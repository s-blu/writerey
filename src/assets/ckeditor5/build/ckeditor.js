/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
!(function (t) {
  const e = (t.en = t.en || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    '%0 of %1': '%0 of %1',
    'Align cell text to the bottom': 'Align cell text to the bottom',
    'Align cell text to the center': 'Align cell text to the center',
    'Align cell text to the left': 'Align cell text to the left',
    'Align cell text to the middle': 'Align cell text to the middle',
    'Align cell text to the right': 'Align cell text to the right',
    'Align cell text to the top': 'Align cell text to the top',
    'Align center': 'Align center',
    'Align left': 'Align left',
    'Align right': 'Align right',
    'Align table to the left': 'Align table to the left',
    'Align table to the right': 'Align table to the right',
    Alignment: 'Alignment',
    Aquamarine: 'Aquamarine',
    Background: 'Background',
    Big: 'Big',
    Black: 'Black',
    'Block quote': 'Block quote',
    Blue: 'Blue',
    'Blue marker': 'Blue marker',
    Bold: 'Bold',
    Border: 'Border',
    'Bulleted List': 'Bulleted List',
    Cancel: 'Cancel',
    'Cell properties': 'Cell properties',
    'Center table': 'Center table',
    'Centered image': 'Centered image',
    'Change image text alternative': 'Change image text alternative',
    'Choose heading': 'Choose heading',
    Color: 'Color',
    'Color picker': 'Color picker',
    Column: 'Column',
    Dashed: 'Dashed',
    'Decrease indent': 'Decrease indent',
    Default: 'Default',
    'Delete column': 'Delete column',
    'Delete row': 'Delete row',
    'Dim grey': 'Dim grey',
    Dimensions: 'Dimensions',
    'Document colors': 'Document colors',
    Dotted: 'Dotted',
    Double: 'Double',
    Downloadable: 'Downloadable',
    'Dropdown toolbar': 'Dropdown toolbar',
    'Edit link': 'Edit link',
    'Editor toolbar': 'Editor toolbar',
    'Enter image caption': 'Enter image caption',
    'Font Background Color': 'Font Background Color',
    'Font Color': 'Font Color',
    'Font Size': 'Font Size',
    'Full size image': 'Full size image',
    Green: 'Green',
    'Green marker': 'Green marker',
    'Green pen': 'Green pen',
    Grey: 'Grey',
    Groove: 'Groove',
    'Header column': 'Header column',
    'Header row': 'Header row',
    Heading: 'Heading',
    'Heading 1': 'Heading 1',
    'Heading 2': 'Heading 2',
    'Heading 3': 'Heading 3',
    'Heading 4': 'Heading 4',
    'Heading 5': 'Heading 5',
    'Heading 6': 'Heading 6',
    Height: 'Height',
    Highlight: 'Highlight',
    'Horizontal text alignment toolbar': 'Horizontal text alignment toolbar',
    Huge: 'Huge',
    'Image toolbar': 'Image toolbar',
    'image widget': 'image widget',
    'Increase indent': 'Increase indent',
    'Insert column left': 'Insert column left',
    'Insert column right': 'Insert column right',
    'Insert image': 'Insert image',
    'Insert media': 'Insert media',
    'Insert paragraph after block': 'Insert paragraph after block',
    'Insert paragraph before block': 'Insert paragraph before block',
    'Insert row above': 'Insert row above',
    'Insert row below': 'Insert row below',
    'Insert table': 'Insert table',
    Inset: 'Inset',
    Italic: 'Italic',
    Justify: 'Justify',
    'Justify cell text': 'Justify cell text',
    'Left aligned image': 'Left aligned image',
    'Light blue': 'Light blue',
    'Light green': 'Light green',
    'Light grey': 'Light grey',
    Link: 'Link',
    'Link URL': 'Link URL',
    'Media URL': 'Media URL',
    'media widget': 'media widget',
    'Merge cell down': 'Merge cell down',
    'Merge cell left': 'Merge cell left',
    'Merge cell right': 'Merge cell right',
    'Merge cell up': 'Merge cell up',
    'Merge cells': 'Merge cells',
    Next: 'Next',
    None: 'None',
    'Numbered List': 'Numbered List',
    'Open in a new tab': 'Open in a new tab',
    'Open link in new tab': 'Open link in new tab',
    Orange: 'Orange',
    Outset: 'Outset',
    Padding: 'Padding',
    Paragraph: 'Paragraph',
    'Paste the media URL in the input.': 'Paste the media URL in the input.',
    'Pink marker': 'Pink marker',
    Previous: 'Previous',
    Purple: 'Purple',
    Red: 'Red',
    'Red pen': 'Red pen',
    Redo: 'Redo',
    'Remove color': 'Remove color',
    'Remove Format': 'Remove Format',
    'Remove highlight': 'Remove highlight',
    'Rich Text Editor, %0': 'Rich Text Editor, %0',
    Ridge: 'Ridge',
    'Right aligned image': 'Right aligned image',
    Row: 'Row',
    Save: 'Save',
    'Select all': 'Select all',
    'Select column': 'Select column',
    'Select row': 'Select row',
    'Show more items': 'Show more items',
    'Side image': 'Side image',
    Small: 'Small',
    Solid: 'Solid',
    'Split cell horizontally': 'Split cell horizontally',
    'Split cell vertically': 'Split cell vertically',
    Strikethrough: 'Strikethrough',
    Style: 'Style',
    'Table alignment toolbar': 'Table alignment toolbar',
    'Table cell text alignment': 'Table cell text alignment',
    'Table properties': 'Table properties',
    'Table toolbar': 'Table toolbar',
    'Text alignment': 'Text alignment',
    'Text alignment toolbar': 'Text alignment toolbar',
    'Text alternative': 'Text alternative',
    'Text highlight toolbar': 'Text highlight toolbar',
    'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".':
      'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
    'The URL must not be empty.': 'The URL must not be empty.',
    'The value is invalid. Try "10px" or "2em" or simply "2".':
      'The value is invalid. Try "10px" or "2em" or simply "2".',
    'This link has no URL': 'This link has no URL',
    'This media URL is not supported.': 'This media URL is not supported.',
    Tiny: 'Tiny',
    'Tip: Paste the URL into the content to embed faster.': 'Tip: Paste the URL into the content to embed faster.',
    Turquoise: 'Turquoise',
    Underline: 'Underline',
    Undo: 'Undo',
    Unlink: 'Unlink',
    'Upload failed': 'Upload failed',
    'Upload in progress': 'Upload in progress',
    'Vertical text alignment toolbar': 'Vertical text alignment toolbar',
    White: 'White',
    'Widget toolbar': 'Widget toolbar',
    Width: 'Width',
    Yellow: 'Yellow',
    'Yellow marker': 'Yellow marker',
  });
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
  (function (t, e) {
    'object' == typeof exports && 'object' == typeof module
      ? (module.exports = e())
      : 'function' == typeof define && define.amd
      ? define([], e)
      : 'object' == typeof exports
      ? (exports.DecoupledDocumentEditor = e())
      : (t.DecoupledDocumentEditor = e());
  })(window, function () {
    return (function (t) {
      var e = {};
      function o(i) {
        if (e[i]) return e[i].exports;
        var n = (e[i] = { i: i, l: !1, exports: {} });
        return t[i].call(n.exports, n, n.exports, o), (n.l = !0), n.exports;
      }
      return (
        (o.m = t),
        (o.c = e),
        (o.d = function (t, e, i) {
          o.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
        }),
        (o.r = function (t) {
          'undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(t, '__esModule', { value: !0 });
        }),
        (o.t = function (t, e) {
          if ((1 & e && (t = o(t)), 8 & e)) return t;
          if (4 & e && 'object' == typeof t && t && t.__esModule) return t;
          var i = Object.create(null);
          if (
            (o.r(i), Object.defineProperty(i, 'default', { enumerable: !0, value: t }), 2 & e && 'string' != typeof t)
          )
            for (var n in t)
              o.d(
                i,
                n,
                function (e) {
                  return t[e];
                }.bind(null, n)
              );
          return i;
        }),
        (o.n = function (t) {
          var e =
            t && t.__esModule
              ? function () {
                  return t.default;
                }
              : function () {
                  return t;
                };
          return o.d(e, 'a', e), e;
        }),
        (o.o = function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }),
        (o.p = ''),
        o((o.s = 118))
      );
    })([
      function (t, e, o) {
        'use strict';
        o.d(e, 'b', function () {
          return i;
        }),
          o.d(e, 'a', function () {
            return n;
          });
        class i extends Error {
          constructor(t, e, o) {
            (t = n(t)),
              o && (t += ' ' + JSON.stringify(o)),
              super(t),
              (this.name = 'CKEditorError'),
              (this.context = e),
              (this.data = o);
          }
          is(t) {
            return 'CKEditorError' === t;
          }
          static rethrowUnexpectedError(t, e) {
            if (t.is && t.is('CKEditorError')) throw t;
            const o = new i(t.message, e);
            throw ((o.stack = t.stack), o);
          }
        }
        function n(t) {
          const e = t.match(/^([^:]+):/);
          return e
            ? t +
                ` Read more: https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html#error-${e[1]}\n`
            : t;
        }
      },
      function (t, e, o) {
        'use strict';
        var i,
          n = function () {
            return void 0 === i && (i = Boolean(window && document && document.all && !window.atob)), i;
          },
          r = (function () {
            var t = {};
            return function (e) {
              if (void 0 === t[e]) {
                var o = document.querySelector(e);
                if (window.HTMLIFrameElement && o instanceof window.HTMLIFrameElement)
                  try {
                    o = o.contentDocument.head;
                  } catch (t) {
                    o = null;
                  }
                t[e] = o;
              }
              return t[e];
            };
          })(),
          s = [];
        function a(t) {
          for (var e = -1, o = 0; o < s.length; o++)
            if (s[o].identifier === t) {
              e = o;
              break;
            }
          return e;
        }
        function l(t, e) {
          for (var o = {}, i = [], n = 0; n < t.length; n++) {
            var r = t[n],
              l = e.base ? r[0] + e.base : r[0],
              c = o[l] || 0,
              d = ''.concat(l, ' ').concat(c);
            o[l] = c + 1;
            var h = a(d),
              u = { css: r[1], media: r[2], sourceMap: r[3] };
            -1 !== h
              ? (s[h].references++, s[h].updater(u))
              : s.push({ identifier: d, updater: p(u, e), references: 1 }),
              i.push(d);
          }
          return i;
        }
        function c(t) {
          var e = document.createElement('style'),
            i = t.attributes || {};
          if (void 0 === i.nonce) {
            var n = o.nc;
            n && (i.nonce = n);
          }
          if (
            (Object.keys(i).forEach(function (t) {
              e.setAttribute(t, i[t]);
            }),
            'function' == typeof t.insert)
          )
            t.insert(e);
          else {
            var s = r(t.insert || 'head');
            if (!s)
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
              );
            s.appendChild(e);
          }
          return e;
        }
        var d,
          h =
            ((d = []),
            function (t, e) {
              return (d[t] = e), d.filter(Boolean).join('\n');
            });
        function u(t, e, o, i) {
          var n = o ? '' : i.media ? '@media '.concat(i.media, ' {').concat(i.css, '}') : i.css;
          if (t.styleSheet) t.styleSheet.cssText = h(e, n);
          else {
            var r = document.createTextNode(n),
              s = t.childNodes;
            s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(r, s[e]) : t.appendChild(r);
          }
        }
        function g(t, e, o) {
          var i = o.css,
            n = o.media,
            r = o.sourceMap;
          if (
            (n ? t.setAttribute('media', n) : t.removeAttribute('media'),
            r &&
              btoa &&
              (i += '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
                ' */'
              )),
            t.styleSheet)
          )
            t.styleSheet.cssText = i;
          else {
            for (; t.firstChild; ) t.removeChild(t.firstChild);
            t.appendChild(document.createTextNode(i));
          }
        }
        var m = null,
          f = 0;
        function p(t, e) {
          var o, i, n;
          if (e.singleton) {
            var r = f++;
            (o = m || (m = c(e))), (i = u.bind(null, o, r, !1)), (n = u.bind(null, o, r, !0));
          } else
            (o = c(e)),
              (i = g.bind(null, o, e)),
              (n = function () {
                !(function (t) {
                  if (null === t.parentNode) return !1;
                  t.parentNode.removeChild(t);
                })(o);
              });
          return (
            i(t),
            function (e) {
              if (e) {
                if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
                i((t = e));
              } else n();
            }
          );
        }
        t.exports = function (t, e) {
          (e = e || {}).singleton || 'boolean' == typeof e.singleton || (e.singleton = n());
          var o = l((t = t || []), e);
          return function (t) {
            if (((t = t || []), '[object Array]' === Object.prototype.toString.call(t))) {
              for (var i = 0; i < o.length; i++) {
                var n = a(o[i]);
                s[n].references--;
              }
              for (var r = l(t, e), c = 0; c < o.length; c++) {
                var d = a(o[c]);
                0 === s[d].references && (s[d].updater(), s.splice(d, 1));
              }
              o = r;
            }
          };
        };
      },
      ,
      function (t, e, o) {
        'use strict';
        var i = o(7),
          n = 'object' == typeof self && self && self.Object === Object && self,
          r = i.a || n || Function('return this')();
        e.a = r;
      },
      function (t, e, o) {
        'use strict';
        (function (t) {
          var i = o(3),
            n = o(14),
            r = 'object' == typeof exports && exports && !exports.nodeType && exports,
            s = r && 'object' == typeof t && t && !t.nodeType && t,
            a = s && s.exports === r ? i.a.Buffer : void 0,
            l = (a ? a.isBuffer : void 0) || n.a;
          e.a = l;
        }.call(this, o(9)(t)));
      },
      function (t, e, o) {
        'use strict';
        (function (t) {
          var i = o(7),
            n = 'object' == typeof exports && exports && !exports.nodeType && exports,
            r = n && 'object' == typeof t && t && !t.nodeType && t,
            s = r && r.exports === n && i.a.process,
            a = (function () {
              try {
                var t = r && r.require && r.require('util').types;
                return t || (s && s.binding && s.binding('util'));
              } catch (t) {}
            })();
          e.a = a;
        }.call(this, o(9)(t)));
      },
      function (t, e, o) {
        'use strict';
        (function (t) {
          var e = o(0);
          const i = 'object' == typeof window ? window : t;
          if (i.CKEDITOR_VERSION)
            throw new e.b('ckeditor-duplicated-modules: Some CKEditor 5 modules are duplicated.', null);
          i.CKEDITOR_VERSION = '19.1.1';
        }.call(this, o(10)));
      },
      function (t, e, o) {
        'use strict';
        (function (t) {
          var o = 'object' == typeof t && t && t.Object === Object && t;
          e.a = o;
        }.call(this, o(10)));
      },
      function (t, e, o) {
        'use strict';
        (function (t) {
          var i = o(3),
            n = 'object' == typeof exports && exports && !exports.nodeType && exports,
            r = n && 'object' == typeof t && t && !t.nodeType && t,
            s = r && r.exports === n ? i.a.Buffer : void 0,
            a = s ? s.allocUnsafe : void 0;
          e.a = function (t, e) {
            if (e) return t.slice();
            var o = t.length,
              i = a ? a(o) : new t.constructor(o);
            return t.copy(i), i;
          };
        }.call(this, o(9)(t)));
      },
      function (t, e) {
        t.exports = function (t) {
          if (!t.webpackPolyfill) {
            var e = Object.create(t);
            e.children || (e.children = []),
              Object.defineProperty(e, 'loaded', {
                enumerable: !0,
                get: function () {
                  return e.l;
                },
              }),
              Object.defineProperty(e, 'id', {
                enumerable: !0,
                get: function () {
                  return e.i;
                },
              }),
              Object.defineProperty(e, 'exports', { enumerable: !0 }),
              (e.webpackPolyfill = 1);
          }
          return e;
        };
      },
      function (t, e) {
        var o;
        o = (function () {
          return this;
        })();
        try {
          o = o || new Function('return this')();
        } catch (t) {
          'object' == typeof window && (o = window);
        }
        t.exports = o;
      },
      function (t, e, o) {
        var i = o(1),
          n = o(49);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e, o) {
        var i = o(1),
          n = o(112);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e, o) {
        var i = o(1),
          n = o(113);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e, o) {
        'use strict';
        e.a = function () {
          return !1;
        };
      },
      function (t, e, o) {
        var i = o(1),
          n = o(16);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(18);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999);--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#5c5c5c;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(20);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(22);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}:root{--ck-dropdown-arrow-size:calc(0.5*var(--ck-icon-size))}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(24);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(26);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_n{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(28);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(-1*var(--ck-spacing-small));margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(-1*var(--ck-spacing-small));margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(30);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(0.2*var(--ck-line-height-base)*var(--ck-font-size-base)) calc(0.4*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(1.2*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(32);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2*var(--ck-switch-button-toggle-spacing))}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(2*var(--ck-spacing-large))}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(2*var(--ck-spacing-large))}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(0.5*var(--ck-border-radius))}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(-1*var(--ck-switch-button-translation)))}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(34);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-toolbar-dropdown .ck.ck-toolbar .ck.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(36);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(38);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;margin-top:0;margin-bottom:0;background:var(--ck-color-toolbar-border)}.ck.ck-toolbar>.ck-toolbar__items>*{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>*,.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(40);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(42);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(44);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports = '.ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(46);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-button.ck-color-table__remove-color{display:flex;align-items:center;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(48);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}';
      },
      function (t, e) {
        t.exports =
          '.ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(51);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-radius:0}.ck-rounded-corners [dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow,[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-left-color:var(--ck-color-split-button-hover-border)}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-right-color:var(--ck-color-split-button-hover-border)}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(53);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{color:var(--ck-highlight-pen-red);background-color:transparent}.ck-content .pen-green{color:var(--ck-highlight-pen-green);background-color:transparent}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(55);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(57);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(-0.5*var(--ck-widget-outline-thickness));left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(-0.5*var(--ck-widget-outline-thickness));right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget:not(.ck-widget_can-type-around_after)>.ck-widget__type-around>.ck-widget__type-around__button_after,.ck .ck-widget:not(.ck-widget_can-type-around_before)>.ck-widget__type-around>.ck-widget__type-around__button_before{display:none}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;pointer-events:none;opacity:0;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{pointer-events:auto;opacity:1}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{pointer-events:none;opacity:0}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(59);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(61);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view>.ck.ck-label{width:100%;text-overflow:ellipsis;overflow:hidden}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(63);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{box-shadow:var(--ck-inner-shadow),0 0;background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .2s ease-in-out,border .2s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),var(--ck-inner-shadow)}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(65);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}.ck.ck-text-alternative-form{padding:var(--ck-spacing-standard)}.ck.ck-text-alternative-form:focus{outline:none}[dir=ltr] .ck.ck-text-alternative-form>:not(:first-child),[dir=rtl] .ck.ck-text-alternative-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-text-alternative-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-text-alternative-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-text-alternative-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-text-alternative-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-text-alternative-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-text-alternative-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(67);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(69);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(71);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image>img{display:block;margin:0 auto;max-width:100%;min-width:50px}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(73);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:#333;background-color:#f7f7f7;padding:.6em;font-size:.75em;outline-offset:-1px}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(75);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0;outline:1px solid var(--ck-color-resizer)}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all;width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nesw-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nesw-resize}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(77);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-content .image.image_resized{max-width:100%;display:block;box-sizing:border-box}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(79);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-image-style-spacing:1.5em}.ck-content .image-style-align-center,.ck-content .image-style-align-left,.ck-content .image-style-align-right,.ck-content .image-style-side{max-width:50%}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(81);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(83);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(85);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(87);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports = '.ck .ck-link_selected{background:var(--ck-color-link-selected-background)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(89);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form{padding:var(--ck-spacing-standard)}.ck.ck-link-form:focus{outline:none}[dir=ltr] .ck.ck-link-form>:not(:first-child),[dir=rtl] .ck.ck-link-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin-left:0}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(91);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions{padding:var(--ck-spacing-standard)}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}.ck.ck-link-actions:focus{outline:none}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):last-of-type{border-right:1px solid var(--ck-color-base-border)}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(93);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-media__wrapper .ck-media__placeholder{display:flex;flex-direction:column;align-items:center}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{visibility:visible;opacity:1}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{overflow:hidden;display:block}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{padding:calc(3*var(--ck-spacing-standard));background:var(--ck-color-base-foreground)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{min-width:var(--ck-media-embed-placeholder-icon-size);height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);background-position:50%;background-size:cover}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{width:100%;height:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);white-space:nowrap;text-align:center;font-style:italic;text-overflow:ellipsis}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-width:300px;max-height:380px}.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMDAzLjc4IDEuNjFoNDkuNjIxYzEuNjk0IDAgMy4xOS0uNzk4IDQuMTQ2LTIuMDM3eiIgZmlsbD0iIzVjODhjNSIvPjxwYXRoIGQ9Ik0yMjYuNzQyIDIyMi45ODhjLTkuMjY2IDAtMTYuNzc3IDcuMTctMTYuNzc3IDE2LjAxNC4wMDcgMi43NjIuNjYzIDUuNDc0IDIuMDkzIDcuODc1LjQzLjcwMy44MyAxLjQwOCAxLjE5IDIuMTA3LjMzMy41MDIuNjUgMS4wMDUuOTUgMS41MDguMzQzLjQ3Ny42NzMuOTU3Ljk4OCAxLjQ0IDEuMzEgMS43NjkgMi41IDMuNTAyIDMuNjM3IDUuMTY4Ljc5MyAxLjI3NSAxLjY4MyAyLjY0IDIuNDY2IDMuOTkgMi4zNjMgNC4wOTQgNC4wMDcgOC4wOTIgNC42IDEzLjkxNHYuMDEyYy4xODIuNDEyLjUxNi42NjYuODc5LjY2Ny40MDMtLjAwMS43NjgtLjMxNC45My0uNzk5LjYwMy01Ljc1NiAyLjIzOC05LjcyOSA0LjU4NS0xMy43OTQuNzgyLTEuMzUgMS42NzMtMi43MTUgMi40NjUtMy45OSAxLjEzNy0xLjY2NiAyLjMyOC0zLjQgMy42MzgtNS4xNjkuMzE1LS40ODIuNjQ1LS45NjIuOTg4LTEuNDM5LjMtLjUwMy42MTctMS4wMDYuOTUtMS41MDguMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0eiIgZmlsbD0iI2RkNGIzZSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48ZWxsaXBzZSByeT0iNS41NjQiIHJ4PSI1LjgyOCIgY3k9IjIzOS4wMDIiIGN4PSIyMjYuNzQyIiBmaWxsPSIjODAyZDI3IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0xOTAuMzAxIDIzNy4yODNjLTQuNjcgMC04LjQ1NyAzLjg1My04LjQ1NyA4LjYwNnMzLjc4NiA4LjYwNyA4LjQ1NyA4LjYwN2MzLjA0MyAwIDQuODA2LS45NTggNi4zMzctMi41MTYgMS41My0xLjU1NyAyLjA4Ny0zLjkxMyAyLjA4Ny02LjI5IDAtLjM2Mi0uMDIzLS43MjItLjA2NC0xLjA3OWgtOC4yNTd2My4wNDNoNC44NWMtLjE5Ny43NTktLjUzMSAxLjQ1LTEuMDU4IDEuOTg2LS45NDIuOTU4LTIuMDI4IDEuNTQ4LTMuOTAxIDEuNTQ4LTIuODc2IDAtNS4yMDgtMi4zNzItNS4yMDgtNS4yOTkgMC0yLjkyNiAyLjMzMi01LjI5OSA1LjIwOC01LjI5OSAxLjM5OSAwIDIuNjE4LjQwNyAzLjU4NCAxLjI5M2wyLjM4MS0yLjM4YzAtLjAwMi0uMDAzLS4wMDQtLjAwNC0uMDA1LTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTV6bTQuNDMgNS42NmwuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxNS4xODQgMjUxLjkyOWwtNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMjMzIDUuMjMzIDAgMDAuNDQ5LTIuMTIzdi0zMS4xNjVjLS40NjkuNjc1LS45MzQgMS4zNDktMS4zODIgMi4wMDUtLjc5MiAxLjI3NS0xLjY4MiAyLjY0LTIuNDY1IDMuOTktMi4zNDcgNC4wNjUtMy45ODIgOC4wMzgtNC41ODUgMTMuNzk0LS4xNjIuNDg1LS41MjcuNzk4LS45My43OTktLjM2My0uMDAxLS42OTctLjI1NS0uODc5LS42Njd2LS4wMTJjLS41OTMtNS44MjItMi4yMzctOS44Mi00LjYtMTMuOTE0LS43ODMtMS4zNS0xLjY3My0yLjcxNS0yLjQ2Ni0zLjk5LTEuMTM3LTEuNjY2LTIuMzI3LTMuNC0zLjYzNy01LjE2OWwtLjAwMi0uMDAzeiIgZmlsbD0iI2MzYzNjMyIvPjxwYXRoIGQ9Ik0yMTIuOTgzIDI0OC40OTVsLTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAwNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYuMjc1IDEzNi4yNzUgMCAwMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAwLS45ODktMS40NCAzNS4xMjcgMzUuMTI3IDAgMDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OXoiIGZpbGw9IiNmZGRjNGYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxMS45OTggMjYxLjA4M2wtNi4xNTIgNi4xNTEgMjQuMjY0IDI0LjI2NGguNzgxYTUuMjI3IDUuMjI3IDAgMDA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OXptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OXoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzN6bTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1ek00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(95);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-media-form{display:flex;align-items:flex-start;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}.ck.ck-media-form{padding:var(--ck-spacing-standard)}.ck.ck-media-form:focus{outline:none}[dir=ltr] .ck.ck-media-form>:not(:first-child),[dir=rtl] .ck.ck-media-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-media-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-media-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-media-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-media-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-media-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-media-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-media-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-media-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-media-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(97);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports = '.ck-content .media{clear:both;margin:1em 0;display:block;min-width:15em}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(99);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(101);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(103);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          ':root{--ck-table-selected-cell-background:rgba(158,207,250,0.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{position:relative;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{content:"";pointer-events:none;background-color:var(--ck-table-selected-cell-background);position:absolute;top:0;left:0;right:0;bottom:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget_selected{outline:unset}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(105);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck-content .table{margin:1em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(107);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-input-color{width:100%;display:flex}.ck.ck-input-color>input.ck.ck-input-text{min-width:auto;flex-grow:1}.ck.ck-input-color>input.ck.ck-input-text:active,.ck.ck-input-color>input.ck.ck-input-text:focus{z-index:var(--ck-z-default)}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{position:relative;overflow:hidden}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{position:absolute;display:block}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{border-top-left-radius:0;border-bottom-left-radius:0;margin-left:-1px}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{border-top-right-radius:0;border-bottom-right-radius:0;margin-right:-1px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview{width:20px;height:20px;border:1px solid var(--ck-color-input-border)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{top:-30%;left:50%;height:150%;width:8%;background:red;border-radius:2px;transform:rotate(45deg);transform-origin:50%}.ck.ck-input-color .ck.ck-input-color__remove-color{width:100%;border-bottom:1px solid var(--ck-color-input-border);padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:0;margin-left:var(--ck-spacing-standard)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(109);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{width:100%;min-width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(111);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-form__header{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{padding:var(--ck-spacing-small) var(--ck-spacing-large);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}';
      },
      function (t, e) {
        t.exports =
          '.ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}';
      },
      function (t, e) {
        t.exports =
          '.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view{display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{flex-grow:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{flex-wrap:wrap;align-items:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{display:flex;flex-direction:column-reverse;align-items:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{position:absolute;left:50%;bottom:calc(-1*var(--ck-table-properties-error-arrow-size));transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";position:absolute;top:calc(-1*var(--ck-table-properties-error-arrow-size));left:50%;transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style{width:80px;min-width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{width:50px;min-width:50px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view>.ck-label{font-size:10px;text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:start;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);padding:var(--ck-spacing-small) var(--ck-spacing-medium);min-width:var(--ck-table-properties-min-error-width);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-left:var(--ck-table-properties-error-arrow-size) solid transparent;border-bottom:var(--ck-table-properties-error-arrow-size) solid var(--ck-color-base-error);border-right:var(--ck-table-properties-error-arrow-size) solid transparent;border-top:0 solid transparent}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(115);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{flex-wrap:wrap;flex-basis:0;align-content:baseline}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}';
      },
      function (t, e, o) {
        var i = o(1),
          n = o(117);
        'string' == typeof (n = n.__esModule ? n.default : n) && (n = [[t.i, n, '']]);
        var r = { injectType: 'singletonStyleTag', insert: 'head', singleton: !0 };
        i(n, r);
        t.exports = n.locals || {};
      },
      function (t, e) {
        t.exports =
          '.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{flex-grow:0}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{padding:0;width:35%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none}';
      },
      function (t, e, o) {
        'use strict';
        o.r(e);
        var i = o(3),
          n = i.a.Symbol,
          r = Object.prototype,
          s = r.hasOwnProperty,
          a = r.toString,
          l = n ? n.toStringTag : void 0;
        var c = function (t) {
            var e = s.call(t, l),
              o = t[l];
            try {
              t[l] = void 0;
              var i = !0;
            } catch (t) {}
            var n = a.call(t);
            return i && (e ? (t[l] = o) : delete t[l]), n;
          },
          d = Object.prototype.toString;
        var h = function (t) {
            return d.call(t);
          },
          u = n ? n.toStringTag : void 0;
        var g = function (t) {
          return null == t
            ? void 0 === t
              ? '[object Undefined]'
              : '[object Null]'
            : u && u in Object(t)
            ? c(t)
            : h(t);
        };
        var m = function (t, e) {
            return function (o) {
              return t(e(o));
            };
          },
          f = m(Object.getPrototypeOf, Object);
        var p = function (t) {
            return null != t && 'object' == typeof t;
          },
          b = Function.prototype,
          w = Object.prototype,
          k = b.toString,
          _ = w.hasOwnProperty,
          v = k.call(Object);
        var y = function (t) {
          if (!p(t) || '[object Object]' != g(t)) return !1;
          var e = f(t);
          if (null === e) return !0;
          var o = _.call(e, 'constructor') && e.constructor;
          return 'function' == typeof o && o instanceof o && k.call(o) == v;
        };
        var x = function () {
          (this.__data__ = []), (this.size = 0);
        };
        var C = function (t, e) {
          return t === e || (t != t && e != e);
        };
        var A = function (t, e) {
            for (var o = t.length; o--; ) if (C(t[o][0], e)) return o;
            return -1;
          },
          T = Array.prototype.splice;
        var S = function (t) {
          var e = this.__data__,
            o = A(e, t);
          return !(o < 0) && (o == e.length - 1 ? e.pop() : T.call(e, o, 1), --this.size, !0);
        };
        var P = function (t) {
          var e = this.__data__,
            o = A(e, t);
          return o < 0 ? void 0 : e[o][1];
        };
        var E = function (t) {
          return A(this.__data__, t) > -1;
        };
        var M = function (t, e) {
          var o = this.__data__,
            i = A(o, t);
          return i < 0 ? (++this.size, o.push([t, e])) : (o[i][1] = e), this;
        };
        function I(t) {
          var e = -1,
            o = null == t ? 0 : t.length;
          for (this.clear(); ++e < o; ) {
            var i = t[e];
            this.set(i[0], i[1]);
          }
        }
        (I.prototype.clear = x),
          (I.prototype.delete = S),
          (I.prototype.get = P),
          (I.prototype.has = E),
          (I.prototype.set = M);
        var N = I;
        var R = function () {
          (this.__data__ = new N()), (this.size = 0);
        };
        var O = function (t) {
          var e = this.__data__,
            o = e.delete(t);
          return (this.size = e.size), o;
        };
        var V = function (t) {
          return this.__data__.get(t);
        };
        var D = function (t) {
          return this.__data__.has(t);
        };
        var z = function (t) {
          var e = typeof t;
          return null != t && ('object' == e || 'function' == e);
        };
        var L,
          j = function (t) {
            if (!z(t)) return !1;
            var e = g(t);
            return (
              '[object Function]' == e ||
              '[object GeneratorFunction]' == e ||
              '[object AsyncFunction]' == e ||
              '[object Proxy]' == e
            );
          },
          B = i.a['__core-js_shared__'],
          F = (L = /[^.]+$/.exec((B && B.keys && B.keys.IE_PROTO) || '')) ? 'Symbol(src)_1.' + L : '';
        var H = function (t) {
            return !!F && F in t;
          },
          W = Function.prototype.toString;
        var U = function (t) {
            if (null != t) {
              try {
                return W.call(t);
              } catch (t) {}
              try {
                return t + '';
              } catch (t) {}
            }
            return '';
          },
          q = /^\[object .+?Constructor\]$/,
          G = Function.prototype,
          Y = Object.prototype,
          $ = G.toString,
          Q = Y.hasOwnProperty,
          K = RegExp(
            '^' +
              $.call(Q)
                .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
              '$'
          );
        var J = function (t) {
          return !(!z(t) || H(t)) && (j(t) ? K : q).test(U(t));
        };
        var Z = function (t, e) {
          return null == t ? void 0 : t[e];
        };
        var X = function (t, e) {
            var o = Z(t, e);
            return J(o) ? o : void 0;
          },
          tt = X(i.a, 'Map'),
          et = X(Object, 'create');
        var ot = function () {
          (this.__data__ = et ? et(null) : {}), (this.size = 0);
        };
        var it = function (t) {
            var e = this.has(t) && delete this.__data__[t];
            return (this.size -= e ? 1 : 0), e;
          },
          nt = Object.prototype.hasOwnProperty;
        var rt = function (t) {
            var e = this.__data__;
            if (et) {
              var o = e[t];
              return '__lodash_hash_undefined__' === o ? void 0 : o;
            }
            return nt.call(e, t) ? e[t] : void 0;
          },
          st = Object.prototype.hasOwnProperty;
        var at = function (t) {
          var e = this.__data__;
          return et ? void 0 !== e[t] : st.call(e, t);
        };
        var lt = function (t, e) {
          var o = this.__data__;
          return (
            (this.size += this.has(t) ? 0 : 1), (o[t] = et && void 0 === e ? '__lodash_hash_undefined__' : e), this
          );
        };
        function ct(t) {
          var e = -1,
            o = null == t ? 0 : t.length;
          for (this.clear(); ++e < o; ) {
            var i = t[e];
            this.set(i[0], i[1]);
          }
        }
        (ct.prototype.clear = ot),
          (ct.prototype.delete = it),
          (ct.prototype.get = rt),
          (ct.prototype.has = at),
          (ct.prototype.set = lt);
        var dt = ct;
        var ht = function () {
          (this.size = 0), (this.__data__ = { hash: new dt(), map: new (tt || N)(), string: new dt() });
        };
        var ut = function (t) {
          var e = typeof t;
          return 'string' == e || 'number' == e || 'symbol' == e || 'boolean' == e ? '__proto__' !== t : null === t;
        };
        var gt = function (t, e) {
          var o = t.__data__;
          return ut(e) ? o['string' == typeof e ? 'string' : 'hash'] : o.map;
        };
        var mt = function (t) {
          var e = gt(this, t).delete(t);
          return (this.size -= e ? 1 : 0), e;
        };
        var ft = function (t) {
          return gt(this, t).get(t);
        };
        var pt = function (t) {
          return gt(this, t).has(t);
        };
        var bt = function (t, e) {
          var o = gt(this, t),
            i = o.size;
          return o.set(t, e), (this.size += o.size == i ? 0 : 1), this;
        };
        function wt(t) {
          var e = -1,
            o = null == t ? 0 : t.length;
          for (this.clear(); ++e < o; ) {
            var i = t[e];
            this.set(i[0], i[1]);
          }
        }
        (wt.prototype.clear = ht),
          (wt.prototype.delete = mt),
          (wt.prototype.get = ft),
          (wt.prototype.has = pt),
          (wt.prototype.set = bt);
        var kt = wt;
        var _t = function (t, e) {
          var o = this.__data__;
          if (o instanceof N) {
            var i = o.__data__;
            if (!tt || i.length < 199) return i.push([t, e]), (this.size = ++o.size), this;
            o = this.__data__ = new kt(i);
          }
          return o.set(t, e), (this.size = o.size), this;
        };
        function vt(t) {
          var e = (this.__data__ = new N(t));
          this.size = e.size;
        }
        (vt.prototype.clear = R),
          (vt.prototype.delete = O),
          (vt.prototype.get = V),
          (vt.prototype.has = D),
          (vt.prototype.set = _t);
        var yt = vt;
        var xt = function (t, e) {
            for (var o = -1, i = null == t ? 0 : t.length; ++o < i && !1 !== e(t[o], o, t); );
            return t;
          },
          Ct = (function () {
            try {
              var t = X(Object, 'defineProperty');
              return t({}, '', {}), t;
            } catch (t) {}
          })();
        var At = function (t, e, o) {
            '__proto__' == e && Ct
              ? Ct(t, e, { configurable: !0, enumerable: !0, value: o, writable: !0 })
              : (t[e] = o);
          },
          Tt = Object.prototype.hasOwnProperty;
        var St = function (t, e, o) {
          var i = t[e];
          (Tt.call(t, e) && C(i, o) && (void 0 !== o || e in t)) || At(t, e, o);
        };
        var Pt = function (t, e, o, i) {
          var n = !o;
          o || (o = {});
          for (var r = -1, s = e.length; ++r < s; ) {
            var a = e[r],
              l = i ? i(o[a], t[a], a, o, t) : void 0;
            void 0 === l && (l = t[a]), n ? At(o, a, l) : St(o, a, l);
          }
          return o;
        };
        var Et = function (t, e) {
          for (var o = -1, i = Array(t); ++o < t; ) i[o] = e(o);
          return i;
        };
        var Mt = function (t) {
            return p(t) && '[object Arguments]' == g(t);
          },
          It = Object.prototype,
          Nt = It.hasOwnProperty,
          Rt = It.propertyIsEnumerable,
          Ot = Mt(
            (function () {
              return arguments;
            })()
          )
            ? Mt
            : function (t) {
                return p(t) && Nt.call(t, 'callee') && !Rt.call(t, 'callee');
              },
          Vt = Array.isArray,
          Dt = o(4),
          zt = /^(?:0|[1-9]\d*)$/;
        var Lt = function (t, e) {
          var o = typeof t;
          return (
            !!(e = null == e ? 9007199254740991 : e) &&
            ('number' == o || ('symbol' != o && zt.test(t))) &&
            t > -1 &&
            t % 1 == 0 &&
            t < e
          );
        };
        var jt = function (t) {
            return 'number' == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991;
          },
          Bt = {};
        (Bt['[object Float32Array]'] = Bt['[object Float64Array]'] = Bt['[object Int8Array]'] = Bt[
          '[object Int16Array]'
        ] = Bt['[object Int32Array]'] = Bt['[object Uint8Array]'] = Bt['[object Uint8ClampedArray]'] = Bt[
          '[object Uint16Array]'
        ] = Bt['[object Uint32Array]'] = !0),
          (Bt['[object Arguments]'] = Bt['[object Array]'] = Bt['[object ArrayBuffer]'] = Bt['[object Boolean]'] = Bt[
            '[object DataView]'
          ] = Bt['[object Date]'] = Bt['[object Error]'] = Bt['[object Function]'] = Bt['[object Map]'] = Bt[
            '[object Number]'
          ] = Bt['[object Object]'] = Bt['[object RegExp]'] = Bt['[object Set]'] = Bt['[object String]'] = Bt[
            '[object WeakMap]'
          ] = !1);
        var Ft = function (t) {
          return p(t) && jt(t.length) && !!Bt[g(t)];
        };
        var Ht = function (t) {
            return function (e) {
              return t(e);
            };
          },
          Wt = o(5),
          Ut = Wt.a && Wt.a.isTypedArray,
          qt = Ut ? Ht(Ut) : Ft,
          Gt = Object.prototype.hasOwnProperty;
        var Yt = function (t, e) {
            var o = Vt(t),
              i = !o && Ot(t),
              n = !o && !i && Object(Dt.a)(t),
              r = !o && !i && !n && qt(t),
              s = o || i || n || r,
              a = s ? Et(t.length, String) : [],
              l = a.length;
            for (var c in t)
              (!e && !Gt.call(t, c)) ||
                (s &&
                  ('length' == c ||
                    (n && ('offset' == c || 'parent' == c)) ||
                    (r && ('buffer' == c || 'byteLength' == c || 'byteOffset' == c)) ||
                    Lt(c, l))) ||
                a.push(c);
            return a;
          },
          $t = Object.prototype;
        var Qt = function (t) {
            var e = t && t.constructor;
            return t === (('function' == typeof e && e.prototype) || $t);
          },
          Kt = m(Object.keys, Object),
          Jt = Object.prototype.hasOwnProperty;
        var Zt = function (t) {
          if (!Qt(t)) return Kt(t);
          var e = [];
          for (var o in Object(t)) Jt.call(t, o) && 'constructor' != o && e.push(o);
          return e;
        };
        var Xt = function (t) {
          return null != t && jt(t.length) && !j(t);
        };
        var te = function (t) {
          return Xt(t) ? Yt(t) : Zt(t);
        };
        var ee = function (t, e) {
          return t && Pt(e, te(e), t);
        };
        var oe = function (t) {
            var e = [];
            if (null != t) for (var o in Object(t)) e.push(o);
            return e;
          },
          ie = Object.prototype.hasOwnProperty;
        var ne = function (t) {
          if (!z(t)) return oe(t);
          var e = Qt(t),
            o = [];
          for (var i in t) ('constructor' != i || (!e && ie.call(t, i))) && o.push(i);
          return o;
        };
        var re = function (t) {
          return Xt(t) ? Yt(t, !0) : ne(t);
        };
        var se = function (t, e) {
            return t && Pt(e, re(e), t);
          },
          ae = o(8);
        var le = function (t, e) {
          var o = -1,
            i = t.length;
          for (e || (e = Array(i)); ++o < i; ) e[o] = t[o];
          return e;
        };
        var ce = function (t, e) {
          for (var o = -1, i = null == t ? 0 : t.length, n = 0, r = []; ++o < i; ) {
            var s = t[o];
            e(s, o, t) && (r[n++] = s);
          }
          return r;
        };
        var de = function () {
            return [];
          },
          he = Object.prototype.propertyIsEnumerable,
          ue = Object.getOwnPropertySymbols,
          ge = ue
            ? function (t) {
                return null == t
                  ? []
                  : ((t = Object(t)),
                    ce(ue(t), function (e) {
                      return he.call(t, e);
                    }));
              }
            : de;
        var me = function (t, e) {
          return Pt(t, ge(t), e);
        };
        var fe = function (t, e) {
            for (var o = -1, i = e.length, n = t.length; ++o < i; ) t[n + o] = e[o];
            return t;
          },
          pe = Object.getOwnPropertySymbols
            ? function (t) {
                for (var e = []; t; ) fe(e, ge(t)), (t = f(t));
                return e;
              }
            : de;
        var be = function (t, e) {
          return Pt(t, pe(t), e);
        };
        var we = function (t, e, o) {
          var i = e(t);
          return Vt(t) ? i : fe(i, o(t));
        };
        var ke = function (t) {
          return we(t, te, ge);
        };
        var _e = function (t) {
            return we(t, re, pe);
          },
          ve = X(i.a, 'DataView'),
          ye = X(i.a, 'Promise'),
          xe = X(i.a, 'Set'),
          Ce = X(i.a, 'WeakMap'),
          Ae = U(ve),
          Te = U(tt),
          Se = U(ye),
          Pe = U(xe),
          Ee = U(Ce),
          Me = g;
        ((ve && '[object DataView]' != Me(new ve(new ArrayBuffer(1)))) ||
          (tt && '[object Map]' != Me(new tt())) ||
          (ye && '[object Promise]' != Me(ye.resolve())) ||
          (xe && '[object Set]' != Me(new xe())) ||
          (Ce && '[object WeakMap]' != Me(new Ce()))) &&
          (Me = function (t) {
            var e = g(t),
              o = '[object Object]' == e ? t.constructor : void 0,
              i = o ? U(o) : '';
            if (i)
              switch (i) {
                case Ae:
                  return '[object DataView]';
                case Te:
                  return '[object Map]';
                case Se:
                  return '[object Promise]';
                case Pe:
                  return '[object Set]';
                case Ee:
                  return '[object WeakMap]';
              }
            return e;
          });
        var Ie = Me,
          Ne = Object.prototype.hasOwnProperty;
        var Re = function (t) {
            var e = t.length,
              o = new t.constructor(e);
            return e && 'string' == typeof t[0] && Ne.call(t, 'index') && ((o.index = t.index), (o.input = t.input)), o;
          },
          Oe = i.a.Uint8Array;
        var Ve = function (t) {
          var e = new t.constructor(t.byteLength);
          return new Oe(e).set(new Oe(t)), e;
        };
        var De = function (t, e) {
            var o = e ? Ve(t.buffer) : t.buffer;
            return new t.constructor(o, t.byteOffset, t.byteLength);
          },
          ze = /\w*$/;
        var Le = function (t) {
            var e = new t.constructor(t.source, ze.exec(t));
            return (e.lastIndex = t.lastIndex), e;
          },
          je = n ? n.prototype : void 0,
          Be = je ? je.valueOf : void 0;
        var Fe = function (t) {
          return Be ? Object(Be.call(t)) : {};
        };
        var He = function (t, e) {
          var o = e ? Ve(t.buffer) : t.buffer;
          return new t.constructor(o, t.byteOffset, t.length);
        };
        var We = function (t, e, o) {
            var i = t.constructor;
            switch (e) {
              case '[object ArrayBuffer]':
                return Ve(t);
              case '[object Boolean]':
              case '[object Date]':
                return new i(+t);
              case '[object DataView]':
                return De(t, o);
              case '[object Float32Array]':
              case '[object Float64Array]':
              case '[object Int8Array]':
              case '[object Int16Array]':
              case '[object Int32Array]':
              case '[object Uint8Array]':
              case '[object Uint8ClampedArray]':
              case '[object Uint16Array]':
              case '[object Uint32Array]':
                return He(t, o);
              case '[object Map]':
                return new i();
              case '[object Number]':
              case '[object String]':
                return new i(t);
              case '[object RegExp]':
                return Le(t);
              case '[object Set]':
                return new i();
              case '[object Symbol]':
                return Fe(t);
            }
          },
          Ue = Object.create,
          qe = (function () {
            function t() {}
            return function (e) {
              if (!z(e)) return {};
              if (Ue) return Ue(e);
              t.prototype = e;
              var o = new t();
              return (t.prototype = void 0), o;
            };
          })();
        var Ge = function (t) {
          return 'function' != typeof t.constructor || Qt(t) ? {} : qe(f(t));
        };
        var Ye = function (t) {
            return p(t) && '[object Map]' == Ie(t);
          },
          $e = Wt.a && Wt.a.isMap,
          Qe = $e ? Ht($e) : Ye;
        var Ke = function (t) {
            return p(t) && '[object Set]' == Ie(t);
          },
          Je = Wt.a && Wt.a.isSet,
          Ze = Je ? Ht(Je) : Ke,
          Xe = {};
        (Xe['[object Arguments]'] = Xe['[object Array]'] = Xe['[object ArrayBuffer]'] = Xe['[object DataView]'] = Xe[
          '[object Boolean]'
        ] = Xe['[object Date]'] = Xe['[object Float32Array]'] = Xe['[object Float64Array]'] = Xe[
          '[object Int8Array]'
        ] = Xe['[object Int16Array]'] = Xe['[object Int32Array]'] = Xe['[object Map]'] = Xe['[object Number]'] = Xe[
          '[object Object]'
        ] = Xe['[object RegExp]'] = Xe['[object Set]'] = Xe['[object String]'] = Xe['[object Symbol]'] = Xe[
          '[object Uint8Array]'
        ] = Xe['[object Uint8ClampedArray]'] = Xe['[object Uint16Array]'] = Xe['[object Uint32Array]'] = !0),
          (Xe['[object Error]'] = Xe['[object Function]'] = Xe['[object WeakMap]'] = !1);
        var to = function t(e, o, i, n, r, s) {
          var a,
            l = 1 & o,
            c = 2 & o,
            d = 4 & o;
          if ((i && (a = r ? i(e, n, r, s) : i(e)), void 0 !== a)) return a;
          if (!z(e)) return e;
          var h = Vt(e);
          if (h) {
            if (((a = Re(e)), !l)) return le(e, a);
          } else {
            var u = Ie(e),
              g = '[object Function]' == u || '[object GeneratorFunction]' == u;
            if (Object(Dt.a)(e)) return Object(ae.a)(e, l);
            if ('[object Object]' == u || '[object Arguments]' == u || (g && !r)) {
              if (((a = c || g ? {} : Ge(e)), !l)) return c ? be(e, se(a, e)) : me(e, ee(a, e));
            } else {
              if (!Xe[u]) return r ? e : {};
              a = We(e, u, l);
            }
          }
          s || (s = new yt());
          var m = s.get(e);
          if (m) return m;
          s.set(e, a),
            Ze(e)
              ? e.forEach(function (n) {
                  a.add(t(n, o, i, n, e, s));
                })
              : Qe(e) &&
                e.forEach(function (n, r) {
                  a.set(r, t(n, o, i, r, e, s));
                });
          var f = d ? (c ? _e : ke) : c ? keysIn : te,
            p = h ? void 0 : f(e);
          return (
            xt(p || e, function (n, r) {
              p && (n = e[(r = n)]), St(a, r, t(n, o, i, r, e, s));
            }),
            a
          );
        };
        var eo = function (t, e) {
          return to(t, 5, (e = 'function' == typeof e ? e : void 0));
        };
        var oo = function (t) {
          return p(t) && 1 === t.nodeType && !y(t);
        };
        class io {
          constructor(t, e) {
            (this._config = {}), e && this.define(no(e)), t && this._setObjectToTarget(this._config, t);
          }
          set(t, e) {
            this._setToTarget(this._config, t, e);
          }
          define(t, e) {
            this._setToTarget(this._config, t, e, !0);
          }
          get(t) {
            return this._getFromSource(this._config, t);
          }
          *names() {
            for (const t of Object.keys(this._config)) yield t;
          }
          _setToTarget(t, e, o, i = !1) {
            if (y(e)) return void this._setObjectToTarget(t, e, i);
            const n = e.split('.');
            e = n.pop();
            for (const e of n) y(t[e]) || (t[e] = {}), (t = t[e]);
            if (y(o)) return y(t[e]) || (t[e] = {}), (t = t[e]), void this._setObjectToTarget(t, o, i);
            (i && void 0 !== t[e]) || (t[e] = o);
          }
          _getFromSource(t, e) {
            const o = e.split('.');
            e = o.pop();
            for (const e of o) {
              if (!y(t[e])) {
                t = null;
                break;
              }
              t = t[e];
            }
            return t ? no(t[e]) : void 0;
          }
          _setObjectToTarget(t, e, o) {
            Object.keys(e).forEach(i => {
              this._setToTarget(t, i, e[i], o);
            });
          }
        }
        function no(t) {
          return eo(t, ro);
        }
        function ro(t) {
          return oo(t) ? t : void 0;
        }
        var so = function () {
          return function t() {
            t.called = !0;
          };
        };
        class ao {
          constructor(t, e) {
            (this.source = t), (this.name = e), (this.path = []), (this.stop = so()), (this.off = so());
          }
        }
        const lo = new Array(256).fill().map((t, e) => ('0' + e.toString(16)).slice(-2));
        function co() {
          const t = (4294967296 * Math.random()) >>> 0,
            e = (4294967296 * Math.random()) >>> 0,
            o = (4294967296 * Math.random()) >>> 0,
            i = (4294967296 * Math.random()) >>> 0;
          return (
            'e' +
            lo[(t >> 0) & 255] +
            lo[(t >> 8) & 255] +
            lo[(t >> 16) & 255] +
            lo[(t >> 24) & 255] +
            lo[(e >> 0) & 255] +
            lo[(e >> 8) & 255] +
            lo[(e >> 16) & 255] +
            lo[(e >> 24) & 255] +
            lo[(o >> 0) & 255] +
            lo[(o >> 8) & 255] +
            lo[(o >> 16) & 255] +
            lo[(o >> 24) & 255] +
            lo[(i >> 0) & 255] +
            lo[(i >> 8) & 255] +
            lo[(i >> 16) & 255] +
            lo[(i >> 24) & 255]
          );
        }
        var ho = {
            get(t) {
              return 'number' != typeof t ? this[t] || this.normal : t;
            },
            highest: 1e5,
            high: 1e3,
            normal: 0,
            low: -1e3,
            lowest: -1e5,
          },
          uo = (o(6), o(0));
        const go = Symbol('listeningTo'),
          mo = Symbol('emitterId');
        var fo = {
          on(t, e, o = {}) {
            this.listenTo(this, t, e, o);
          },
          once(t, e, o) {
            let i = !1;
            this.listenTo(
              this,
              t,
              function (t, ...o) {
                i || ((i = !0), t.off(), e.call(this, t, ...o));
              },
              o
            );
          },
          off(t, e) {
            this.stopListening(this, t, e);
          },
          listenTo(t, e, o, i = {}) {
            let n, r;
            this[go] || (this[go] = {});
            const s = this[go];
            bo(t) || po(t);
            const a = bo(t);
            (n = s[a]) || (n = s[a] = { emitter: t, callbacks: {} }),
              (r = n.callbacks[e]) || (r = n.callbacks[e] = []),
              r.push(o),
              (function (t, e) {
                const o = wo(t);
                if (o[e]) return;
                let i = e,
                  n = null;
                const r = [];
                for (; '' !== i && !o[i]; )
                  (o[i] = { callbacks: [], childEvents: [] }),
                    r.push(o[i]),
                    n && o[i].childEvents.push(n),
                    (n = i),
                    (i = i.substr(0, i.lastIndexOf(':')));
                if ('' !== i) {
                  for (const t of r) t.callbacks = o[i].callbacks.slice();
                  o[i].childEvents.push(n);
                }
              })(t, e);
            const l = ko(t, e),
              c = ho.get(i.priority),
              d = { callback: o, priority: c };
            for (const t of l) {
              let e = !1;
              for (let o = 0; o < t.length; o++)
                if (t[o].priority < c) {
                  t.splice(o, 0, d), (e = !0);
                  break;
                }
              e || t.push(d);
            }
          },
          stopListening(t, e, o) {
            const i = this[go];
            let n = t && bo(t);
            const r = i && n && i[n],
              s = r && e && r.callbacks[e];
            if (!(!i || (t && !r) || (e && !s)))
              if (o) vo(t, e, o);
              else if (s) {
                for (; (o = s.pop()); ) vo(t, e, o);
                delete r.callbacks[e];
              } else if (r) {
                for (e in r.callbacks) this.stopListening(t, e);
                delete i[n];
              } else {
                for (n in i) this.stopListening(i[n].emitter);
                delete this[go];
              }
          },
          fire(t, ...e) {
            try {
              const o = t instanceof ao ? t : new ao(this, t),
                i = o.name;
              let n = (function t(e, o) {
                let i;
                if (!e._events || !(i = e._events[o]) || !i.callbacks.length)
                  return o.indexOf(':') > -1 ? t(e, o.substr(0, o.lastIndexOf(':'))) : null;
                return i.callbacks;
              })(this, i);
              if ((o.path.push(this), n)) {
                const t = [o, ...e];
                n = Array.from(n);
                for (
                  let e = 0;
                  e < n.length &&
                  (n[e].callback.apply(this, t),
                  o.off.called && (delete o.off.called, vo(this, i, n[e].callback)),
                  !o.stop.called);
                  e++
                );
              }
              if (this._delegations) {
                const t = this._delegations.get(i),
                  n = this._delegations.get('*');
                t && _o(t, o, e), n && _o(n, o, e);
              }
              return o.return;
            } catch (t) {
              uo.b.rethrowUnexpectedError(t, this);
            }
          },
          delegate(...t) {
            return {
              to: (e, o) => {
                this._delegations || (this._delegations = new Map()),
                  t.forEach(t => {
                    const i = this._delegations.get(t);
                    i ? i.set(e, o) : this._delegations.set(t, new Map([[e, o]]));
                  });
              },
            };
          },
          stopDelegating(t, e) {
            if (this._delegations)
              if (t)
                if (e) {
                  const o = this._delegations.get(t);
                  o && o.delete(e);
                } else this._delegations.delete(t);
              else this._delegations.clear();
          },
        };
        function po(t, e) {
          t[mo] || (t[mo] = e || co());
        }
        function bo(t) {
          return t[mo];
        }
        function wo(t) {
          return t._events || Object.defineProperty(t, '_events', { value: {} }), t._events;
        }
        function ko(t, e) {
          const o = wo(t)[e];
          if (!o) return [];
          let i = [o.callbacks];
          for (let e = 0; e < o.childEvents.length; e++) {
            const n = ko(t, o.childEvents[e]);
            i = i.concat(n);
          }
          return i;
        }
        function _o(t, e, o) {
          for (let [i, n] of t) {
            n ? 'function' == typeof n && (n = n(e.name)) : (n = e.name);
            const t = new ao(e.source, n);
            (t.path = [...e.path]), i.fire(t, ...o);
          }
        }
        function vo(t, e, o) {
          const i = ko(t, e);
          for (const t of i) for (let e = 0; e < t.length; e++) t[e].callback == o && (t.splice(e, 1), e--);
        }
        function yo(t) {
          return !(!t || !t[Symbol.iterator]);
        }
        function xo(t, ...e) {
          e.forEach(e => {
            Object.getOwnPropertyNames(e)
              .concat(Object.getOwnPropertySymbols(e))
              .forEach(o => {
                if (o in t.prototype) return;
                const i = Object.getOwnPropertyDescriptor(e, o);
                (i.enumerable = !1), Object.defineProperty(t.prototype, o, i);
              });
          });
        }
        class Co {
          constructor(t = {}, e = {}) {
            const o = yo(t);
            if (
              (o || (e = t),
              (this._items = []),
              (this._itemMap = new Map()),
              (this._idProperty = e.idProperty || 'id'),
              (this._bindToExternalToInternalMap = new WeakMap()),
              (this._bindToInternalToExternalMap = new WeakMap()),
              (this._skippedIndexesFromExternal = []),
              o)
            )
              for (const e of t) this._items.push(e), this._itemMap.set(this._getItemIdBeforeAdding(e), e);
          }
          get length() {
            return this._items.length;
          }
          get first() {
            return this._items[0] || null;
          }
          get last() {
            return this._items[this.length - 1] || null;
          }
          add(t, e) {
            const o = this._getItemIdBeforeAdding(t);
            if (void 0 === e) e = this._items.length;
            else if (e > this._items.length || e < 0) throw new uo.b('collection-add-item-invalid-index', this);
            return this._items.splice(e, 0, t), this._itemMap.set(o, t), this.fire('add', t, e), this;
          }
          get(t) {
            let e;
            if ('string' == typeof t) e = this._itemMap.get(t);
            else {
              if ('number' != typeof t) throw new uo.b('collection-get-invalid-arg: Index or id must be given.', this);
              e = this._items[t];
            }
            return e || null;
          }
          has(t) {
            if ('string' == typeof t) return this._itemMap.has(t);
            {
              const e = t[this._idProperty];
              return this._itemMap.has(e);
            }
          }
          getIndex(t) {
            let e;
            return (e = 'string' == typeof t ? this._itemMap.get(t) : t), this._items.indexOf(e);
          }
          remove(t) {
            let e,
              o,
              i,
              n = !1;
            const r = this._idProperty;
            if (
              ('string' == typeof t
                ? ((o = t), (i = this._itemMap.get(o)), (n = !i), i && (e = this._items.indexOf(i)))
                : 'number' == typeof t
                ? ((e = t), (i = this._items[e]), (n = !i), i && (o = i[r]))
                : ((i = t), (o = i[r]), (e = this._items.indexOf(i)), (n = -1 == e || !this._itemMap.get(o))),
              n)
            )
              throw new uo.b('collection-remove-404: Item not found.', this);
            this._items.splice(e, 1), this._itemMap.delete(o);
            const s = this._bindToInternalToExternalMap.get(i);
            return (
              this._bindToInternalToExternalMap.delete(i),
              this._bindToExternalToInternalMap.delete(s),
              this.fire('remove', i, e),
              i
            );
          }
          map(t, e) {
            return this._items.map(t, e);
          }
          find(t, e) {
            return this._items.find(t, e);
          }
          filter(t, e) {
            return this._items.filter(t, e);
          }
          clear() {
            for (
              this._bindToCollection && (this.stopListening(this._bindToCollection), (this._bindToCollection = null));
              this.length;

            )
              this.remove(0);
          }
          bindTo(t) {
            if (this._bindToCollection)
              throw new uo.b('collection-bind-to-rebind: The collection cannot be bound more than once.', this);
            return (
              (this._bindToCollection = t),
              {
                as: t => {
                  this._setUpBindToBinding(e => new t(e));
                },
                using: t => {
                  'function' == typeof t ? this._setUpBindToBinding(e => t(e)) : this._setUpBindToBinding(e => e[t]);
                },
              }
            );
          }
          _setUpBindToBinding(t) {
            const e = this._bindToCollection,
              o = (o, i, n) => {
                const r = e._bindToCollection == this,
                  s = e._bindToInternalToExternalMap.get(i);
                if (r && s) this._bindToExternalToInternalMap.set(i, s), this._bindToInternalToExternalMap.set(s, i);
                else {
                  const o = t(i);
                  if (!o) return void this._skippedIndexesFromExternal.push(n);
                  let r = n;
                  for (const t of this._skippedIndexesFromExternal) n > t && r--;
                  for (const t of e._skippedIndexesFromExternal) r >= t && r++;
                  this._bindToExternalToInternalMap.set(i, o),
                    this._bindToInternalToExternalMap.set(o, i),
                    this.add(o, r);
                  for (let t = 0; t < e._skippedIndexesFromExternal.length; t++)
                    r <= e._skippedIndexesFromExternal[t] && e._skippedIndexesFromExternal[t]++;
                }
              };
            for (const t of e) o(0, t, e.getIndex(t));
            this.listenTo(e, 'add', o),
              this.listenTo(e, 'remove', (t, e, o) => {
                const i = this._bindToExternalToInternalMap.get(e);
                i && this.remove(i),
                  (this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(
                    (t, e) => (o < e && t.push(e - 1), o > e && t.push(e), t),
                    []
                  ));
              });
          }
          _getItemIdBeforeAdding(t) {
            const e = this._idProperty;
            let o;
            if (e in t) {
              if (((o = t[e]), 'string' != typeof o)) throw new uo.b('collection-add-invalid-id', this);
              if (this.get(o)) throw new uo.b('collection-add-item-already-exists', this);
            } else t[e] = o = co();
            return o;
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
        }
        xo(Co, fo);
        class Ao {
          constructor(t, e = [], o = []) {
            (this._context = t), (this._plugins = new Map()), (this._availablePlugins = new Map());
            for (const t of e) t.pluginName && this._availablePlugins.set(t.pluginName, t);
            this._contextPlugins = new Map();
            for (const [t, e] of o)
              this._contextPlugins.set(t, e),
                this._contextPlugins.set(e, t),
                t.pluginName && this._availablePlugins.set(t.pluginName, t);
          }
          *[Symbol.iterator]() {
            for (const t of this._plugins) 'function' == typeof t[0] && (yield t);
          }
          get(t) {
            const e = this._plugins.get(t);
            if (!e) {
              const e = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';
              let o = t;
              throw ('function' == typeof t && (o = t.pluginName || t.name), new uo.b(e, this._context, { plugin: o }));
            }
            return e;
          }
          has(t) {
            return this._plugins.has(t);
          }
          init(t, e = []) {
            const o = this,
              i = this._context,
              n = new Set(),
              r = [],
              s = u(t),
              a = u(e),
              l = (function (t) {
                const e = [];
                for (const o of t) h(o) || e.push(o);
                return e.length ? e : null;
              })(t);
            if (l) {
              const t = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.';
              return console.error(Object(uo.a)(t), { plugins: l }), Promise.reject(new uo.b(t, i, { plugins: l }));
            }
            return Promise.all(s.map(c))
              .then(() => d(r, 'init'))
              .then(() => d(r, 'afterInit'))
              .then(() => r);
            function c(t) {
              if (!a.includes(t) && !o._plugins.has(t) && !n.has(t))
                return (function (t) {
                  return new Promise(s => {
                    n.add(t),
                      t.requires &&
                        t.requires.forEach(o => {
                          const n = h(o);
                          if (t.isContextPlugin && !n.isContextPlugin)
                            throw new uo.b(
                              'plugincollection-context-required: Context plugin can not require plugin which is not a context plugin',
                              null,
                              { plugin: n.name, requiredBy: t.name }
                            );
                          if (e.includes(n))
                            throw new uo.b(
                              'plugincollection-required: Cannot load a plugin because one of its dependencies is listed inthe `removePlugins` option.',
                              i,
                              { plugin: n.name, requiredBy: t.name }
                            );
                          c(n);
                        });
                    const a = o._contextPlugins.get(t) || new t(i);
                    o._add(t, a), r.push(a), s();
                  });
                })(t).catch(e => {
                  throw (
                    (console.error(Object(uo.a)('plugincollection-load: It was not possible to load the plugin.'), {
                      plugin: t,
                    }),
                    e)
                  );
                });
            }
            function d(t, e) {
              return t.reduce(
                (t, i) => (i[e] ? (o._contextPlugins.has(i) ? t : t.then(i[e].bind(i))) : t),
                Promise.resolve()
              );
            }
            function h(t) {
              return 'function' == typeof t ? t : o._availablePlugins.get(t);
            }
            function u(t) {
              return t.map(t => h(t)).filter(t => !!t);
            }
          }
          destroy() {
            const t = [];
            for (const [, e] of this)
              'function' != typeof e.destroy || this._contextPlugins.has(e) || t.push(e.destroy());
            return Promise.all(t);
          }
          _add(t, e) {
            this._plugins.set(t, e);
            const o = t.pluginName;
            if (o) {
              if (this._plugins.has(o))
                throw new uo.b(
                  'plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.',
                  null,
                  { pluginName: o, plugin1: this._plugins.get(o).constructor, plugin2: t }
                );
              this._plugins.set(o, e);
            }
          }
        }
        function To(t, e, o = 1) {
          if ('number' != typeof o)
            throw new uo.b('translation-service-quantity-not-a-number: Expecting `quantity` to be a number.', null, {
              quantity: o,
            });
          const i = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
          1 === i && (t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
          const n = e.id || e.string;
          if (
            0 === i ||
            !(function (t, e) {
              return !!window.CKEDITOR_TRANSLATIONS[t] && !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e];
            })(t, n)
          )
            return 1 !== o ? e.plural : e.string;
          const r = window.CKEDITOR_TRANSLATIONS[t].dictionary,
            s = window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => (1 === t ? 0 : 1));
          if ('string' == typeof r[n]) return r[n];
          const a = Number(s(o));
          return r[n][a];
        }
        xo(Ao, fo), window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
        const So = ['ar', 'fa', 'he', 'ku', 'ug'];
        class Po {
          constructor(t = {}) {
            (this.uiLanguage = t.uiLanguage || 'en'),
              (this.contentLanguage = t.contentLanguage || this.uiLanguage),
              (this.uiLanguageDirection = Eo(this.uiLanguage)),
              (this.contentLanguageDirection = Eo(this.contentLanguage)),
              (this.t = (t, e) => this._t(t, e));
          }
          get language() {
            return (
              console.warn(
                'locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.'
              ),
              this.uiLanguage
            );
          }
          _t(t, e = []) {
            Array.isArray(e) || (e = [e]), 'string' == typeof t && (t = { string: t });
            const o = !!t.plural ? e[0] : 1;
            return (function (t, e) {
              return t.replace(/%(\d+)/g, (t, o) => (o < e.length ? e[o] : t));
            })(To(this.uiLanguage, t, o), e);
          }
        }
        function Eo(t) {
          return So.includes(t) ? 'rtl' : 'ltr';
        }
        class Mo {
          constructor(t) {
            this.config = new io(t, this.constructor.defaultConfig);
            const e = this.constructor.builtinPlugins;
            this.config.define('plugins', e), (this.plugins = new Ao(this, e));
            const o = this.config.get('language') || {};
            (this.locale = new Po({
              uiLanguage: 'string' == typeof o ? o : o.ui,
              contentLanguage: this.config.get('language.content'),
            })),
              (this.t = this.locale.t),
              (this.editors = new Co()),
              (this._contextOwner = null);
          }
          initPlugins() {
            const t = this.config.get('plugins') || [];
            for (const e of t) {
              if ('function' != typeof e)
                throw new uo.b(
                  'context-initplugins-constructor-only: Only a constructor function is allowed as a context plugin.',
                  null,
                  { Plugin: e }
                );
              if (!0 !== e.isContextPlugin)
                throw new uo.b(
                  'context-initplugins-invalid-plugin: Only a plugin marked as a context plugin is allowed to be used with a context.',
                  null,
                  { Plugin: e }
                );
            }
            return this.plugins.init(t);
          }
          destroy() {
            return Promise.all(Array.from(this.editors, t => t.destroy())).then(() => this.plugins.destroy());
          }
          _addEditor(t, e) {
            if (this._contextOwner)
              throw new uo.b(
                'context-addEditor-private-context: Cannot add multiple editors to the context which is created by the editor.'
              );
            this.editors.add(t), e && (this._contextOwner = t);
          }
          _removeEditor(t) {
            return (
              this.editors.has(t) && this.editors.remove(t),
              this._contextOwner === t ? this.destroy() : Promise.resolve()
            );
          }
          _getEditorConfig() {
            const t = {};
            for (const e of this.config.names())
              ['plugins', 'removePlugins', 'extraPlugins'].includes(e) || (t[e] = this.config.get(e));
            return t;
          }
          static create(t) {
            return new Promise(e => {
              const o = new this(t);
              e(o.initPlugins().then(() => o));
            });
          }
        }
        function Io(t, e) {
          const o = Math.min(t.length, e.length);
          for (let i = 0; i < o; i++) if (t[i] != e[i]) return i;
          return t.length == e.length ? 'same' : t.length < e.length ? 'prefix' : 'extension';
        }
        var No = function (t) {
          return to(t, 4);
        };
        class Ro {
          constructor(t) {
            (this.document = t), (this.parent = null);
          }
          get index() {
            let t;
            if (!this.parent) return null;
            if (-1 == (t = this.parent.getChildIndex(this)))
              throw new uo.b("view-node-not-found-in-parent: The node's parent does not contain this node.", this);
            return t;
          }
          get nextSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t + 1)) || null;
          }
          get previousSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t - 1)) || null;
          }
          get root() {
            let t = this;
            for (; t.parent; ) t = t.parent;
            return t;
          }
          isAttached() {
            return this.root.is('rootElement');
          }
          getPath() {
            const t = [];
            let e = this;
            for (; e.parent; ) t.unshift(e.index), (e = e.parent);
            return t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let o = t.includeSelf ? this : this.parent;
            for (; o; ) e[t.parentFirst ? 'push' : 'unshift'](o), (o = o.parent);
            return e;
          }
          getCommonAncestor(t, e = {}) {
            const o = this.getAncestors(e),
              i = t.getAncestors(e);
            let n = 0;
            for (; o[n] == i[n] && o[n]; ) n++;
            return 0 === n ? null : o[n - 1];
          }
          isBefore(t) {
            if (this == t) return !1;
            if (this.root !== t.root) return !1;
            const e = this.getPath(),
              o = t.getPath(),
              i = Io(e, o);
            switch (i) {
              case 'prefix':
                return !0;
              case 'extension':
                return !1;
              default:
                return e[i] < o[i];
            }
          }
          isAfter(t) {
            return this != t && this.root === t.root && !this.isBefore(t);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _fireChange(t, e) {
            this.fire('change:' + t, e), this.parent && this.parent._fireChange(t, e);
          }
          toJSON() {
            const t = No(this);
            return delete t.parent, t;
          }
          is(t) {
            return 'node' === t || 'view:node' === t;
          }
        }
        xo(Ro, fo);
        class Oo extends Ro {
          constructor(t, e) {
            super(t), (this._textData = e);
          }
          is(t) {
            return 'text' === t || 'view:text' === t || 'node' === t || 'view:node' === t;
          }
          get data() {
            return this._textData;
          }
          get _data() {
            return this.data;
          }
          set _data(t) {
            this._fireChange('text', this), (this._textData = t);
          }
          isSimilar(t) {
            return t instanceof Oo && (this === t || this.data === t.data);
          }
          _clone() {
            return new Oo(this.document, this.data);
          }
        }
        class Vo {
          constructor(t, e, o) {
            if (((this.textNode = t), e < 0 || e > t.data.length))
              throw new uo.b('view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.', this);
            if (o < 0 || e + o > t.data.length)
              throw new uo.b('view-textproxy-wrong-length: Given length value is incorrect.', this);
            (this.data = t.data.substring(e, e + o)), (this.offsetInText = e);
          }
          get offsetSize() {
            return this.data.length;
          }
          get isPartial() {
            return this.data.length !== this.textNode.data.length;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          get document() {
            return this.textNode.document;
          }
          is(t) {
            return 'textProxy' === t || 'view:textProxy' === t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let o = t.includeSelf ? this.textNode : this.parent;
            for (; null !== o; ) e[t.parentFirst ? 'push' : 'unshift'](o), (o = o.parent);
            return e;
          }
        }
        function Do(t) {
          return yo(t)
            ? new Map(t)
            : (function (t) {
                const e = new Map();
                for (const o in t) e.set(o, t[o]);
                return e;
              })(t);
        }
        class zo {
          constructor(...t) {
            (this._patterns = []), this.add(...t);
          }
          add(...t) {
            for (let e of t)
              ('string' == typeof e || e instanceof RegExp) && (e = { name: e }),
                e.classes && ('string' == typeof e.classes || e.classes instanceof RegExp) && (e.classes = [e.classes]),
                this._patterns.push(e);
          }
          match(...t) {
            for (const e of t)
              for (const t of this._patterns) {
                const o = Lo(e, t);
                if (o) return { element: e, pattern: t, match: o };
              }
            return null;
          }
          matchAll(...t) {
            const e = [];
            for (const o of t)
              for (const t of this._patterns) {
                const i = Lo(o, t);
                i && e.push({ element: o, pattern: t, match: i });
              }
            return e.length > 0 ? e : null;
          }
          getElementName() {
            if (1 !== this._patterns.length) return null;
            const t = this._patterns[0],
              e = t.name;
            return 'function' == typeof t || !e || e instanceof RegExp ? null : e;
          }
        }
        function Lo(t, e) {
          if ('function' == typeof e) return e(t);
          const o = {};
          return (e.name &&
            ((o.name = (function (t, e) {
              if (t instanceof RegExp) return t.test(e);
              return t === e;
            })(e.name, t.name)),
            !o.name)) ||
            (e.attributes &&
              ((o.attributes = (function (t, e) {
                const o = [];
                for (const i in t) {
                  const n = t[i];
                  if (!e.hasAttribute(i)) return null;
                  {
                    const t = e.getAttribute(i);
                    if (!0 === n) o.push(i);
                    else if (n instanceof RegExp) {
                      if (!n.test(t)) return null;
                      o.push(i);
                    } else {
                      if (t !== n) return null;
                      o.push(i);
                    }
                  }
                }
                return o;
              })(e.attributes, t)),
              !o.attributes))
            ? null
            : !(
                e.classes &&
                ((o.classes = (function (t, e) {
                  const o = [];
                  for (const i of t)
                    if (i instanceof RegExp) {
                      const t = e.getClassNames();
                      for (const e of t) i.test(e) && o.push(e);
                      if (0 === o.length) return null;
                    } else {
                      if (!e.hasClass(i)) return null;
                      o.push(i);
                    }
                  return o;
                })(e.classes, t)),
                !o.classes)
              ) &&
                !(
                  e.styles &&
                  ((o.styles = (function (t, e) {
                    const o = [];
                    for (const i in t) {
                      const n = t[i];
                      if (!e.hasStyle(i)) return null;
                      {
                        const t = e.getStyle(i);
                        if (n instanceof RegExp) {
                          if (!n.test(t)) return null;
                          o.push(i);
                        } else {
                          if (t !== n) return null;
                          o.push(i);
                        }
                      }
                    }
                    return o;
                  })(e.styles, t)),
                  !o.styles)
                ) &&
                o;
        }
        var jo = function (t) {
            return 'symbol' == typeof t || (p(t) && '[object Symbol]' == g(t));
          },
          Bo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          Fo = /^\w*$/;
        var Ho = function (t, e) {
          if (Vt(t)) return !1;
          var o = typeof t;
          return (
            !('number' != o && 'symbol' != o && 'boolean' != o && null != t && !jo(t)) ||
            Fo.test(t) ||
            !Bo.test(t) ||
            (null != e && t in Object(e))
          );
        };
        function Wo(t, e) {
          if ('function' != typeof t || (null != e && 'function' != typeof e))
            throw new TypeError('Expected a function');
          var o = function () {
            var i = arguments,
              n = e ? e.apply(this, i) : i[0],
              r = o.cache;
            if (r.has(n)) return r.get(n);
            var s = t.apply(this, i);
            return (o.cache = r.set(n, s) || r), s;
          };
          return (o.cache = new (Wo.Cache || kt)()), o;
        }
        Wo.Cache = kt;
        var Uo = Wo;
        var qo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
          Go = /\\(\\)?/g,
          Yo = (function (t) {
            var e = Uo(t, function (t) {
                return 500 === o.size && o.clear(), t;
              }),
              o = e.cache;
            return e;
          })(function (t) {
            var e = [];
            return (
              46 === t.charCodeAt(0) && e.push(''),
              t.replace(qo, function (t, o, i, n) {
                e.push(i ? n.replace(Go, '$1') : o || t);
              }),
              e
            );
          });
        var $o = function (t, e) {
            for (var o = -1, i = null == t ? 0 : t.length, n = Array(i); ++o < i; ) n[o] = e(t[o], o, t);
            return n;
          },
          Qo = n ? n.prototype : void 0,
          Ko = Qo ? Qo.toString : void 0;
        var Jo = function t(e) {
          if ('string' == typeof e) return e;
          if (Vt(e)) return $o(e, t) + '';
          if (jo(e)) return Ko ? Ko.call(e) : '';
          var o = e + '';
          return '0' == o && 1 / e == -1 / 0 ? '-0' : o;
        };
        var Zo = function (t) {
          return null == t ? '' : Jo(t);
        };
        var Xo = function (t, e) {
          return Vt(t) ? t : Ho(t, e) ? [t] : Yo(Zo(t));
        };
        var ti = function (t) {
          var e = null == t ? 0 : t.length;
          return e ? t[e - 1] : void 0;
        };
        var ei = function (t) {
          if ('string' == typeof t || jo(t)) return t;
          var e = t + '';
          return '0' == e && 1 / t == -1 / 0 ? '-0' : e;
        };
        var oi = function (t, e) {
          for (var o = 0, i = (e = Xo(e, t)).length; null != t && o < i; ) t = t[ei(e[o++])];
          return o && o == i ? t : void 0;
        };
        var ii = function (t, e, o) {
          var i = -1,
            n = t.length;
          e < 0 && (e = -e > n ? 0 : n + e),
            (o = o > n ? n : o) < 0 && (o += n),
            (n = e > o ? 0 : (o - e) >>> 0),
            (e >>>= 0);
          for (var r = Array(n); ++i < n; ) r[i] = t[i + e];
          return r;
        };
        var ni = function (t, e) {
          return e.length < 2 ? t : oi(t, ii(e, 0, -1));
        };
        var ri = function (t, e) {
          return (e = Xo(e, t)), null == (t = ni(t, e)) || delete t[ei(ti(e))];
        };
        var si = function (t, e) {
          return null == t || ri(t, e);
        };
        var ai = function (t, e, o) {
          var i = null == t ? void 0 : oi(t, e);
          return void 0 === i ? o : i;
        };
        var li = function (t, e, o) {
          ((void 0 !== o && !C(t[e], o)) || (void 0 === o && !(e in t))) && At(t, e, o);
        };
        var ci = (function (t) {
          return function (e, o, i) {
            for (var n = -1, r = Object(e), s = i(e), a = s.length; a--; ) {
              var l = s[t ? a : ++n];
              if (!1 === o(r[l], l, r)) break;
            }
            return e;
          };
        })();
        var di = function (t) {
          return p(t) && Xt(t);
        };
        var hi = function (t, e) {
          if (('constructor' !== e || 'function' != typeof t[e]) && '__proto__' != e) return t[e];
        };
        var ui = function (t) {
          return Pt(t, re(t));
        };
        var gi = function (t, e, o, i, n, r, s) {
          var a = hi(t, o),
            l = hi(e, o),
            c = s.get(l);
          if (c) li(t, o, c);
          else {
            var d = r ? r(a, l, o + '', t, e, s) : void 0,
              h = void 0 === d;
            if (h) {
              var u = Vt(l),
                g = !u && Object(Dt.a)(l),
                m = !u && !g && qt(l);
              (d = l),
                u || g || m
                  ? Vt(a)
                    ? (d = a)
                    : di(a)
                    ? (d = le(a))
                    : g
                    ? ((h = !1), (d = Object(ae.a)(l, !0)))
                    : m
                    ? ((h = !1), (d = He(l, !0)))
                    : (d = [])
                  : y(l) || Ot(l)
                  ? ((d = a), Ot(a) ? (d = ui(a)) : (z(a) && !j(a)) || (d = Ge(l)))
                  : (h = !1);
            }
            h && (s.set(l, d), n(d, l, i, r, s), s.delete(l)), li(t, o, d);
          }
        };
        var mi = function t(e, o, i, n, r) {
          e !== o &&
            ci(
              o,
              function (s, a) {
                if ((r || (r = new yt()), z(s))) gi(e, o, a, i, t, n, r);
                else {
                  var l = n ? n(hi(e, a), s, a + '', e, o, r) : void 0;
                  void 0 === l && (l = s), li(e, a, l);
                }
              },
              re
            );
        };
        var fi = function (t) {
          return t;
        };
        var pi = function (t, e, o) {
            switch (o.length) {
              case 0:
                return t.call(e);
              case 1:
                return t.call(e, o[0]);
              case 2:
                return t.call(e, o[0], o[1]);
              case 3:
                return t.call(e, o[0], o[1], o[2]);
            }
            return t.apply(e, o);
          },
          bi = Math.max;
        var wi = function (t, e, o) {
          return (
            (e = bi(void 0 === e ? t.length - 1 : e, 0)),
            function () {
              for (var i = arguments, n = -1, r = bi(i.length - e, 0), s = Array(r); ++n < r; ) s[n] = i[e + n];
              n = -1;
              for (var a = Array(e + 1); ++n < e; ) a[n] = i[n];
              return (a[e] = o(s)), pi(t, this, a);
            }
          );
        };
        var ki = function (t) {
            return function () {
              return t;
            };
          },
          _i = Ct
            ? function (t, e) {
                return Ct(t, 'toString', { configurable: !0, enumerable: !1, value: ki(e), writable: !0 });
              }
            : fi,
          vi = Date.now;
        var yi = (function (t) {
          var e = 0,
            o = 0;
          return function () {
            var i = vi(),
              n = 16 - (i - o);
            if (((o = i), n > 0)) {
              if (++e >= 800) return arguments[0];
            } else e = 0;
            return t.apply(void 0, arguments);
          };
        })(_i);
        var xi = function (t, e) {
          return yi(wi(t, e, fi), t + '');
        };
        var Ci = function (t, e, o) {
          if (!z(o)) return !1;
          var i = typeof e;
          return !!('number' == i ? Xt(o) && Lt(e, o.length) : 'string' == i && e in o) && C(o[e], t);
        };
        var Ai = function (t) {
            return xi(function (e, o) {
              var i = -1,
                n = o.length,
                r = n > 1 ? o[n - 1] : void 0,
                s = n > 2 ? o[2] : void 0;
              for (
                r = t.length > 3 && 'function' == typeof r ? (n--, r) : void 0,
                  s && Ci(o[0], o[1], s) && ((r = n < 3 ? void 0 : r), (n = 1)),
                  e = Object(e);
                ++i < n;

              ) {
                var a = o[i];
                a && t(e, a, i, r);
              }
              return e;
            });
          },
          Ti = Ai(function (t, e, o) {
            mi(t, e, o);
          });
        var Si = function (t, e, o, i) {
          if (!z(t)) return t;
          for (var n = -1, r = (e = Xo(e, t)).length, s = r - 1, a = t; null != a && ++n < r; ) {
            var l = ei(e[n]),
              c = o;
            if (n != s) {
              var d = a[l];
              void 0 === (c = i ? i(d, l, a) : void 0) && (c = z(d) ? d : Lt(e[n + 1]) ? [] : {});
            }
            St(a, l, c), (a = a[l]);
          }
          return t;
        };
        var Pi = function (t, e, o) {
          return null == t ? t : Si(t, e, o);
        };
        class Ei {
          constructor(t) {
            (this._styles = {}), (this._styleProcessor = t);
          }
          get isEmpty() {
            const t = Object.entries(this._styles);
            return !Array.from(t).length;
          }
          get size() {
            return this.isEmpty ? 0 : this.getStyleNames().length;
          }
          setTo(t) {
            this.clear();
            const e = Array.from(
              (function (t) {
                let e = null,
                  o = 0,
                  i = 0,
                  n = null;
                const r = new Map();
                if ('' === t) return r;
                ';' != t.charAt(t.length - 1) && (t += ';');
                for (let s = 0; s < t.length; s++) {
                  const a = t.charAt(s);
                  if (null === e)
                    switch (a) {
                      case ':':
                        n || ((n = t.substr(o, s - o)), (i = s + 1));
                        break;
                      case '"':
                      case "'":
                        e = a;
                        break;
                      case ';': {
                        const e = t.substr(i, s - i);
                        n && r.set(n.trim(), e.trim()), (n = null), (o = s + 1);
                        break;
                      }
                    }
                  else a === e && (e = null);
                }
                return r;
              })(t).entries()
            );
            for (const [t, o] of e) this._styleProcessor.toNormalizedForm(t, o, this._styles);
          }
          has(t) {
            if (this.isEmpty) return !1;
            const e = this._styleProcessor.getReducedForm(t, this._styles).find(([e]) => e === t);
            return Array.isArray(e);
          }
          set(t, e) {
            if (z(t)) for (const [e, o] of Object.entries(t)) this._styleProcessor.toNormalizedForm(e, o, this._styles);
            else this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
          remove(t) {
            const e = Ii(t);
            si(this._styles, e), delete this._styles[t], this._cleanEmptyObjectsOnPath(e);
          }
          getNormalized(t) {
            return this._styleProcessor.getNormalized(t, this._styles);
          }
          toString() {
            return this.isEmpty
              ? ''
              : this._getStylesEntries()
                  .map(t => t.join(':'))
                  .sort()
                  .join(';') + ';';
          }
          getAsString(t) {
            if (this.isEmpty) return;
            if (this._styles[t] && !z(this._styles[t])) return this._styles[t];
            const e = this._styleProcessor.getReducedForm(t, this._styles).find(([e]) => e === t);
            return Array.isArray(e) ? e[1] : void 0;
          }
          getStyleNames() {
            if (this.isEmpty) return [];
            return this._getStylesEntries().map(([t]) => t);
          }
          clear() {
            this._styles = {};
          }
          _getStylesEntries() {
            const t = [],
              e = Object.keys(this._styles);
            for (const o of e) t.push(...this._styleProcessor.getReducedForm(o, this._styles));
            return t;
          }
          _cleanEmptyObjectsOnPath(t) {
            const e = t.split('.');
            if (!(e.length > 1)) return;
            const o = e.splice(0, e.length - 1).join('.'),
              i = ai(this._styles, o);
            if (!i) return;
            !Array.from(Object.keys(i)).length && this.remove(o);
          }
        }
        class Mi {
          constructor() {
            (this._normalizers = new Map()),
              (this._extractors = new Map()),
              (this._reducers = new Map()),
              (this._consumables = new Map());
          }
          toNormalizedForm(t, e, o) {
            if (z(e)) Ni(o, Ii(t), e);
            else if (this._normalizers.has(t)) {
              const i = this._normalizers.get(t),
                { path: n, value: r } = i(e);
              Ni(o, n, r);
            } else Ni(o, t, e);
          }
          getNormalized(t, e) {
            if (!t) return Ti({}, e);
            if (void 0 !== e[t]) return e[t];
            if (this._extractors.has(t)) {
              const o = this._extractors.get(t);
              if ('string' == typeof o) return ai(e, o);
              const i = o(t, e);
              if (i) return i;
            }
            return ai(e, Ii(t));
          }
          getReducedForm(t, e) {
            const o = this.getNormalized(t, e);
            if (void 0 === o) return [];
            if (this._reducers.has(t)) {
              return this._reducers.get(t)(o);
            }
            return [[t, o]];
          }
          getRelatedStyles(t) {
            return this._consumables.get(t) || [];
          }
          setNormalizer(t, e) {
            this._normalizers.set(t, e);
          }
          setExtractor(t, e) {
            this._extractors.set(t, e);
          }
          setReducer(t, e) {
            this._reducers.set(t, e);
          }
          setStyleRelation(t, e) {
            this._mapStyleNames(t, e);
            for (const o of e) this._mapStyleNames(o, [t]);
          }
          _mapStyleNames(t, e) {
            this._consumables.has(t) || this._consumables.set(t, []), this._consumables.get(t).push(...e);
          }
        }
        function Ii(t) {
          return t.replace('-', '.');
        }
        function Ni(t, e, o) {
          let i = o;
          z(o) && (i = Ti({}, ai(t, e), o)), Pi(t, e, i);
        }
        class Ri extends Ro {
          constructor(t, e, o, i) {
            if (
              (super(t),
              (this.name = e),
              (this._attrs = (function (t) {
                t = Do(t);
                for (const [e, o] of t) null === o ? t.delete(e) : 'string' != typeof o && t.set(e, String(o));
                return t;
              })(o)),
              (this._children = []),
              i && this._insertChild(0, i),
              (this._classes = new Set()),
              this._attrs.has('class'))
            ) {
              const t = this._attrs.get('class');
              Oi(this._classes, t), this._attrs.delete('class');
            }
            (this._styles = new Ei(this.document.stylesProcessor)),
              this._attrs.has('style') && (this._styles.setTo(this._attrs.get('style')), this._attrs.delete('style')),
              (this._customProperties = new Map());
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this._children.length;
          }
          is(t, e = null) {
            return e
              ? e === this.name && ('element' === t || 'view:element' === t)
              : t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          getChild(t) {
            return this._children[t];
          }
          getChildIndex(t) {
            return this._children.indexOf(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          *getAttributeKeys() {
            this._classes.size > 0 && (yield 'class'),
              this._styles.isEmpty || (yield 'style'),
              yield* this._attrs.keys();
          }
          *getAttributes() {
            yield* this._attrs.entries(),
              this._classes.size > 0 && (yield ['class', this.getAttribute('class')]),
              this._styles.isEmpty || (yield ['style', this.getAttribute('style')]);
          }
          getAttribute(t) {
            if ('class' == t) return this._classes.size > 0 ? [...this._classes].join(' ') : void 0;
            if ('style' == t) {
              const t = this._styles.toString();
              return '' == t ? void 0 : t;
            }
            return this._attrs.get(t);
          }
          hasAttribute(t) {
            return 'class' == t ? this._classes.size > 0 : 'style' == t ? !this._styles.isEmpty : this._attrs.has(t);
          }
          isSimilar(t) {
            if (!(t instanceof Ri)) return !1;
            if (this === t) return !0;
            if (this.name != t.name) return !1;
            if (
              this._attrs.size !== t._attrs.size ||
              this._classes.size !== t._classes.size ||
              this._styles.size !== t._styles.size
            )
              return !1;
            for (const [e, o] of this._attrs) if (!t._attrs.has(e) || t._attrs.get(e) !== o) return !1;
            for (const e of this._classes) if (!t._classes.has(e)) return !1;
            for (const e of this._styles.getStyleNames())
              if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) return !1;
            return !0;
          }
          hasClass(...t) {
            for (const e of t) if (!this._classes.has(e)) return !1;
            return !0;
          }
          getClassNames() {
            return this._classes.keys();
          }
          getStyle(t) {
            return this._styles.getAsString(t);
          }
          getNormalizedStyle(t) {
            return this._styles.getNormalized(t);
          }
          getStyleNames() {
            return this._styles.getStyleNames();
          }
          hasStyle(...t) {
            for (const e of t) if (!this._styles.has(e)) return !1;
            return !0;
          }
          findAncestor(...t) {
            const e = new zo(...t);
            let o = this.parent;
            for (; o; ) {
              if (e.match(o)) return o;
              o = o.parent;
            }
            return null;
          }
          getCustomProperty(t) {
            return this._customProperties.get(t);
          }
          *getCustomProperties() {
            yield* this._customProperties.entries();
          }
          getIdentity() {
            const t = Array.from(this._classes).sort().join(','),
              e = this._styles.toString(),
              o = Array.from(this._attrs)
                .map(t => `${t[0]}="${t[1]}"`)
                .sort()
                .join(' ');
            return this.name + ('' == t ? '' : ` class="${t}"`) + (e ? ` style="${e}"` : '') + ('' == o ? '' : ' ' + o);
          }
          _clone(t = !1) {
            const e = [];
            if (t) for (const o of this.getChildren()) e.push(o._clone(t));
            const o = new this.constructor(this.document, this.name, this._attrs, e);
            return (
              (o._classes = new Set(this._classes)),
              o._styles.set(this._styles.getNormalized()),
              (o._customProperties = new Map(this._customProperties)),
              (o.getFillerOffset = this.getFillerOffset),
              o
            );
          }
          _appendChild(t) {
            return this._insertChild(this.childCount, t);
          }
          _insertChild(t, e) {
            this._fireChange('children', this);
            let o = 0;
            const i = (function (t, e) {
              if ('string' == typeof e) return [new Oo(t, e)];
              yo(e) || (e = [e]);
              return Array.from(e).map(e =>
                'string' == typeof e ? new Oo(t, e) : e instanceof Vo ? new Oo(t, e.data) : e
              );
            })(this.document, e);
            for (const e of i)
              null !== e.parent && e._remove(),
                (e.parent = this),
                (e.document = this.document),
                this._children.splice(t, 0, e),
                t++,
                o++;
            return o;
          }
          _removeChildren(t, e = 1) {
            this._fireChange('children', this);
            for (let o = t; o < t + e; o++) this._children[o].parent = null;
            return this._children.splice(t, e);
          }
          _setAttribute(t, e) {
            (e = String(e)),
              this._fireChange('attributes', this),
              'class' == t ? Oi(this._classes, e) : 'style' == t ? this._styles.setTo(e) : this._attrs.set(t, e);
          }
          _removeAttribute(t) {
            return (
              this._fireChange('attributes', this),
              'class' == t
                ? this._classes.size > 0 && (this._classes.clear(), !0)
                : 'style' == t
                ? !this._styles.isEmpty && (this._styles.clear(), !0)
                : this._attrs.delete(t)
            );
          }
          _addClass(t) {
            this._fireChange('attributes', this), (t = Array.isArray(t) ? t : [t]).forEach(t => this._classes.add(t));
          }
          _removeClass(t) {
            this._fireChange('attributes', this),
              (t = Array.isArray(t) ? t : [t]).forEach(t => this._classes.delete(t));
          }
          _setStyle(t, e) {
            this._fireChange('attributes', this), this._styles.set(t, e);
          }
          _removeStyle(t) {
            this._fireChange('attributes', this), (t = Array.isArray(t) ? t : [t]).forEach(t => this._styles.remove(t));
          }
          _setCustomProperty(t, e) {
            this._customProperties.set(t, e);
          }
          _removeCustomProperty(t) {
            return this._customProperties.delete(t);
          }
        }
        function Oi(t, e) {
          const o = e.split(/\s+/);
          t.clear(), o.forEach(e => t.add(e));
        }
        class Vi extends Ri {
          constructor(t, e, o, i) {
            super(t, e, o, i), (this.getFillerOffset = Di);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('containerElement' === t || 'view:containerElement' === t || 'element' === t || 'view:element' === t)
              : 'containerElement' === t ||
                  'view:containerElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
        }
        function Di() {
          const t = [...this.getChildren()],
            e = t[this.childCount - 1];
          if (e && e.is('element', 'br')) return this.childCount;
          for (const e of t) if (!e.is('uiElement')) return null;
          return this.childCount;
        }
        var zi = Ai(function (t, e) {
          Pt(e, re(e), t);
        });
        const Li = Symbol('observableProperties'),
          ji = Symbol('boundObservables'),
          Bi = Symbol('boundProperties'),
          Fi = {
            set(t, e) {
              if (z(t))
                return void Object.keys(t).forEach(e => {
                  this.set(e, t[e]);
                }, this);
              Wi(this);
              const o = this[Li];
              if (t in this && !o.has(t))
                throw new uo.b('observable-set-cannot-override: Cannot override an existing property.', this);
              Object.defineProperty(this, t, {
                enumerable: !0,
                configurable: !0,
                get: () => o.get(t),
                set(e) {
                  const i = o.get(t);
                  let n = this.fire('set:' + t, t, e, i);
                  void 0 === n && (n = e), (i === n && o.has(t)) || (o.set(t, n), this.fire('change:' + t, t, n, i));
                },
              }),
                (this[t] = e);
            },
            bind(...t) {
              if (!t.length || !Gi(t))
                throw new uo.b('observable-bind-wrong-properties: All properties must be strings.', this);
              if (new Set(t).size !== t.length)
                throw new uo.b('observable-bind-duplicate-properties: Properties must be unique.', this);
              Wi(this);
              const e = this[Bi];
              t.forEach(t => {
                if (e.has(t))
                  throw new uo.b('observable-bind-rebind: Cannot bind the same property more than once.', this);
              });
              const o = new Map();
              return (
                t.forEach(t => {
                  const i = { property: t, to: [] };
                  e.set(t, i), o.set(t, i);
                }),
                { to: Ui, toMany: qi, _observable: this, _bindProperties: t, _to: [], _bindings: o }
              );
            },
            unbind(...t) {
              if (!this[Li]) return;
              const e = this[Bi],
                o = this[ji];
              if (t.length) {
                if (!Gi(t)) throw new uo.b('observable-unbind-wrong-properties: Properties must be strings.', this);
                t.forEach(t => {
                  const i = e.get(t);
                  if (!i) return;
                  let n, r, s, a;
                  i.to.forEach(t => {
                    (n = t[0]),
                      (r = t[1]),
                      (s = o.get(n)),
                      (a = s[r]),
                      a.delete(i),
                      a.size || delete s[r],
                      Object.keys(s).length || (o.delete(n), this.stopListening(n, 'change'));
                  }),
                    e.delete(t);
                });
              } else
                o.forEach((t, e) => {
                  this.stopListening(e, 'change');
                }),
                  o.clear(),
                  e.clear();
            },
            decorate(t) {
              const e = this[t];
              if (!e)
                throw new uo.b(
                  'observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.',
                  this,
                  { object: this, methodName: t }
                );
              this.on(t, (t, o) => {
                t.return = e.apply(this, o);
              }),
                (this[t] = function (...e) {
                  return this.fire(t, e);
                });
            },
          };
        zi(Fi, fo);
        var Hi = Fi;
        function Wi(t) {
          t[Li] ||
            (Object.defineProperty(t, Li, { value: new Map() }),
            Object.defineProperty(t, ji, { value: new Map() }),
            Object.defineProperty(t, Bi, { value: new Map() }));
        }
        function Ui(...t) {
          const e = (function (...t) {
              if (!t.length) throw new uo.b('observable-bind-to-parse-error: Invalid argument syntax in `to()`.', null);
              const e = { to: [] };
              let o;
              'function' == typeof t[t.length - 1] && (e.callback = t.pop());
              return (
                t.forEach(t => {
                  if ('string' == typeof t) o.properties.push(t);
                  else {
                    if ('object' != typeof t)
                      throw new uo.b('observable-bind-to-parse-error: Invalid argument syntax in `to()`.', null);
                    (o = { observable: t, properties: [] }), e.to.push(o);
                  }
                }),
                e
              );
            })(...t),
            o = Array.from(this._bindings.keys()),
            i = o.length;
          if (!e.callback && e.to.length > 1)
            throw new uo.b(
              'observable-bind-to-no-callback: Binding multiple observables only possible with callback.',
              this
            );
          if (i > 1 && e.callback)
            throw new uo.b(
              'observable-bind-to-extra-callback: Cannot bind multiple properties and use a callback in one binding.',
              this
            );
          var n;
          e.to.forEach(t => {
            if (t.properties.length && t.properties.length !== i)
              throw new uo.b('observable-bind-to-properties-length: The number of properties must match.', this);
            t.properties.length || (t.properties = this._bindProperties);
          }),
            (this._to = e.to),
            e.callback && (this._bindings.get(o[0]).callback = e.callback),
            (n = this._observable),
            this._to.forEach(t => {
              const e = n[ji];
              let o;
              e.get(t.observable) ||
                n.listenTo(t.observable, 'change', (i, r) => {
                  (o = e.get(t.observable)[r]),
                    o &&
                      o.forEach(t => {
                        Yi(n, t.property);
                      });
                });
            }),
            (function (t) {
              let e;
              t._bindings.forEach((o, i) => {
                t._to.forEach(n => {
                  (e = n.properties[o.callback ? 0 : t._bindProperties.indexOf(i)]),
                    o.to.push([n.observable, e]),
                    (function (t, e, o, i) {
                      const n = t[ji],
                        r = n.get(o),
                        s = r || {};
                      s[i] || (s[i] = new Set());
                      s[i].add(e), r || n.set(o, s);
                    })(t._observable, o, n.observable, e);
                });
              });
            })(this),
            this._bindProperties.forEach(t => {
              Yi(this._observable, t);
            });
        }
        function qi(t, e, o) {
          if (this._bindings.size > 1)
            throw new uo.b(
              'observable-bind-to-many-not-one-binding: Cannot bind multiple properties with toMany().',
              this
            );
          this.to(
            ...(function (t, e) {
              const o = t.map(t => [t, e]);
              return Array.prototype.concat.apply([], o);
            })(t, e),
            o
          );
        }
        function Gi(t) {
          return t.every(t => 'string' == typeof t);
        }
        function Yi(t, e) {
          const o = t[Bi].get(e);
          let i;
          o.callback
            ? (i = o.callback.apply(
                t,
                o.to.map(t => t[0][t[1]])
              ))
            : ((i = o.to[0]), (i = i[0][i[1]])),
            t.hasOwnProperty(e) ? (t[e] = i) : t.set(e, i);
        }
        class $i extends Vi {
          constructor(t, e, o, i) {
            super(t, e, o, i),
              this.set('isReadOnly', !1),
              this.set('isFocused', !1),
              this.bind('isReadOnly').to(t),
              this.bind('isFocused').to(t, 'isFocused', e => e && t.selection.editableElement == this),
              this.listenTo(t.selection, 'change', () => {
                this.isFocused = t.isFocused && t.selection.editableElement == this;
              });
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('editableElement' === t ||
                    'view:editableElement' === t ||
                    'containerElement' === t ||
                    'view:containerElement' === t ||
                    'element' === t ||
                    'view:element' === t)
              : 'editableElement' === t ||
                  'view:editableElement' === t ||
                  'containerElement' === t ||
                  'view:containerElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          destroy() {
            this.stopListening();
          }
        }
        xo($i, Hi);
        const Qi = Symbol('rootName');
        class Ki extends $i {
          constructor(t, e) {
            super(t, e), (this.rootName = 'main');
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('rootElement' === t ||
                    'view:rootElement' === t ||
                    'editableElement' === t ||
                    'view:editableElement' === t ||
                    'containerElement' === t ||
                    'view:containerElement' === t ||
                    'element' === t ||
                    'view:element' === t)
              : 'rootElement' === t ||
                  'view:rootElement' === t ||
                  'editableElement' === t ||
                  'view:editableElement' === t ||
                  'containerElement' === t ||
                  'view:containerElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          get rootName() {
            return this.getCustomProperty(Qi);
          }
          set rootName(t) {
            this._setCustomProperty(Qi, t);
          }
          set _name(t) {
            this.name = t;
          }
        }
        class Ji {
          constructor(t = {}) {
            if (!t.boundaries && !t.startPosition)
              throw new uo.b(
                'view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.',
                null
              );
            if (t.direction && 'forward' != t.direction && 'backward' != t.direction)
              throw new uo.b(
                'view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',
                t.startPosition,
                { direction: t.direction }
              );
            (this.boundaries = t.boundaries || null),
              t.startPosition
                ? (this.position = Zi._createAt(t.startPosition))
                : (this.position = Zi._createAt(t.boundaries['backward' == t.direction ? 'end' : 'start'])),
              (this.direction = t.direction || 'forward'),
              (this.singleCharacters = !!t.singleCharacters),
              (this.shallow = !!t.shallow),
              (this.ignoreElementEnd = !!t.ignoreElementEnd),
              (this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null),
              (this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null);
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t) {
            let e, o, i;
            do {
              (i = this.position), ({ done: e, value: o } = this.next());
            } while (!e && t(o));
            e || (this.position = i);
          }
          next() {
            return 'forward' == this.direction ? this._next() : this._previous();
          }
          _next() {
            let t = this.position.clone();
            const e = this.position,
              o = t.parent;
            if (null === o.parent && t.offset === o.childCount) return { done: !0 };
            if (o === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return { done: !0 };
            let i;
            if (o instanceof Oo) {
              if (t.isAtEnd) return (this.position = Zi._createAfter(o)), this._next();
              i = o.data[t.offset];
            } else i = o.getChild(t.offset);
            if (i instanceof Ri)
              return (
                this.shallow ? t.offset++ : (t = new Zi(i, 0)),
                (this.position = t),
                this._formatReturnValue('elementStart', i, e, t, 1)
              );
            if (i instanceof Oo) {
              if (this.singleCharacters) return (t = new Zi(i, 0)), (this.position = t), this._next();
              {
                let o,
                  n = i.data.length;
                return (
                  i == this._boundaryEndParent
                    ? ((n = this.boundaries.end.offset), (o = new Vo(i, 0, n)), (t = Zi._createAfter(o)))
                    : ((o = new Vo(i, 0, i.data.length)), t.offset++),
                  (this.position = t),
                  this._formatReturnValue('text', o, e, t, n)
                );
              }
            }
            if ('string' == typeof i) {
              let i;
              if (this.singleCharacters) i = 1;
              else {
                i = (o === this._boundaryEndParent ? this.boundaries.end.offset : o.data.length) - t.offset;
              }
              const n = new Vo(o, t.offset, i);
              return (t.offset += i), (this.position = t), this._formatReturnValue('text', n, e, t, i);
            }
            return (
              (t = Zi._createAfter(o)),
              (this.position = t),
              this.ignoreElementEnd ? this._next() : this._formatReturnValue('elementEnd', o, e, t)
            );
          }
          _previous() {
            let t = this.position.clone();
            const e = this.position,
              o = t.parent;
            if (null === o.parent && 0 === t.offset) return { done: !0 };
            if (o == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return { done: !0 };
            let i;
            if (o instanceof Oo) {
              if (t.isAtStart) return (this.position = Zi._createBefore(o)), this._previous();
              i = o.data[t.offset - 1];
            } else i = o.getChild(t.offset - 1);
            if (i instanceof Ri)
              return this.shallow
                ? (t.offset--, (this.position = t), this._formatReturnValue('elementStart', i, e, t, 1))
                : ((t = new Zi(i, i.childCount)),
                  (this.position = t),
                  this.ignoreElementEnd ? this._previous() : this._formatReturnValue('elementEnd', i, e, t));
            if (i instanceof Oo) {
              if (this.singleCharacters) return (t = new Zi(i, i.data.length)), (this.position = t), this._previous();
              {
                let o,
                  n = i.data.length;
                if (i == this._boundaryStartParent) {
                  const e = this.boundaries.start.offset;
                  (o = new Vo(i, e, i.data.length - e)), (n = o.data.length), (t = Zi._createBefore(o));
                } else (o = new Vo(i, 0, i.data.length)), t.offset--;
                return (this.position = t), this._formatReturnValue('text', o, e, t, n);
              }
            }
            if ('string' == typeof i) {
              let i;
              if (this.singleCharacters) i = 1;
              else {
                const e = o === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                i = t.offset - e;
              }
              t.offset -= i;
              const n = new Vo(o, t.offset, i);
              return (this.position = t), this._formatReturnValue('text', n, e, t, i);
            }
            return (t = Zi._createBefore(o)), (this.position = t), this._formatReturnValue('elementStart', o, e, t, 1);
          }
          _formatReturnValue(t, e, o, i, n) {
            return (
              e instanceof Vo &&
                (e.offsetInText + e.data.length == e.textNode.data.length &&
                  ('forward' != this.direction || (this.boundaries && this.boundaries.end.isEqual(this.position))
                    ? (o = Zi._createAfter(e.textNode))
                    : ((i = Zi._createAfter(e.textNode)), (this.position = i))),
                0 === e.offsetInText &&
                  ('backward' != this.direction || (this.boundaries && this.boundaries.start.isEqual(this.position))
                    ? (o = Zi._createBefore(e.textNode))
                    : ((i = Zi._createBefore(e.textNode)), (this.position = i)))),
              { done: !1, value: { type: t, item: e, previousPosition: o, nextPosition: i, length: n } }
            );
          }
        }
        class Zi {
          constructor(t, e) {
            (this.parent = t), (this.offset = e);
          }
          get nodeAfter() {
            return this.parent.is('text') ? null : this.parent.getChild(this.offset) || null;
          }
          get nodeBefore() {
            return this.parent.is('text') ? null : this.parent.getChild(this.offset - 1) || null;
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            const t = this.parent.is('text') ? this.parent.data.length : this.parent.childCount;
            return this.offset === t;
          }
          get root() {
            return this.parent.root;
          }
          get editableElement() {
            let t = this.parent;
            for (; !(t instanceof $i); ) {
              if (!t.parent) return null;
              t = t.parent;
            }
            return t;
          }
          getShiftedBy(t) {
            const e = Zi._createAt(this),
              o = e.offset + t;
            return (e.offset = o < 0 ? 0 : o), e;
          }
          getLastMatchingPosition(t, e = {}) {
            e.startPosition = this;
            const o = new Ji(e);
            return o.skip(t), o.position;
          }
          getAncestors() {
            return this.parent.is('documentFragment') ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
          }
          getCommonAncestor(t) {
            const e = this.getAncestors(),
              o = t.getAncestors();
            let i = 0;
            for (; e[i] == o[i] && e[i]; ) i++;
            return 0 === i ? null : e[i - 1];
          }
          is(t) {
            return 'position' === t || 'view:position' === t;
          }
          isEqual(t) {
            return this.parent == t.parent && this.offset == t.offset;
          }
          isBefore(t) {
            return 'before' == this.compareWith(t);
          }
          isAfter(t) {
            return 'after' == this.compareWith(t);
          }
          compareWith(t) {
            if (this.root !== t.root) return 'different';
            if (this.isEqual(t)) return 'same';
            const e = this.parent.is('node') ? this.parent.getPath() : [],
              o = t.parent.is('node') ? t.parent.getPath() : [];
            e.push(this.offset), o.push(t.offset);
            const i = Io(e, o);
            switch (i) {
              case 'prefix':
                return 'before';
              case 'extension':
                return 'after';
              default:
                return e[i] < o[i] ? 'before' : 'after';
            }
          }
          getWalker(t = {}) {
            return (t.startPosition = this), new Ji(t);
          }
          clone() {
            return new Zi(this.parent, this.offset);
          }
          static _createAt(t, e) {
            if (t instanceof Zi) return new this(t.parent, t.offset);
            {
              const o = t;
              if ('end' == e) e = o.is('text') ? o.data.length : o.childCount;
              else {
                if ('before' == e) return this._createBefore(o);
                if ('after' == e) return this._createAfter(o);
                if (0 !== e && !e)
                  throw new uo.b(
                    'view-createPositionAt-offset-required: View#createPositionAt() requires the offset when the first parameter is a view item.',
                    o
                  );
              }
              return new Zi(o, e);
            }
          }
          static _createAfter(t) {
            if (t.is('textProxy')) return new Zi(t.textNode, t.offsetInText + t.data.length);
            if (!t.parent)
              throw new uo.b('view-position-after-root: You can not make position after root.', t, { root: t });
            return new Zi(t.parent, t.index + 1);
          }
          static _createBefore(t) {
            if (t.is('textProxy')) return new Zi(t.textNode, t.offsetInText);
            if (!t.parent)
              throw new uo.b('view-position-before-root: You can not make position before root.', t, { root: t });
            return new Zi(t.parent, t.index);
          }
        }
        class Xi {
          constructor(t, e = null) {
            (this.start = t.clone()), (this.end = e ? e.clone() : t.clone());
          }
          *[Symbol.iterator]() {
            yield* new Ji({ boundaries: this, ignoreElementEnd: !0 });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return this.start.parent === this.end.parent;
          }
          get root() {
            return this.start.root;
          }
          getEnlarged() {
            let t = this.start.getLastMatchingPosition(tn, { direction: 'backward' }),
              e = this.end.getLastMatchingPosition(tn);
            return (
              t.parent.is('text') && t.isAtStart && (t = Zi._createBefore(t.parent)),
              e.parent.is('text') && e.isAtEnd && (e = Zi._createAfter(e.parent)),
              new Xi(t, e)
            );
          }
          getTrimmed() {
            let t = this.start.getLastMatchingPosition(tn);
            if (t.isAfter(this.end) || t.isEqual(this.end)) return new Xi(t, t);
            let e = this.end.getLastMatchingPosition(tn, { direction: 'backward' });
            const o = t.nodeAfter,
              i = e.nodeBefore;
            return (
              o && o.is('text') && (t = new Zi(o, 0)), i && i.is('text') && (e = new Zi(i, i.data.length)), new Xi(t, e)
            );
          }
          isEqual(t) {
            return this == t || (this.start.isEqual(t.start) && this.end.isEqual(t.end));
          }
          containsPosition(t) {
            return t.isAfter(this.start) && t.isBefore(this.end);
          }
          containsRange(t, e = !1) {
            t.isCollapsed && (e = !1);
            const o = this.containsPosition(t.start) || (e && this.start.isEqual(t.start)),
              i = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
            return o && i;
          }
          getDifference(t) {
            const e = [];
            return (
              this.isIntersecting(t)
                ? (this.containsPosition(t.start) && e.push(new Xi(this.start, t.start)),
                  this.containsPosition(t.end) && e.push(new Xi(t.end, this.end)))
                : e.push(this.clone()),
              e
            );
          }
          getIntersection(t) {
            if (this.isIntersecting(t)) {
              let e = this.start,
                o = this.end;
              return (
                this.containsPosition(t.start) && (e = t.start),
                this.containsPosition(t.end) && (o = t.end),
                new Xi(e, o)
              );
            }
            return null;
          }
          getWalker(t = {}) {
            return (t.boundaries = this), new Ji(t);
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed) return null;
            let t = this.start.nodeAfter,
              e = this.end.nodeBefore;
            return (
              this.start.parent.is('text') &&
                this.start.isAtEnd &&
                this.start.parent.nextSibling &&
                (t = this.start.parent.nextSibling),
              this.end.parent.is('text') &&
                this.end.isAtStart &&
                this.end.parent.previousSibling &&
                (e = this.end.parent.previousSibling),
              t && t.is('element') && t === e ? t : null
            );
          }
          clone() {
            return new Xi(this.start, this.end);
          }
          *getItems(t = {}) {
            (t.boundaries = this), (t.ignoreElementEnd = !0);
            const e = new Ji(t);
            for (const t of e) yield t.item;
          }
          *getPositions(t = {}) {
            t.boundaries = this;
            const e = new Ji(t);
            yield e.position;
            for (const t of e) yield t.nextPosition;
          }
          is(t) {
            return 'range' === t || 'view:range' === t;
          }
          isIntersecting(t) {
            return this.start.isBefore(t.end) && this.end.isAfter(t.start);
          }
          static _createFromParentsAndOffsets(t, e, o, i) {
            return new this(new Zi(t, e), new Zi(o, i));
          }
          static _createFromPositionAndShift(t, e) {
            const o = t,
              i = t.getShiftedBy(e);
            return e > 0 ? new this(o, i) : new this(i, o);
          }
          static _createIn(t) {
            return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
          }
          static _createOn(t) {
            const e = t.is('textProxy') ? t.offsetSize : 1;
            return this._createFromPositionAndShift(Zi._createBefore(t), e);
          }
        }
        function tn(t) {
          return !(!t.item.is('attributeElement') && !t.item.is('uiElement'));
        }
        function en(t) {
          let e = 0;
          for (const o of t) e++;
          return e;
        }
        class on {
          constructor(t = null, e, o) {
            (this._ranges = []),
              (this._lastRangeBackward = !1),
              (this._isFake = !1),
              (this._fakeSelectionLabel = ''),
              this.setTo(t, e, o);
          }
          get isFake() {
            return this._isFake;
          }
          get fakeSelectionLabel() {
            return this._fakeSelectionLabel;
          }
          get anchor() {
            if (!this._ranges.length) return null;
            const t = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t.end : t.start).clone();
          }
          get focus() {
            if (!this._ranges.length) return null;
            const t = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t.start : t.end).clone();
          }
          get isCollapsed() {
            return 1 === this.rangeCount && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          get editableElement() {
            return this.anchor ? this.anchor.editableElement : null;
          }
          *getRanges() {
            for (const t of this._ranges) yield t.clone();
          }
          getFirstRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.start.isBefore(t.start)) || (t = e);
            return t ? t.clone() : null;
          }
          getLastRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.end.isAfter(t.end)) || (t = e);
            return t ? t.clone() : null;
          }
          getFirstPosition() {
            const t = this.getFirstRange();
            return t ? t.start.clone() : null;
          }
          getLastPosition() {
            const t = this.getLastRange();
            return t ? t.end.clone() : null;
          }
          isEqual(t) {
            if (this.isFake != t.isFake) return !1;
            if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) return !1;
            if (this.rangeCount != t.rangeCount) return !1;
            if (0 === this.rangeCount) return !0;
            if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
            for (const e of this._ranges) {
              let o = !1;
              for (const i of t._ranges)
                if (e.isEqual(i)) {
                  o = !0;
                  break;
                }
              if (!o) return !1;
            }
            return !0;
          }
          isSimilar(t) {
            if (this.isBackward != t.isBackward) return !1;
            const e = en(this.getRanges());
            if (e != en(t.getRanges())) return !1;
            if (0 == e) return !0;
            for (let e of this.getRanges()) {
              e = e.getTrimmed();
              let o = !1;
              for (let i of t.getRanges())
                if (((i = i.getTrimmed()), e.start.isEqual(i.start) && e.end.isEqual(i.end))) {
                  o = !0;
                  break;
                }
              if (!o) return !1;
            }
            return !0;
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          setTo(t, e, o) {
            if (null === t) this._setRanges([]), this._setFakeOptions(e);
            else if (t instanceof on || t instanceof nn)
              this._setRanges(t.getRanges(), t.isBackward),
                this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
            else if (t instanceof Xi) this._setRanges([t], e && e.backward), this._setFakeOptions(e);
            else if (t instanceof Zi) this._setRanges([new Xi(t)]), this._setFakeOptions(e);
            else if (t instanceof Ro) {
              const i = !!o && !!o.backward;
              let n;
              if (void 0 === e)
                throw new uo.b(
                  'view-selection-setTo-required-second-parameter: selection.setTo requires the second parameter when the first parameter is a node.',
                  this
                );
              (n = 'in' == e ? Xi._createIn(t) : 'on' == e ? Xi._createOn(t) : new Xi(Zi._createAt(t, e))),
                this._setRanges([n], i),
                this._setFakeOptions(o);
            } else {
              if (!yo(t))
                throw new uo.b('view-selection-setTo-not-selectable: Cannot set selection to given place.', this);
              this._setRanges(t, e && e.backward), this._setFakeOptions(e);
            }
            this.fire('change');
          }
          setFocus(t, e) {
            if (null === this.anchor)
              throw new uo.b(
                'view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.',
                this
              );
            const o = Zi._createAt(t, e);
            if ('same' == o.compareWith(this.focus)) return;
            const i = this.anchor;
            this._ranges.pop(),
              'before' == o.compareWith(i) ? this._addRange(new Xi(o, i), !0) : this._addRange(new Xi(i, o)),
              this.fire('change');
          }
          is(t) {
            return 'selection' === t || 'view:selection' === t;
          }
          _setRanges(t, e = !1) {
            (t = Array.from(t)), (this._ranges = []);
            for (const e of t) this._addRange(e);
            this._lastRangeBackward = !!e;
          }
          _setFakeOptions(t = {}) {
            (this._isFake = !!t.fake), (this._fakeSelectionLabel = (t.fake && t.label) || '');
          }
          _addRange(t, e = !1) {
            if (!(t instanceof Xi))
              throw new uo.b(
                'view-selection-add-range-not-range: Selection range set to an object that is not an instance of view.Range',
                this
              );
            this._pushRange(t), (this._lastRangeBackward = !!e);
          }
          _pushRange(t) {
            for (const e of this._ranges)
              if (t.isIntersecting(e))
                throw new uo.b(
                  'view-selection-range-intersects: Trying to add a range that intersects with another range from selection.',
                  this,
                  { addedRange: t, intersectingRange: e }
                );
            this._ranges.push(new Xi(t.start, t.end));
          }
        }
        xo(on, fo);
        class nn {
          constructor(t = null, e, o) {
            (this._selection = new on()), this._selection.delegate('change').to(this), this._selection.setTo(t, e, o);
          }
          get isFake() {
            return this._selection.isFake;
          }
          get fakeSelectionLabel() {
            return this._selection.fakeSelectionLabel;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get editableElement() {
            return this._selection.editableElement;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          *getRanges() {
            yield* this._selection.getRanges();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          isEqual(t) {
            return this._selection.isEqual(t);
          }
          isSimilar(t) {
            return this._selection.isSimilar(t);
          }
          is(t) {
            return (
              'selection' === t || 'documentSelection' == t || 'view:selection' == t || 'view:documentSelection' == t
            );
          }
          _setTo(t, e, o) {
            this._selection.setTo(t, e, o);
          }
          _setFocus(t, e) {
            this._selection.setFocus(t, e);
          }
        }
        xo(nn, fo);
        class rn {
          constructor(t) {
            (this.selection = new nn()),
              (this.roots = new Co({ idProperty: 'rootName' })),
              (this.stylesProcessor = t),
              this.set('isReadOnly', !1),
              this.set('isFocused', !1),
              this.set('isComposing', !1),
              (this._postFixers = new Set());
          }
          getRoot(t = 'main') {
            return this.roots.get(t);
          }
          registerPostFixer(t) {
            this._postFixers.add(t);
          }
          destroy() {
            this.roots.map(t => t.destroy()), this.stopListening();
          }
          _callPostFixers(t) {
            let e = !1;
            do {
              for (const o of this._postFixers) if (((e = o(t)), e)) break;
            } while (e);
          }
        }
        xo(rn, Hi);
        class sn extends Ri {
          constructor(t, e, o, i) {
            super(t, e, o, i),
              (this.getFillerOffset = an),
              (this._priority = 10),
              (this._id = null),
              (this._clonesGroup = null);
          }
          get priority() {
            return this._priority;
          }
          get id() {
            return this._id;
          }
          getElementsWithSameId() {
            if (null === this.id)
              throw new uo.b(
                'attribute-element-get-elements-with-same-id-no-id: Cannot get elements with the same id for an attribute element without id.',
                this
              );
            return new Set(this._clonesGroup);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('attributeElement' === t || 'view:attributeElement' === t || 'element' === t || 'view:element' === t)
              : 'attributeElement' === t ||
                  'view:attributeElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          isSimilar(t) {
            return null !== this.id || null !== t.id
              ? this.id === t.id
              : super.isSimilar(t) && this.priority == t.priority;
          }
          _clone(t) {
            const e = super._clone(t);
            return (e._priority = this._priority), (e._id = this._id), e;
          }
        }
        function an() {
          if (ln(this)) return null;
          let t = this.parent;
          for (; t && t.is('attributeElement'); ) {
            if (ln(t) > 1) return null;
            t = t.parent;
          }
          return !t || ln(t) > 1 ? null : this.childCount;
        }
        function ln(t) {
          return Array.from(t.getChildren()).filter(t => !t.is('uiElement')).length;
        }
        sn.DEFAULT_PRIORITY = 10;
        class cn extends Ri {
          constructor(t, e, o, i) {
            super(t, e, o, i), (this.getFillerOffset = dn);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('emptyElement' === t || 'view:emptyElement' === t || 'element' === t || 'view:element' === t)
              : 'emptyElement' === t ||
                  'view:emptyElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          _insertChild(t, e) {
            if (e && (e instanceof Ro || Array.from(e).length > 0))
              throw new uo.b('view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.', [
                this,
                e,
              ]);
          }
        }
        function dn() {
          return null;
        }
        const hn = navigator.userAgent.toLowerCase();
        var un = {
          isMac: (function (t) {
            return t.indexOf('macintosh') > -1;
          })(hn),
          isGecko: (function (t) {
            return !!t.match(/gecko\/\d+/);
          })(hn),
          isSafari: (function (t) {
            return t.indexOf(' applewebkit/') > -1 && -1 === t.indexOf('chrome');
          })(hn),
          isAndroid: (function (t) {
            return t.indexOf('android') > -1;
          })(hn),
          features: {
            isRegExpUnicodePropertySupported: (function () {
              let t = !1;
              try {
                t = 0 === 'ć'.search(new RegExp('[\\p{L}]', 'u'));
              } catch (t) {}
              return t;
            })(),
          },
        };
        const gn = { '⌘': 'ctrl', '⇧': 'shift', '⌥': 'alt' },
          mn = { ctrl: '⌘', shift: '⇧', alt: '⌥' },
          fn = (function () {
            const t = {
              arrowleft: 37,
              arrowup: 38,
              arrowright: 39,
              arrowdown: 40,
              backspace: 8,
              delete: 46,
              enter: 13,
              space: 32,
              esc: 27,
              tab: 9,
              ctrl: 1114112,
              cmd: 1114112,
              shift: 2228224,
              alt: 4456448,
            };
            for (let e = 65; e <= 90; e++) {
              const o = String.fromCharCode(e);
              t[o.toLowerCase()] = e;
            }
            for (let e = 48; e <= 57; e++) t[e - 48] = e;
            for (let e = 112; e <= 123; e++) t['f' + (e - 111)] = e;
            return t;
          })();
        function pn(t) {
          let e;
          if ('string' == typeof t) {
            if (((e = fn[t.toLowerCase()]), !e))
              throw new uo.b('keyboard-unknown-key: Unknown key name.', null, { key: t });
          } else e = t.keyCode + (t.altKey ? fn.alt : 0) + (t.ctrlKey ? fn.ctrl : 0) + (t.shiftKey ? fn.shift : 0);
          return e;
        }
        function bn(t) {
          return (
            'string' == typeof t && (t = kn(t)),
            t.map(t => ('string' == typeof t ? pn(t) : t)).reduce((t, e) => e + t, 0)
          );
        }
        function wn(t) {
          return un.isMac
            ? kn(t)
                .map(t => mn[t.toLowerCase()] || t)
                .reduce((t, e) => (t.slice(-1) in gn ? t + e : t + '+' + e))
            : t;
        }
        function kn(t) {
          return t.split(/\s*\+\s*/);
        }
        class _n extends Ri {
          constructor(t, e, o, i) {
            super(t, e, o, i), (this.getFillerOffset = yn);
          }
          is(t, e = null) {
            return e
              ? e === this.name &&
                  ('uiElement' === t || 'view:uiElement' === t || 'element' === t || 'view:element' === t)
              : 'uiElement' === t ||
                  'view:uiElement' === t ||
                  t === this.name ||
                  t === 'view:' + this.name ||
                  'element' === t ||
                  'view:element' === t ||
                  'node' === t ||
                  'view:node' === t;
          }
          _insertChild(t, e) {
            if (e && (e instanceof Ro || Array.from(e).length > 0))
              throw new uo.b('view-uielement-cannot-add: Cannot add child nodes to UIElement instance.', this);
          }
          render(t) {
            return this.toDomElement(t);
          }
          toDomElement(t) {
            const e = t.createElement(this.name);
            for (const t of this.getAttributeKeys()) e.setAttribute(t, this.getAttribute(t));
            return e;
          }
        }
        function vn(t) {
          t.document.on('keydown', (e, o) =>
            (function (t, e, o) {
              if (e.keyCode == fn.arrowright) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection(),
                  i = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
                if (i || e.shiftKey) {
                  const e = t.focusNode,
                    n = t.focusOffset,
                    r = o.domPositionToView(e, n);
                  if (null === r) return;
                  let s = !1;
                  const a = r.getLastMatchingPosition(
                    t => (
                      t.item.is('uiElement') && (s = !0), !(!t.item.is('uiElement') && !t.item.is('attributeElement'))
                    )
                  );
                  if (s) {
                    const e = o.viewPositionToDom(a);
                    i ? t.collapse(e.parent, e.offset) : t.extend(e.parent, e.offset);
                  }
                }
              }
            })(0, o, t.domConverter)
          );
        }
        function yn() {
          return null;
        }
        class xn {
          constructor(t, e) {
            (this.document = t), (this._children = []), e && this._insertChild(0, e);
          }
          [Symbol.iterator]() {
            return this._children[Symbol.iterator]();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t) {
            return 'documentFragment' === t || 'view:documentFragment' === t;
          }
          _appendChild(t) {
            return this._insertChild(this.childCount, t);
          }
          getChild(t) {
            return this._children[t];
          }
          getChildIndex(t) {
            return this._children.indexOf(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          _insertChild(t, e) {
            this._fireChange('children', this);
            let o = 0;
            const i = (function (t, e) {
              if ('string' == typeof e) return [new Oo(t, e)];
              yo(e) || (e = [e]);
              return Array.from(e).map(e =>
                'string' == typeof e ? new Oo(t, e) : e instanceof Vo ? new Oo(t, e.data) : e
              );
            })(this.document, e);
            for (const e of i)
              null !== e.parent && e._remove(), (e.parent = this), this._children.splice(t, 0, e), t++, o++;
            return o;
          }
          _removeChildren(t, e = 1) {
            this._fireChange('children', this);
            for (let o = t; o < t + e; o++) this._children[o].parent = null;
            return this._children.splice(t, e);
          }
          _fireChange(t, e) {
            this.fire('change:' + t, e);
          }
        }
        xo(xn, fo);
        class Cn {
          constructor(t) {
            (this.document = t), (this._cloneGroups = new Map());
          }
          setSelection(t, e, o) {
            this.document.selection._setTo(t, e, o);
          }
          setSelectionFocus(t, e) {
            this.document.selection._setFocus(t, e);
          }
          createText(t) {
            return new Oo(this.document, t);
          }
          createAttributeElement(t, e, o = {}) {
            const i = new sn(this.document, t, e);
            return o.priority && (i._priority = o.priority), o.id && (i._id = o.id), i;
          }
          createContainerElement(t, e) {
            return new Vi(this.document, t, e);
          }
          createEditableElement(t, e) {
            const o = new $i(this.document, t, e);
            return (o._document = this.document), o;
          }
          createEmptyElement(t, e) {
            return new cn(this.document, t, e);
          }
          createUIElement(t, e, o) {
            const i = new _n(this.document, t, e);
            return o && (i.render = o), i;
          }
          setAttribute(t, e, o) {
            o._setAttribute(t, e);
          }
          removeAttribute(t, e) {
            e._removeAttribute(t);
          }
          addClass(t, e) {
            e._addClass(t);
          }
          removeClass(t, e) {
            e._removeClass(t);
          }
          setStyle(t, e, o) {
            y(t) && void 0 === o && (o = e), o._setStyle(t, e);
          }
          removeStyle(t, e) {
            e._removeStyle(t);
          }
          setCustomProperty(t, e, o) {
            o._setCustomProperty(t, e);
          }
          removeCustomProperty(t, e) {
            return e._removeCustomProperty(t);
          }
          breakAttributes(t) {
            return t instanceof Zi ? this._breakAttributes(t) : this._breakAttributesRange(t);
          }
          breakContainer(t) {
            const e = t.parent;
            if (!e.is('containerElement'))
              throw new uo.b(
                'view-writer-break-non-container-element: Trying to break an element which is not a container element.',
                this.document
              );
            if (!e.parent) throw new uo.b('view-writer-break-root: Trying to break root element.', this.document);
            if (t.isAtStart) return Zi._createBefore(e);
            if (!t.isAtEnd) {
              const o = e._clone(!1);
              this.insert(Zi._createAfter(e), o);
              const i = new Xi(t, Zi._createAt(e, 'end')),
                n = new Zi(o, 0);
              this.move(i, n);
            }
            return Zi._createAfter(e);
          }
          mergeAttributes(t) {
            const e = t.offset,
              o = t.parent;
            if (o.is('text')) return t;
            if (o.is('attributeElement') && 0 === o.childCount) {
              const t = o.parent,
                e = o.index;
              return o._remove(), this._removeFromClonedElementsGroup(o), this.mergeAttributes(new Zi(t, e));
            }
            const i = o.getChild(e - 1),
              n = o.getChild(e);
            if (!i || !n) return t;
            if (i.is('text') && n.is('text')) return En(i, n);
            if (i.is('attributeElement') && n.is('attributeElement') && i.isSimilar(n)) {
              const t = i.childCount;
              return (
                i._appendChild(n.getChildren()),
                n._remove(),
                this._removeFromClonedElementsGroup(n),
                this.mergeAttributes(new Zi(i, t))
              );
            }
            return t;
          }
          mergeContainers(t) {
            const e = t.nodeBefore,
              o = t.nodeAfter;
            if (!(e && o && e.is('containerElement') && o.is('containerElement')))
              throw new uo.b(
                'view-writer-merge-containers-invalid-position: Element before and after given position cannot be merged.',
                this.document
              );
            const i = e.getChild(e.childCount - 1),
              n = i instanceof Oo ? Zi._createAt(i, 'end') : Zi._createAt(e, 'end');
            return this.move(Xi._createIn(o), Zi._createAt(e, 'end')), this.remove(Xi._createOn(o)), n;
          }
          insert(t, e) {
            (function t(e, o) {
              for (const i of e) {
                if (!Mn.some(t => i instanceof t)) throw new uo.b('view-writer-insert-invalid-node', o);
                i.is('text') || t(i.getChildren(), o);
              }
            })((e = yo(e) ? [...e] : [e]), this.document);
            const o = An(t);
            if (!o) throw new uo.b('view-writer-invalid-position-container', this.document);
            const i = this._breakAttributes(t, !0),
              n = o._insertChild(i.offset, e);
            for (const t of e) this._addToClonedElementsGroup(t);
            const r = i.getShiftedBy(n),
              s = this.mergeAttributes(i);
            if (0 === n) return new Xi(s, s);
            {
              s.isEqual(i) || r.offset--;
              const t = this.mergeAttributes(r);
              return new Xi(s, t);
            }
          }
          remove(t) {
            const e = t instanceof Xi ? t : Xi._createOn(t);
            if ((Nn(e, this.document), e.isCollapsed)) return new xn(this.document);
            const { start: o, end: i } = this._breakAttributesRange(e, !0),
              n = o.parent,
              r = i.offset - o.offset,
              s = n._removeChildren(o.offset, r);
            for (const t of s) this._removeFromClonedElementsGroup(t);
            const a = this.mergeAttributes(o);
            return (e.start = a), (e.end = a.clone()), new xn(this.document, s);
          }
          clear(t, e) {
            Nn(t, this.document);
            const o = t.getWalker({ direction: 'backward', ignoreElementEnd: !0 });
            for (const i of o) {
              const o = i.item;
              let n;
              if (o.is('element') && e.isSimilar(o)) n = Xi._createOn(o);
              else if (!i.nextPosition.isAfter(t.start) && o.is('textProxy')) {
                const t = o.getAncestors().find(t => t.is('element') && e.isSimilar(t));
                t && (n = Xi._createIn(t));
              }
              n &&
                (n.end.isAfter(t.end) && (n.end = t.end),
                n.start.isBefore(t.start) && (n.start = t.start),
                this.remove(n));
            }
          }
          move(t, e) {
            let o;
            if (e.isAfter(t.end)) {
              const i = (e = this._breakAttributes(e, !0)).parent,
                n = i.childCount;
              (t = this._breakAttributesRange(t, !0)), (o = this.remove(t)), (e.offset += i.childCount - n);
            } else o = this.remove(t);
            return this.insert(e, o);
          }
          wrap(t, e) {
            if (!(e instanceof sn)) throw new uo.b('view-writer-wrap-invalid-attribute', this.document);
            if ((Nn(t, this.document), t.isCollapsed)) {
              let i = t.start;
              i.parent.is('element') &&
                ((o = i.parent), !Array.from(o.getChildren()).some(t => !t.is('uiElement'))) &&
                (i = i.getLastMatchingPosition(t => t.item.is('uiElement'))),
                (i = this._wrapPosition(i, e));
              const n = this.document.selection;
              return n.isCollapsed && n.getFirstPosition().isEqual(t.start) && this.setSelection(i), new Xi(i);
            }
            return this._wrapRange(t, e);
            var o;
          }
          unwrap(t, e) {
            if (!(e instanceof sn)) throw new uo.b('view-writer-unwrap-invalid-attribute', this.document);
            if ((Nn(t, this.document), t.isCollapsed)) return t;
            const { start: o, end: i } = this._breakAttributesRange(t, !0),
              n = o.parent,
              r = this._unwrapChildren(n, o.offset, i.offset, e),
              s = this.mergeAttributes(r.start);
            s.isEqual(r.start) || r.end.offset--;
            const a = this.mergeAttributes(r.end);
            return new Xi(s, a);
          }
          rename(t, e) {
            const o = new Vi(this.document, t, e.getAttributes());
            return (
              this.insert(Zi._createAfter(e), o),
              this.move(Xi._createIn(e), Zi._createAt(o, 0)),
              this.remove(Xi._createOn(e)),
              o
            );
          }
          clearClonedElementsGroup(t) {
            this._cloneGroups.delete(t);
          }
          createPositionAt(t, e) {
            return Zi._createAt(t, e);
          }
          createPositionAfter(t) {
            return Zi._createAfter(t);
          }
          createPositionBefore(t) {
            return Zi._createBefore(t);
          }
          createRange(t, e) {
            return new Xi(t, e);
          }
          createRangeOn(t) {
            return Xi._createOn(t);
          }
          createRangeIn(t) {
            return Xi._createIn(t);
          }
          createSelection(t, e, o) {
            return new on(t, e, o);
          }
          _wrapChildren(t, e, o, i) {
            let n = e;
            const r = [];
            for (; n < o; ) {
              const e = t.getChild(n),
                o = e.is('text'),
                s = e.is('attributeElement'),
                a = e.is('emptyElement'),
                l = e.is('uiElement');
              if (s && this._wrapAttributeElement(i, e)) r.push(new Zi(t, n));
              else if (o || a || l || (s && Tn(i, e))) {
                const o = i._clone();
                e._remove(),
                  o._appendChild(e),
                  t._insertChild(n, o),
                  this._addToClonedElementsGroup(o),
                  r.push(new Zi(t, n));
              } else s && this._wrapChildren(e, 0, e.childCount, i);
              n++;
            }
            let s = 0;
            for (const t of r) {
              if (((t.offset -= s), t.offset == e)) continue;
              this.mergeAttributes(t).isEqual(t) || (s++, o--);
            }
            return Xi._createFromParentsAndOffsets(t, e, t, o);
          }
          _unwrapChildren(t, e, o, i) {
            let n = e;
            const r = [];
            for (; n < o; ) {
              const e = t.getChild(n);
              if (e.is('attributeElement'))
                if (e.isSimilar(i)) {
                  const i = e.getChildren(),
                    s = e.childCount;
                  e._remove(),
                    t._insertChild(n, i),
                    this._removeFromClonedElementsGroup(e),
                    r.push(new Zi(t, n), new Zi(t, n + s)),
                    (n += s),
                    (o += s - 1);
                } else
                  this._unwrapAttributeElement(i, e)
                    ? (r.push(new Zi(t, n), new Zi(t, n + 1)), n++)
                    : (this._unwrapChildren(e, 0, e.childCount, i), n++);
              else n++;
            }
            let s = 0;
            for (const t of r) {
              if (((t.offset -= s), t.offset == e || t.offset == o)) continue;
              this.mergeAttributes(t).isEqual(t) || (s++, o--);
            }
            return Xi._createFromParentsAndOffsets(t, e, t, o);
          }
          _wrapRange(t, e) {
            const { start: o, end: i } = this._breakAttributesRange(t, !0),
              n = o.parent,
              r = this._wrapChildren(n, o.offset, i.offset, e),
              s = this.mergeAttributes(r.start);
            s.isEqual(r.start) || r.end.offset--;
            const a = this.mergeAttributes(r.end);
            return new Xi(s, a);
          }
          _wrapPosition(t, e) {
            if (e.isSimilar(t.parent)) return Sn(t.clone());
            t.parent.is('text') && (t = Pn(t));
            const o = this.createAttributeElement();
            (o._priority = Number.POSITIVE_INFINITY), (o.isSimilar = () => !1), t.parent._insertChild(t.offset, o);
            const i = new Xi(t, t.getShiftedBy(1));
            this.wrap(i, e);
            const n = new Zi(o.parent, o.index);
            o._remove();
            const r = n.nodeBefore,
              s = n.nodeAfter;
            return r instanceof Oo && s instanceof Oo ? En(r, s) : Sn(n);
          }
          _wrapAttributeElement(t, e) {
            if (!Rn(t, e)) return !1;
            if (t.name !== e.name || t.priority !== e.priority) return !1;
            for (const o of t.getAttributeKeys())
              if ('class' !== o && 'style' !== o && e.hasAttribute(o) && e.getAttribute(o) !== t.getAttribute(o))
                return !1;
            for (const o of t.getStyleNames()) if (e.hasStyle(o) && e.getStyle(o) !== t.getStyle(o)) return !1;
            for (const o of t.getAttributeKeys())
              'class' !== o && 'style' !== o && (e.hasAttribute(o) || this.setAttribute(o, t.getAttribute(o), e));
            for (const o of t.getStyleNames()) e.hasStyle(o) || this.setStyle(o, t.getStyle(o), e);
            for (const o of t.getClassNames()) e.hasClass(o) || this.addClass(o, e);
            return !0;
          }
          _unwrapAttributeElement(t, e) {
            if (!Rn(t, e)) return !1;
            if (t.name !== e.name || t.priority !== e.priority) return !1;
            for (const o of t.getAttributeKeys())
              if ('class' !== o && 'style' !== o && (!e.hasAttribute(o) || e.getAttribute(o) !== t.getAttribute(o)))
                return !1;
            if (!e.hasClass(...t.getClassNames())) return !1;
            for (const o of t.getStyleNames()) if (!e.hasStyle(o) || e.getStyle(o) !== t.getStyle(o)) return !1;
            for (const o of t.getAttributeKeys()) 'class' !== o && 'style' !== o && this.removeAttribute(o, e);
            return (
              this.removeClass(Array.from(t.getClassNames()), e), this.removeStyle(Array.from(t.getStyleNames()), e), !0
            );
          }
          _breakAttributesRange(t, e = !1) {
            const o = t.start,
              i = t.end;
            if ((Nn(t, this.document), t.isCollapsed)) {
              const o = this._breakAttributes(t.start, e);
              return new Xi(o, o);
            }
            const n = this._breakAttributes(i, e),
              r = n.parent.childCount,
              s = this._breakAttributes(o, e);
            return (n.offset += n.parent.childCount - r), new Xi(s, n);
          }
          _breakAttributes(t, e = !1) {
            const o = t.offset,
              i = t.parent;
            if (t.parent.is('emptyElement')) throw new uo.b('view-writer-cannot-break-empty-element', this.document);
            if (t.parent.is('uiElement')) throw new uo.b('view-writer-cannot-break-ui-element', this.document);
            if (!e && i.is('text') && In(i.parent)) return t.clone();
            if (In(i)) return t.clone();
            if (i.is('text')) return this._breakAttributes(Pn(t), e);
            if (o == i.childCount) {
              const t = new Zi(i.parent, i.index + 1);
              return this._breakAttributes(t, e);
            }
            if (0 === o) {
              const t = new Zi(i.parent, i.index);
              return this._breakAttributes(t, e);
            }
            {
              const t = i.index + 1,
                n = i._clone();
              i.parent._insertChild(t, n), this._addToClonedElementsGroup(n);
              const r = i.childCount - o,
                s = i._removeChildren(o, r);
              n._appendChild(s);
              const a = new Zi(i.parent, t);
              return this._breakAttributes(a, e);
            }
          }
          _addToClonedElementsGroup(t) {
            if (!t.root.is('rootElement')) return;
            if (t.is('element')) for (const e of t.getChildren()) this._addToClonedElementsGroup(e);
            const e = t.id;
            if (!e) return;
            let o = this._cloneGroups.get(e);
            o || ((o = new Set()), this._cloneGroups.set(e, o)), o.add(t), (t._clonesGroup = o);
          }
          _removeFromClonedElementsGroup(t) {
            if (t.is('element')) for (const e of t.getChildren()) this._removeFromClonedElementsGroup(e);
            const e = t.id;
            if (!e) return;
            const o = this._cloneGroups.get(e);
            o && o.delete(t);
          }
        }
        function An(t) {
          let e = t.parent;
          for (; !In(e); ) {
            if (!e) return;
            e = e.parent;
          }
          return e;
        }
        function Tn(t, e) {
          return t.priority < e.priority || (!(t.priority > e.priority) && t.getIdentity() < e.getIdentity());
        }
        function Sn(t) {
          const e = t.nodeBefore;
          if (e && e.is('text')) return new Zi(e, e.data.length);
          const o = t.nodeAfter;
          return o && o.is('text') ? new Zi(o, 0) : t;
        }
        function Pn(t) {
          if (t.offset == t.parent.data.length) return new Zi(t.parent.parent, t.parent.index + 1);
          if (0 === t.offset) return new Zi(t.parent.parent, t.parent.index);
          const e = t.parent.data.slice(t.offset);
          return (
            (t.parent._data = t.parent.data.slice(0, t.offset)),
            t.parent.parent._insertChild(t.parent.index + 1, new Oo(t.root.document, e)),
            new Zi(t.parent.parent, t.parent.index + 1)
          );
        }
        function En(t, e) {
          const o = t.data.length;
          return (t._data += e.data), e._remove(), new Zi(t, o);
        }
        const Mn = [Oo, sn, Vi, cn, _n];
        function In(t) {
          return t && (t.is('containerElement') || t.is('documentFragment'));
        }
        function Nn(t, e) {
          const o = An(t.start),
            i = An(t.end);
          if (!o || !i || o !== i) throw new uo.b('view-writer-invalid-range-container', e);
        }
        function Rn(t, e) {
          return null === t.id && null === e.id;
        }
        function On(t) {
          return '[object Text]' == Object.prototype.toString.call(t);
        }
        const Vn = t => t.createTextNode(' '),
          Dn = t => {
            const e = t.createElement('br');
            return (e.dataset.ckeFiller = !0), e;
          },
          zn = (() => {
            let t = '';
            for (let e = 0; e < 7; e++) t += '​';
            return t;
          })();
        function Ln(t) {
          return On(t) && t.data.substr(0, 7) === zn;
        }
        function jn(t) {
          return 7 == t.data.length && Ln(t);
        }
        function Bn(t) {
          return Ln(t) ? t.data.slice(7) : t.data;
        }
        function Fn(t, e) {
          if (e.keyCode == fn.arrowleft) {
            const t = e.domTarget.ownerDocument.defaultView.getSelection();
            if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
              const e = t.getRangeAt(0).startContainer,
                o = t.getRangeAt(0).startOffset;
              Ln(e) && o <= 7 && t.collapse(e, 0);
            }
          }
        }
        function Hn(t, e, o, i = !1) {
          (o =
            o ||
            function (t, e) {
              return t === e;
            }),
            Array.isArray(t) || (t = Array.prototype.slice.call(t)),
            Array.isArray(e) || (e = Array.prototype.slice.call(e));
          const n = (function (t, e, o) {
            const i = Wn(t, e, o);
            if (-1 === i) return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
            const n = Un(t, i),
              r = Un(e, i),
              s = Wn(n, r, o),
              a = t.length - s,
              l = e.length - s;
            return { firstIndex: i, lastIndexOld: a, lastIndexNew: l };
          })(t, e, o);
          return i
            ? (function (t, e) {
                const { firstIndex: o, lastIndexOld: i, lastIndexNew: n } = t;
                if (-1 === o) return Array(e).fill('equal');
                let r = [];
                o > 0 && (r = r.concat(Array(o).fill('equal')));
                n - o > 0 && (r = r.concat(Array(n - o).fill('insert')));
                i - o > 0 && (r = r.concat(Array(i - o).fill('delete')));
                n < e && (r = r.concat(Array(e - n).fill('equal')));
                return r;
              })(n, e.length)
            : (function (t, e) {
                const o = [],
                  { firstIndex: i, lastIndexOld: n, lastIndexNew: r } = e;
                r - i > 0 && o.push({ index: i, type: 'insert', values: t.slice(i, r) });
                n - i > 0 && o.push({ index: i + (r - i), type: 'delete', howMany: n - i });
                return o;
              })(e, n);
        }
        function Wn(t, e, o) {
          for (let i = 0; i < Math.max(t.length, e.length); i++)
            if (void 0 === t[i] || void 0 === e[i] || !o(t[i], e[i])) return i;
          return -1;
        }
        function Un(t, e) {
          return t.slice(e).reverse();
        }
        function qn(t, e, o) {
          o =
            o ||
            function (t, e) {
              return t === e;
            };
          const i = t.length,
            n = e.length;
          if (i > 200 || n > 200 || i + n > 300) return qn.fastDiff(t, e, o, !0);
          let r, s;
          if (n < i) {
            const o = t;
            (t = e), (e = o), (r = 'delete'), (s = 'insert');
          } else (r = 'insert'), (s = 'delete');
          const a = t.length,
            l = e.length,
            c = l - a,
            d = {},
            h = {};
          function u(i) {
            const n = (void 0 !== h[i - 1] ? h[i - 1] : -1) + 1,
              c = void 0 !== h[i + 1] ? h[i + 1] : -1,
              u = n > c ? -1 : 1;
            d[i + u] && (d[i] = d[i + u].slice(0)), d[i] || (d[i] = []), d[i].push(n > c ? r : s);
            let g = Math.max(n, c),
              m = g - i;
            for (; m < a && g < l && o(t[m], e[g]); ) m++, g++, d[i].push('equal');
            return g;
          }
          let g,
            m = 0;
          do {
            for (g = -m; g < c; g++) h[g] = u(g);
            for (g = c + m; g > c; g--) h[g] = u(g);
            (h[c] = u(c)), m++;
          } while (h[c] !== l);
          return d[c].slice(1);
        }
        function Gn(t, e, o) {
          t.insertBefore(o, t.childNodes[e] || null);
        }
        function Yn(t) {
          const e = t.parentNode;
          e && e.removeChild(t);
        }
        function $n(t) {
          if (t) {
            if (t.defaultView) return t instanceof t.defaultView.Document;
            if (t.ownerDocument && t.ownerDocument.defaultView) return t instanceof t.ownerDocument.defaultView.Node;
          }
          return !1;
        }
        qn.fastDiff = Hn;
        class Qn {
          constructor(t, e) {
            (this.domDocuments = new Set()),
              (this.domConverter = t),
              (this.markedAttributes = new Set()),
              (this.markedChildren = new Set()),
              (this.markedTexts = new Set()),
              (this.selection = e),
              (this.isFocused = !1),
              (this._inlineFiller = null),
              (this._fakeSelectionContainer = null);
          }
          markToSync(t, e) {
            if ('text' === t) this.domConverter.mapViewToDom(e.parent) && this.markedTexts.add(e);
            else {
              if (!this.domConverter.mapViewToDom(e)) return;
              if ('attributes' === t) this.markedAttributes.add(e);
              else {
                if ('children' !== t)
                  throw new uo.b('view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.', this);
                this.markedChildren.add(e);
              }
            }
          }
          render() {
            let t;
            for (const t of this.markedChildren) this._updateChildrenMappings(t);
            this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(),
              this._inlineFiller
                ? (t = this._getInlineFillerPosition())
                : this._needsInlineFillerAtSelection() &&
                  ((t = this.selection.getFirstPosition()), this.markedChildren.add(t.parent));
            for (const t of this.markedAttributes) this._updateAttrs(t);
            for (const e of this.markedChildren) this._updateChildren(e, { inlineFillerPosition: t });
            for (const e of this.markedTexts)
              !this.markedChildren.has(e.parent) &&
                this.domConverter.mapViewToDom(e.parent) &&
                this._updateText(e, { inlineFillerPosition: t });
            if (t) {
              const e = this.domConverter.viewPositionToDom(t),
                o = e.parent.ownerDocument;
              Ln(e.parent) ? (this._inlineFiller = e.parent) : (this._inlineFiller = Kn(o, e.parent, e.offset));
            } else this._inlineFiller = null;
            this._updateSelection(),
              this._updateFocus(),
              this.markedTexts.clear(),
              this.markedAttributes.clear(),
              this.markedChildren.clear();
          }
          _updateChildrenMappings(t) {
            const e = this.domConverter.mapViewToDom(t);
            if (!e) return;
            const o = this.domConverter.mapViewToDom(t).childNodes,
              i = Array.from(this.domConverter.viewChildrenToDom(t, e.ownerDocument, { withChildren: !1 })),
              n = this._diffNodeLists(o, i),
              r = this._findReplaceActions(n, o, i);
            if (-1 !== r.indexOf('replace')) {
              const e = { equal: 0, insert: 0, delete: 0 };
              for (const n of r)
                if ('replace' === n) {
                  const n = e.equal + e.insert,
                    r = e.equal + e.delete,
                    s = t.getChild(n);
                  s && !s.is('uiElement') && this._updateElementMappings(s, o[r]), Yn(i[n]), e.equal++;
                } else e[n]++;
            }
          }
          _updateElementMappings(t, e) {
            this.domConverter.unbindDomElement(e),
              this.domConverter.bindElements(e, t),
              this.markedChildren.add(t),
              this.markedAttributes.add(t);
          }
          _getInlineFillerPosition() {
            const t = this.selection.getFirstPosition();
            return t.parent.is('text') ? Zi._createBefore(this.selection.getFirstPosition().parent) : t;
          }
          _isSelectionInInlineFiller() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
            const t = this.selection.getFirstPosition(),
              e = this.domConverter.viewPositionToDom(t);
            return !!(e && On(e.parent) && Ln(e.parent));
          }
          _removeInlineFiller() {
            const t = this._inlineFiller;
            if (!Ln(t)) throw new uo.b('view-renderer-filler-was-lost: The inline filler node was lost.', this);
            jn(t) ? t.parentNode.removeChild(t) : (t.data = t.data.substr(7)), (this._inlineFiller = null);
          }
          _needsInlineFillerAtSelection() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
            const t = this.selection.getFirstPosition(),
              e = t.parent,
              o = t.offset;
            if (!this.domConverter.mapViewToDom(e.root)) return !1;
            if (!e.is('element')) return !1;
            if (
              !(function (t) {
                if ('false' == t.getAttribute('contenteditable')) return !1;
                const e = t.findAncestor(t => t.hasAttribute('contenteditable'));
                return !e || 'true' == e.getAttribute('contenteditable');
              })(e)
            )
              return !1;
            if (o === e.getFillerOffset()) return !1;
            const i = t.nodeBefore,
              n = t.nodeAfter;
            return !(i instanceof Oo || n instanceof Oo);
          }
          _updateText(t, e) {
            const o = this.domConverter.findCorrespondingDomText(t),
              i = this.domConverter.viewToDom(t, o.ownerDocument),
              n = o.data;
            let r = i.data;
            const s = e.inlineFillerPosition;
            if ((s && s.parent == t.parent && s.offset == t.index && (r = zn + r), n != r)) {
              const t = Hn(n, r);
              for (const e of t)
                'insert' === e.type ? o.insertData(e.index, e.values.join('')) : o.deleteData(e.index, e.howMany);
            }
          }
          _updateAttrs(t) {
            const e = this.domConverter.mapViewToDom(t);
            if (!e) return;
            const o = Array.from(e.attributes).map(t => t.name),
              i = t.getAttributeKeys();
            for (const o of i) e.setAttribute(o, t.getAttribute(o));
            for (const i of o) t.hasAttribute(i) || e.removeAttribute(i);
          }
          _updateChildren(t, e) {
            const o = this.domConverter.mapViewToDom(t);
            if (!o) return;
            const i = e.inlineFillerPosition,
              n = this.domConverter.mapViewToDom(t).childNodes,
              r = Array.from(
                this.domConverter.viewChildrenToDom(t, o.ownerDocument, { bind: !0, inlineFillerPosition: i })
              );
            i && i.parent === t && Kn(o.ownerDocument, r, i.offset);
            const s = this._diffNodeLists(n, r);
            let a = 0;
            const l = new Set();
            for (const t of s) 'delete' === t ? (l.add(n[a]), Yn(n[a])) : 'equal' === t && a++;
            a = 0;
            for (const t of s)
              'insert' === t
                ? (Gn(o, a, r[a]), a++)
                : 'equal' === t && (this._markDescendantTextToSync(this.domConverter.domToView(r[a])), a++);
            for (const t of l) t.parentNode || this.domConverter.unbindDomElement(t);
          }
          _diffNodeLists(t, e) {
            return qn(
              (t = (function (t, e) {
                const o = Array.from(t);
                if (0 == o.length || !e) return o;
                o[o.length - 1] == e && o.pop();
                return o;
              })(t, this._fakeSelectionContainer)),
              e,
              Zn.bind(null, this.domConverter)
            );
          }
          _findReplaceActions(t, e, o) {
            if (-1 === t.indexOf('insert') || -1 === t.indexOf('delete')) return t;
            let i = [],
              n = [],
              r = [];
            const s = { equal: 0, insert: 0, delete: 0 };
            for (const a of t)
              'insert' === a
                ? r.push(o[s.equal + s.insert])
                : 'delete' === a
                ? n.push(e[s.equal + s.delete])
                : ((i = i.concat(qn(n, r, Jn).map(t => ('equal' === t ? 'replace' : t)))),
                  i.push('equal'),
                  (n = []),
                  (r = [])),
                s[a]++;
            return i.concat(qn(n, r, Jn).map(t => ('equal' === t ? 'replace' : t)));
          }
          _markDescendantTextToSync(t) {
            if (t)
              if (t.is('text')) this.markedTexts.add(t);
              else if (t.is('element')) for (const e of t.getChildren()) this._markDescendantTextToSync(e);
          }
          _updateSelection() {
            if (0 === this.selection.rangeCount) return this._removeDomSelection(), void this._removeFakeSelection();
            const t = this.domConverter.mapViewToDom(this.selection.editableElement);
            this.isFocused &&
              t &&
              (this.selection.isFake
                ? this._updateFakeSelection(t)
                : (this._removeFakeSelection(), this._updateDomSelection(t)));
          }
          _updateFakeSelection(t) {
            const e = t.ownerDocument;
            this._fakeSelectionContainer ||
              (this._fakeSelectionContainer = (function (t) {
                const e = t.createElement('div');
                return (
                  Object.assign(e.style, { position: 'fixed', top: 0, left: '-9999px', width: '42px' }),
                  (e.textContent = ' '),
                  e
                );
              })(e));
            const o = this._fakeSelectionContainer;
            if ((this.domConverter.bindFakeSelection(o, this.selection), !this._fakeSelectionNeedsUpdate(t))) return;
            (o.parentElement && o.parentElement == t) || t.appendChild(o),
              (o.textContent = this.selection.fakeSelectionLabel || ' ');
            const i = e.getSelection(),
              n = e.createRange();
            i.removeAllRanges(), n.selectNodeContents(o), i.addRange(n);
          }
          _updateDomSelection(t) {
            const e = t.ownerDocument.defaultView.getSelection();
            if (!this._domSelectionNeedsUpdate(e)) return;
            const o = this.domConverter.viewPositionToDom(this.selection.anchor),
              i = this.domConverter.viewPositionToDom(this.selection.focus);
            t.focus(),
              e.collapse(o.parent, o.offset),
              e.extend(i.parent, i.offset),
              un.isGecko &&
                (function (t, e) {
                  const o = t.parent;
                  if (o.nodeType != Node.ELEMENT_NODE || t.offset != o.childNodes.length - 1) return;
                  const i = o.childNodes[t.offset];
                  i && 'BR' == i.tagName && e.addRange(e.getRangeAt(0));
                })(i, e);
          }
          _domSelectionNeedsUpdate(t) {
            if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
            const e = t && this.domConverter.domSelectionToView(t);
            return (!e || !this.selection.isEqual(e)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e));
          }
          _fakeSelectionNeedsUpdate(t) {
            const e = this._fakeSelectionContainer,
              o = t.ownerDocument.getSelection();
            return (
              !e ||
              e.parentElement !== t ||
              (o.anchorNode !== e && !e.contains(o.anchorNode)) ||
              e.textContent !== this.selection.fakeSelectionLabel
            );
          }
          _removeDomSelection() {
            for (const t of this.domDocuments) {
              if (t.getSelection().rangeCount) {
                const e = t.activeElement,
                  o = this.domConverter.mapDomToView(e);
                e && o && t.getSelection().removeAllRanges();
              }
            }
          }
          _removeFakeSelection() {
            const t = this._fakeSelectionContainer;
            t && t.remove();
          }
          _updateFocus() {
            if (this.isFocused) {
              const t = this.selection.editableElement;
              t && this.domConverter.focus(t);
            }
          }
        }
        function Kn(t, e, o) {
          const i = e instanceof Array ? e : e.childNodes,
            n = i[o];
          if (On(n)) return (n.data = zn + n.data), n;
          {
            const n = t.createTextNode(zn);
            return Array.isArray(e) ? i.splice(o, 0, n) : Gn(e, o, n), n;
          }
        }
        function Jn(t, e) {
          return $n(t) && $n(e) && !On(t) && !On(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase();
        }
        function Zn(t, e, o) {
          return e === o || (On(e) && On(o) ? e.data === o.data : !(!t.isBlockFiller(e) || !t.isBlockFiller(o)));
        }
        xo(Qn, Hi);
        var Xn = { window: window, document: document };
        function tr(t) {
          let e = 0;
          for (; t.previousSibling; ) (t = t.previousSibling), e++;
          return e;
        }
        function er(t) {
          const e = [];
          for (; t && t.nodeType != Node.DOCUMENT_NODE; ) e.unshift(t), (t = t.parentNode);
          return e;
        }
        const or = Dn(document);
        class ir {
          constructor(t, e = {}) {
            (this.document = t),
              (this.blockFillerMode = e.blockFillerMode || 'br'),
              (this.preElements = ['pre']),
              (this.blockElements = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption']),
              (this._blockFiller = 'br' == this.blockFillerMode ? Dn : Vn),
              (this._domToViewMapping = new WeakMap()),
              (this._viewToDomMapping = new WeakMap()),
              (this._fakeSelectionMapping = new WeakMap());
          }
          bindFakeSelection(t, e) {
            this._fakeSelectionMapping.set(t, new on(e));
          }
          fakeSelectionToView(t) {
            return this._fakeSelectionMapping.get(t);
          }
          bindElements(t, e) {
            this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
          }
          unbindDomElement(t) {
            const e = this._domToViewMapping.get(t);
            if (e) {
              this._domToViewMapping.delete(t), this._viewToDomMapping.delete(e);
              for (const e of t.childNodes) this.unbindDomElement(e);
            }
          }
          bindDocumentFragments(t, e) {
            this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
          }
          viewToDom(t, e, o = {}) {
            if (t.is('text')) {
              const o = this._processDataFromViewText(t);
              return e.createTextNode(o);
            }
            {
              if (this.mapViewToDom(t)) return this.mapViewToDom(t);
              let i;
              if (t.is('documentFragment'))
                (i = e.createDocumentFragment()), o.bind && this.bindDocumentFragments(i, t);
              else {
                if (t.is('uiElement')) return (i = t.render(e)), o.bind && this.bindElements(i, t), i;
                (i = t.hasAttribute('xmlns')
                  ? e.createElementNS(t.getAttribute('xmlns'), t.name)
                  : e.createElement(t.name)),
                  o.bind && this.bindElements(i, t);
                for (const e of t.getAttributeKeys()) i.setAttribute(e, t.getAttribute(e));
              }
              if (o.withChildren || void 0 === o.withChildren)
                for (const n of this.viewChildrenToDom(t, e, o)) i.appendChild(n);
              return i;
            }
          }
          *viewChildrenToDom(t, e, o = {}) {
            const i = t.getFillerOffset && t.getFillerOffset();
            let n = 0;
            for (const r of t.getChildren())
              i === n && (yield this._blockFiller(e)), yield this.viewToDom(r, e, o), n++;
            i === n && (yield this._blockFiller(e));
          }
          viewRangeToDom(t) {
            const e = this.viewPositionToDom(t.start),
              o = this.viewPositionToDom(t.end),
              i = document.createRange();
            return i.setStart(e.parent, e.offset), i.setEnd(o.parent, o.offset), i;
          }
          viewPositionToDom(t) {
            const e = t.parent;
            if (e.is('text')) {
              const o = this.findCorrespondingDomText(e);
              if (!o) return null;
              let i = t.offset;
              return Ln(o) && (i += 7), { parent: o, offset: i };
            }
            {
              let o, i, n;
              if (0 === t.offset) {
                if (((o = this.mapViewToDom(e)), !o)) return null;
                n = o.childNodes[0];
              } else {
                const e = t.nodeBefore;
                if (((i = e.is('text') ? this.findCorrespondingDomText(e) : this.mapViewToDom(t.nodeBefore)), !i))
                  return null;
                (o = i.parentNode), (n = i.nextSibling);
              }
              if (On(n) && Ln(n)) return { parent: n, offset: 7 };
              return { parent: o, offset: i ? tr(i) + 1 : 0 };
            }
          }
          domToView(t, e = {}) {
            if (this.isBlockFiller(t, this.blockFillerMode)) return null;
            const o = this.getParentUIElement(t, this._domToViewMapping);
            if (o) return o;
            if (On(t)) {
              if (jn(t)) return null;
              {
                const e = this._processDataFromDomText(t);
                return '' === e ? null : new Oo(this.document, e);
              }
            }
            if (this.isComment(t)) return null;
            {
              if (this.mapDomToView(t)) return this.mapDomToView(t);
              let o;
              if (this.isDocumentFragment(t)) (o = new xn(this.document)), e.bind && this.bindDocumentFragments(t, o);
              else {
                const i = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                (o = new Ri(this.document, i)), e.bind && this.bindElements(t, o);
                const n = t.attributes;
                for (let t = n.length - 1; t >= 0; t--) o._setAttribute(n[t].name, n[t].value);
              }
              if (e.withChildren || void 0 === e.withChildren)
                for (const i of this.domChildrenToView(t, e)) o._appendChild(i);
              return o;
            }
          }
          *domChildrenToView(t, e = {}) {
            for (let o = 0; o < t.childNodes.length; o++) {
              const i = t.childNodes[o],
                n = this.domToView(i, e);
              null !== n && (yield n);
            }
          }
          domSelectionToView(t) {
            if (1 === t.rangeCount) {
              let e = t.getRangeAt(0).startContainer;
              On(e) && (e = e.parentNode);
              const o = this.fakeSelectionToView(e);
              if (o) return o;
            }
            const e = this.isDomSelectionBackward(t),
              o = [];
            for (let e = 0; e < t.rangeCount; e++) {
              const i = t.getRangeAt(e),
                n = this.domRangeToView(i);
              n && o.push(n);
            }
            return new on(o, { backward: e });
          }
          domRangeToView(t) {
            const e = this.domPositionToView(t.startContainer, t.startOffset),
              o = this.domPositionToView(t.endContainer, t.endOffset);
            return e && o ? new Xi(e, o) : null;
          }
          domPositionToView(t, e) {
            if (this.isBlockFiller(t, this.blockFillerMode)) return this.domPositionToView(t.parentNode, tr(t));
            const o = this.mapDomToView(t);
            if (o && o.is('uiElement')) return Zi._createBefore(o);
            if (On(t)) {
              if (jn(t)) return this.domPositionToView(t.parentNode, tr(t));
              const o = this.findCorrespondingViewText(t);
              let i = e;
              return o ? (Ln(t) && ((i -= 7), (i = i < 0 ? 0 : i)), new Zi(o, i)) : null;
            }
            if (0 === e) {
              const e = this.mapDomToView(t);
              if (e) return new Zi(e, 0);
            } else {
              const o = t.childNodes[e - 1],
                i = On(o) ? this.findCorrespondingViewText(o) : this.mapDomToView(o);
              if (i && i.parent) return new Zi(i.parent, i.index + 1);
            }
            return null;
          }
          mapDomToView(t) {
            return this.getParentUIElement(t) || this._domToViewMapping.get(t);
          }
          findCorrespondingViewText(t) {
            if (jn(t)) return null;
            const e = this.getParentUIElement(t);
            if (e) return e;
            const o = t.previousSibling;
            if (o) {
              if (!this.isElement(o)) return null;
              const t = this.mapDomToView(o);
              if (t) {
                return t.nextSibling instanceof Oo ? t.nextSibling : null;
              }
            } else {
              const e = this.mapDomToView(t.parentNode);
              if (e) {
                const t = e.getChild(0);
                return t instanceof Oo ? t : null;
              }
            }
            return null;
          }
          mapViewToDom(t) {
            return this._viewToDomMapping.get(t);
          }
          findCorrespondingDomText(t) {
            const e = t.previousSibling;
            return e && this.mapViewToDom(e)
              ? this.mapViewToDom(e).nextSibling
              : !e && t.parent && this.mapViewToDom(t.parent)
              ? this.mapViewToDom(t.parent).childNodes[0]
              : null;
          }
          focus(t) {
            const e = this.mapViewToDom(t);
            if (e && e.ownerDocument.activeElement !== e) {
              const { scrollX: t, scrollY: o } = Xn.window,
                i = [];
              rr(e, t => {
                const { scrollLeft: e, scrollTop: o } = t;
                i.push([e, o]);
              }),
                e.focus(),
                rr(e, t => {
                  const [e, o] = i.shift();
                  (t.scrollLeft = e), (t.scrollTop = o);
                }),
                Xn.window.scrollTo(t, o);
            }
          }
          isElement(t) {
            return t && t.nodeType == Node.ELEMENT_NODE;
          }
          isDocumentFragment(t) {
            return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
          }
          isComment(t) {
            return t && t.nodeType == Node.COMMENT_NODE;
          }
          isBlockFiller(t) {
            return 'br' == this.blockFillerMode
              ? t.isEqualNode(or)
              : !('BR' !== t.tagName || !sr(t, this.blockElements) || 1 !== t.parentNode.childNodes.length) ||
                  (function (t, e) {
                    return On(t) && ' ' == t.data && sr(t, e) && 1 === t.parentNode.childNodes.length;
                  })(t, this.blockElements);
          }
          isDomSelectionBackward(t) {
            if (t.isCollapsed) return !1;
            const e = document.createRange();
            e.setStart(t.anchorNode, t.anchorOffset), e.setEnd(t.focusNode, t.focusOffset);
            const o = e.collapsed;
            return e.detach(), o;
          }
          getParentUIElement(t) {
            const e = er(t);
            for (e.pop(); e.length; ) {
              const t = e.pop(),
                o = this._domToViewMapping.get(t);
              if (o && o.is('uiElement')) return o;
            }
            return null;
          }
          isDomSelectionCorrect(t) {
            return (
              this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
              this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
            );
          }
          _isDomSelectionPositionCorrect(t, e) {
            if (On(t) && Ln(t) && e < 7) return !1;
            if (this.isElement(t) && Ln(t.childNodes[e])) return !1;
            const o = this.mapDomToView(t);
            return !o || !o.is('uiElement');
          }
          _processDataFromViewText(t) {
            let e = t.data;
            if (t.getAncestors().some(t => this.preElements.includes(t.name))) return e;
            if (' ' == e.charAt(0)) {
              const o = this._getTouchingViewTextNode(t, !1);
              (!(o && this._nodeEndsWithSpace(o)) && o) || (e = ' ' + e.substr(1));
            }
            if (' ' == e.charAt(e.length - 1)) {
              const o = this._getTouchingViewTextNode(t, !0);
              (' ' != e.charAt(e.length - 2) && o && ' ' != o.data.charAt(0)) || (e = e.substr(0, e.length - 1) + ' ');
            }
            return e.replace(/ {2}/g, '  ');
          }
          _nodeEndsWithSpace(t) {
            if (t.getAncestors().some(t => this.preElements.includes(t.name))) return !1;
            const e = this._processDataFromViewText(t);
            return ' ' == e.charAt(e.length - 1);
          }
          _processDataFromDomText(t) {
            let e = t.data;
            if (nr(t, this.preElements)) return Bn(t);
            e = e.replace(/[ \n\t\r]{1,}/g, ' ');
            const o = this._getTouchingInlineDomNode(t, !1),
              i = this._getTouchingInlineDomNode(t, !0),
              n = this._checkShouldLeftTrimDomText(o),
              r = this._checkShouldRightTrimDomText(t, i);
            return (
              n && (e = e.replace(/^ /, '')),
              r && (e = e.replace(/ $/, '')),
              (e = Bn(new Text(e))),
              (e = e.replace(/ \u00A0/g, '  ')),
              (/( |\u00A0)\u00A0$/.test(e) || !i || (i.data && ' ' == i.data.charAt(0))) &&
                (e = e.replace(/\u00A0$/, ' ')),
              n && (e = e.replace(/^\u00A0/, ' ')),
              e
            );
          }
          _checkShouldLeftTrimDomText(t) {
            return !t || !!oo(t) || /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1));
          }
          _checkShouldRightTrimDomText(t, e) {
            return !e && !Ln(t);
          }
          _getTouchingViewTextNode(t, e) {
            const o = new Ji({
              startPosition: e ? Zi._createAfter(t) : Zi._createBefore(t),
              direction: e ? 'forward' : 'backward',
            });
            for (const t of o) {
              if (t.item.is('containerElement')) return null;
              if (t.item.is('br')) return null;
              if (t.item.is('textProxy')) return t.item;
            }
            return null;
          }
          _getTouchingInlineDomNode(t, e) {
            if (!t.parentNode) return null;
            const o = e ? 'nextNode' : 'previousNode',
              i = t.ownerDocument,
              n = er(t)[0],
              r = i.createTreeWalker(n, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
                acceptNode: t => (On(t) || 'BR' == t.tagName ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP),
              });
            r.currentNode = t;
            const s = r[o]();
            if (null !== s) {
              const e = (function (t, e) {
                const o = er(t),
                  i = er(e);
                let n = 0;
                for (; o[n] == i[n] && o[n]; ) n++;
                return 0 === n ? null : o[n - 1];
              })(t, s);
              if (e && !nr(t, this.blockElements, e) && !nr(s, this.blockElements, e)) return s;
            }
            return null;
          }
        }
        function nr(t, e, o) {
          let i = er(t);
          return o && (i = i.slice(i.indexOf(o) + 1)), i.some(t => t.tagName && e.includes(t.tagName.toLowerCase()));
        }
        function rr(t, e) {
          for (; t && t != Xn.document; ) e(t), (t = t.parentNode);
        }
        function sr(t, e) {
          const o = t.parentNode;
          return o && o.tagName && e.includes(o.tagName.toLowerCase());
        }
        function ar(t) {
          const e = Object.prototype.toString.apply(t);
          return '[object Window]' == e || '[object global]' == e;
        }
        var lr = zi({}, fo, {
          listenTo(t, ...e) {
            if ($n(t) || ar(t)) {
              const o = this._getProxyEmitter(t) || new cr(t);
              o.attach(...e), (t = o);
            }
            fo.listenTo.call(this, t, ...e);
          },
          stopListening(t, e, o) {
            if ($n(t) || ar(t)) {
              const e = this._getProxyEmitter(t);
              if (!e) return;
              t = e;
            }
            fo.stopListening.call(this, t, e, o), t instanceof cr && t.detach(e);
          },
          _getProxyEmitter(t) {
            return (e = this), (o = dr(t)), e[go] && e[go][o] ? e[go][o].emitter : null;
            var e, o;
          },
        });
        class cr {
          constructor(t) {
            po(this, dr(t)), (this._domNode = t);
          }
        }
        function dr(t) {
          return t['data-ck-expando'] || (t['data-ck-expando'] = co());
        }
        zi(cr.prototype, fo, {
          attach(t, e, o = {}) {
            if (this._domListeners && this._domListeners[t]) return;
            const i = this._createDomListener(t, !!o.useCapture);
            this._domNode.addEventListener(t, i, !!o.useCapture),
              this._domListeners || (this._domListeners = {}),
              (this._domListeners[t] = i);
          },
          detach(t) {
            let e;
            !this._domListeners[t] ||
              ((e = this._events[t]) && e.callbacks.length) ||
              this._domListeners[t].removeListener();
          },
          _createDomListener(t, e) {
            const o = e => {
              this.fire(t, e);
            };
            return (
              (o.removeListener = () => {
                this._domNode.removeEventListener(t, o, e), delete this._domListeners[t];
              }),
              o
            );
          },
        });
        class hr {
          constructor(t) {
            (this.view = t), (this.document = t.document), (this.isEnabled = !1);
          }
          enable() {
            this.isEnabled = !0;
          }
          disable() {
            this.isEnabled = !1;
          }
          destroy() {
            this.disable(), this.stopListening();
          }
        }
        xo(hr, lr);
        var ur = function (t) {
          return this.__data__.set(t, '__lodash_hash_undefined__'), this;
        };
        var gr = function (t) {
          return this.__data__.has(t);
        };
        function mr(t) {
          var e = -1,
            o = null == t ? 0 : t.length;
          for (this.__data__ = new kt(); ++e < o; ) this.add(t[e]);
        }
        (mr.prototype.add = mr.prototype.push = ur), (mr.prototype.has = gr);
        var fr = mr;
        var pr = function (t, e) {
          for (var o = -1, i = null == t ? 0 : t.length; ++o < i; ) if (e(t[o], o, t)) return !0;
          return !1;
        };
        var br = function (t, e) {
          return t.has(e);
        };
        var wr = function (t, e, o, i, n, r) {
          var s = 1 & o,
            a = t.length,
            l = e.length;
          if (a != l && !(s && l > a)) return !1;
          var c = r.get(t);
          if (c && r.get(e)) return c == e;
          var d = -1,
            h = !0,
            u = 2 & o ? new fr() : void 0;
          for (r.set(t, e), r.set(e, t); ++d < a; ) {
            var g = t[d],
              m = e[d];
            if (i) var f = s ? i(m, g, d, e, t, r) : i(g, m, d, t, e, r);
            if (void 0 !== f) {
              if (f) continue;
              h = !1;
              break;
            }
            if (u) {
              if (
                !pr(e, function (t, e) {
                  if (!br(u, e) && (g === t || n(g, t, o, i, r))) return u.push(e);
                })
              ) {
                h = !1;
                break;
              }
            } else if (g !== m && !n(g, m, o, i, r)) {
              h = !1;
              break;
            }
          }
          return r.delete(t), r.delete(e), h;
        };
        var kr = function (t) {
          var e = -1,
            o = Array(t.size);
          return (
            t.forEach(function (t, i) {
              o[++e] = [i, t];
            }),
            o
          );
        };
        var _r = function (t) {
            var e = -1,
              o = Array(t.size);
            return (
              t.forEach(function (t) {
                o[++e] = t;
              }),
              o
            );
          },
          vr = n ? n.prototype : void 0,
          yr = vr ? vr.valueOf : void 0;
        var xr = function (t, e, o, i, n, r, s) {
            switch (o) {
              case '[object DataView]':
                if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                (t = t.buffer), (e = e.buffer);
              case '[object ArrayBuffer]':
                return !(t.byteLength != e.byteLength || !r(new Oe(t), new Oe(e)));
              case '[object Boolean]':
              case '[object Date]':
              case '[object Number]':
                return C(+t, +e);
              case '[object Error]':
                return t.name == e.name && t.message == e.message;
              case '[object RegExp]':
              case '[object String]':
                return t == e + '';
              case '[object Map]':
                var a = kr;
              case '[object Set]':
                var l = 1 & i;
                if ((a || (a = _r), t.size != e.size && !l)) return !1;
                var c = s.get(t);
                if (c) return c == e;
                (i |= 2), s.set(t, e);
                var d = wr(a(t), a(e), i, n, r, s);
                return s.delete(t), d;
              case '[object Symbol]':
                if (yr) return yr.call(t) == yr.call(e);
            }
            return !1;
          },
          Cr = Object.prototype.hasOwnProperty;
        var Ar = function (t, e, o, i, n, r) {
            var s = 1 & o,
              a = ke(t),
              l = a.length;
            if (l != ke(e).length && !s) return !1;
            for (var c = l; c--; ) {
              var d = a[c];
              if (!(s ? d in e : Cr.call(e, d))) return !1;
            }
            var h = r.get(t);
            if (h && r.get(e)) return h == e;
            var u = !0;
            r.set(t, e), r.set(e, t);
            for (var g = s; ++c < l; ) {
              var m = t[(d = a[c])],
                f = e[d];
              if (i) var p = s ? i(f, m, d, e, t, r) : i(m, f, d, t, e, r);
              if (!(void 0 === p ? m === f || n(m, f, o, i, r) : p)) {
                u = !1;
                break;
              }
              g || (g = 'constructor' == d);
            }
            if (u && !g) {
              var b = t.constructor,
                w = e.constructor;
              b == w ||
                !('constructor' in t) ||
                !('constructor' in e) ||
                ('function' == typeof b && b instanceof b && 'function' == typeof w && w instanceof w) ||
                (u = !1);
            }
            return r.delete(t), r.delete(e), u;
          },
          Tr = Object.prototype.hasOwnProperty;
        var Sr = function (t, e, o, i, n, r) {
          var s = Vt(t),
            a = Vt(e),
            l = s ? '[object Array]' : Ie(t),
            c = a ? '[object Array]' : Ie(e),
            d = '[object Object]' == (l = '[object Arguments]' == l ? '[object Object]' : l),
            h = '[object Object]' == (c = '[object Arguments]' == c ? '[object Object]' : c),
            u = l == c;
          if (u && Object(Dt.a)(t)) {
            if (!Object(Dt.a)(e)) return !1;
            (s = !0), (d = !1);
          }
          if (u && !d) return r || (r = new yt()), s || qt(t) ? wr(t, e, o, i, n, r) : xr(t, e, l, o, i, n, r);
          if (!(1 & o)) {
            var g = d && Tr.call(t, '__wrapped__'),
              m = h && Tr.call(e, '__wrapped__');
            if (g || m) {
              var f = g ? t.value() : t,
                p = m ? e.value() : e;
              return r || (r = new yt()), n(f, p, o, i, r);
            }
          }
          return !!u && (r || (r = new yt()), Ar(t, e, o, i, n, r));
        };
        var Pr = function t(e, o, i, n, r) {
          return e === o || (null == e || null == o || (!p(e) && !p(o)) ? e != e && o != o : Sr(e, o, i, n, t, r));
        };
        var Er = function (t, e, o) {
          var i = (o = 'function' == typeof o ? o : void 0) ? o(t, e) : void 0;
          return void 0 === i ? Pr(t, e, void 0, o) : !!i;
        };
        class Mr extends hr {
          constructor(t) {
            super(t),
              (this._config = { childList: !0, characterData: !0, characterDataOldValue: !0, subtree: !0 }),
              (this.domConverter = t.domConverter),
              (this.renderer = t._renderer),
              (this._domElements = []),
              (this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this)));
          }
          flush() {
            this._onMutations(this._mutationObserver.takeRecords());
          }
          observe(t) {
            this._domElements.push(t), this.isEnabled && this._mutationObserver.observe(t, this._config);
          }
          enable() {
            super.enable();
            for (const t of this._domElements) this._mutationObserver.observe(t, this._config);
          }
          disable() {
            super.disable(), this._mutationObserver.disconnect();
          }
          destroy() {
            super.destroy(), this._mutationObserver.disconnect();
          }
          _onMutations(t) {
            if (0 === t.length) return;
            const e = this.domConverter,
              o = new Map(),
              i = new Set();
            for (const o of t)
              if ('childList' === o.type) {
                const t = e.mapDomToView(o.target);
                if (t && t.is('uiElement')) continue;
                t && !this._isBogusBrMutation(o) && i.add(t);
              }
            for (const n of t) {
              const t = e.mapDomToView(n.target);
              if ((!t || !t.is('uiElement')) && 'characterData' === n.type) {
                const t = e.findCorrespondingViewText(n.target);
                t && !i.has(t.parent)
                  ? o.set(t, { type: 'text', oldText: t.data, newText: Bn(n.target), node: t })
                  : !t && Ln(n.target) && i.add(e.mapDomToView(n.target.parentNode));
              }
            }
            const n = [];
            for (const t of o.values()) this.renderer.markToSync('text', t.node), n.push(t);
            for (const t of i) {
              const o = e.mapViewToDom(t),
                i = Array.from(t.getChildren()),
                r = Array.from(e.domChildrenToView(o, { withChildren: !1 }));
              Er(i, r, a) ||
                (this.renderer.markToSync('children', t),
                n.push({ type: 'children', oldChildren: i, newChildren: r, node: t }));
            }
            const r = t[0].target.ownerDocument.getSelection();
            let s = null;
            if (r && r.anchorNode) {
              const t = e.domPositionToView(r.anchorNode, r.anchorOffset),
                o = e.domPositionToView(r.focusNode, r.focusOffset);
              t && o && ((s = new on(t)), s.setFocus(o));
            }
            function a(t, e) {
              if (!Array.isArray(t)) return t === e || (!(!t.is('text') || !e.is('text')) && t.data === e.data);
            }
            n.length && (this.document.fire('mutations', n, s), this.view.forceRender());
          }
          _isBogusBrMutation(t) {
            let e = null;
            return (
              null === t.nextSibling &&
                0 === t.removedNodes.length &&
                1 == t.addedNodes.length &&
                (e = this.domConverter.domToView(t.addedNodes[0], { withChildren: !1 })),
              e && e.is('element', 'br')
            );
          }
        }
        class Ir {
          constructor(t, e, o) {
            (this.view = t),
              (this.document = t.document),
              (this.domEvent = e),
              (this.domTarget = e.target),
              zi(this, o);
          }
          get target() {
            return this.view.domConverter.mapDomToView(this.domTarget);
          }
          preventDefault() {
            this.domEvent.preventDefault();
          }
          stopPropagation() {
            this.domEvent.stopPropagation();
          }
        }
        class Nr extends hr {
          constructor(t) {
            super(t), (this.useCapture = !1);
          }
          observe(t) {
            ('string' == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach(e => {
              this.listenTo(
                t,
                e,
                (t, e) => {
                  this.isEnabled && this.onDomEvent(e);
                },
                { useCapture: this.useCapture }
              );
            });
          }
          fire(t, e, o) {
            this.isEnabled && this.document.fire(t, new Ir(this.view, e, o));
          }
        }
        class Rr extends Nr {
          constructor(t) {
            super(t), (this.domEventType = ['keydown', 'keyup']);
          }
          onDomEvent(t) {
            this.fire(t.type, t, {
              keyCode: t.keyCode,
              altKey: t.altKey,
              ctrlKey: t.ctrlKey || t.metaKey,
              shiftKey: t.shiftKey,
              get keystroke() {
                return pn(this);
              },
            });
          }
        }
        var Or = function () {
            return i.a.Date.now();
          },
          Vr = /^\s+|\s+$/g,
          Dr = /^[-+]0x[0-9a-f]+$/i,
          zr = /^0b[01]+$/i,
          Lr = /^0o[0-7]+$/i,
          jr = parseInt;
        var Br = function (t) {
            if ('number' == typeof t) return t;
            if (jo(t)) return NaN;
            if (z(t)) {
              var e = 'function' == typeof t.valueOf ? t.valueOf() : t;
              t = z(e) ? e + '' : e;
            }
            if ('string' != typeof t) return 0 === t ? t : +t;
            t = t.replace(Vr, '');
            var o = zr.test(t);
            return o || Lr.test(t) ? jr(t.slice(2), o ? 2 : 8) : Dr.test(t) ? NaN : +t;
          },
          Fr = Math.max,
          Hr = Math.min;
        var Wr = function (t, e, o) {
          var i,
            n,
            r,
            s,
            a,
            l,
            c = 0,
            d = !1,
            h = !1,
            u = !0;
          if ('function' != typeof t) throw new TypeError('Expected a function');
          function g(e) {
            var o = i,
              r = n;
            return (i = n = void 0), (c = e), (s = t.apply(r, o));
          }
          function m(t) {
            return (c = t), (a = setTimeout(p, e)), d ? g(t) : s;
          }
          function f(t) {
            var o = t - l;
            return void 0 === l || o >= e || o < 0 || (h && t - c >= r);
          }
          function p() {
            var t = Or();
            if (f(t)) return b(t);
            a = setTimeout(
              p,
              (function (t) {
                var o = e - (t - l);
                return h ? Hr(o, r - (t - c)) : o;
              })(t)
            );
          }
          function b(t) {
            return (a = void 0), u && i ? g(t) : ((i = n = void 0), s);
          }
          function w() {
            var t = Or(),
              o = f(t);
            if (((i = arguments), (n = this), (l = t), o)) {
              if (void 0 === a) return m(l);
              if (h) return clearTimeout(a), (a = setTimeout(p, e)), g(l);
            }
            return void 0 === a && (a = setTimeout(p, e)), s;
          }
          return (
            (e = Br(e) || 0),
            z(o) &&
              ((d = !!o.leading),
              (r = (h = 'maxWait' in o) ? Fr(Br(o.maxWait) || 0, e) : r),
              (u = 'trailing' in o ? !!o.trailing : u)),
            (w.cancel = function () {
              void 0 !== a && clearTimeout(a), (c = 0), (i = l = n = a = void 0);
            }),
            (w.flush = function () {
              return void 0 === a ? s : b(Or());
            }),
            w
          );
        };
        class Ur extends hr {
          constructor(t) {
            super(t),
              (this._fireSelectionChangeDoneDebounced = Wr(t => this.document.fire('selectionChangeDone', t), 200));
          }
          observe() {
            const t = this.document;
            t.on(
              'keydown',
              (e, o) => {
                var i;
                t.selection.isFake &&
                  ((i = o.keyCode) == fn.arrowright || i == fn.arrowleft || i == fn.arrowup || i == fn.arrowdown) &&
                  this.isEnabled &&
                  (o.preventDefault(), this._handleSelectionMove(o.keyCode));
              },
              { priority: 'lowest' }
            );
          }
          destroy() {
            super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionMove(t) {
            const e = this.document.selection,
              o = new on(e.getRanges(), { backward: e.isBackward, fake: !1 });
            (t != fn.arrowleft && t != fn.arrowup) || o.setTo(o.getFirstPosition()),
              (t != fn.arrowright && t != fn.arrowdown) || o.setTo(o.getLastPosition());
            const i = { oldSelection: e, newSelection: o, domSelection: null };
            this.document.fire('selectionChange', i), this._fireSelectionChangeDoneDebounced(i);
          }
        }
        class qr extends hr {
          constructor(t) {
            super(t),
              (this.mutationObserver = t.getObserver(Mr)),
              (this.selection = this.document.selection),
              (this.domConverter = t.domConverter),
              (this._documents = new WeakSet()),
              (this._fireSelectionChangeDoneDebounced = Wr(t => this.document.fire('selectionChangeDone', t), 200)),
              (this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3)),
              (this._loopbackCounter = 0);
          }
          observe(t) {
            const e = t.ownerDocument;
            this._documents.has(e) ||
              (this.listenTo(e, 'selectionchange', () => {
                this._handleSelectionChange(e);
              }),
              this._documents.add(e));
          }
          destroy() {
            super.destroy(),
              clearInterval(this._clearInfiniteLoopInterval),
              this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionChange(t) {
            if (!this.isEnabled) return;
            this.mutationObserver.flush();
            const e = t.defaultView.getSelection(),
              o = this.domConverter.domSelectionToView(e);
            if (0 != o.rangeCount) {
              if (
                ((this.view.hasDomSelection = !0),
                !(
                  (this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(e)) ||
                  ++this._loopbackCounter > 60
                ))
              )
                if (this.selection.isSimilar(o)) this.view.forceRender();
                else {
                  const t = { oldSelection: this.selection, newSelection: o, domSelection: e };
                  this.document.fire('selectionChange', t), this._fireSelectionChangeDoneDebounced(t);
                }
            } else this.view.hasDomSelection = !1;
          }
          _clearInfiniteLoop() {
            this._loopbackCounter = 0;
          }
        }
        class Gr extends Nr {
          constructor(t) {
            super(t), (this.domEventType = ['focus', 'blur']), (this.useCapture = !0);
            const e = this.document;
            e.on('focus', () => {
              (e.isFocused = !0), (this._renderTimeoutId = setTimeout(() => t.forceRender(), 50));
            }),
              e.on('blur', (o, i) => {
                const n = e.selection.editableElement;
                (null !== n && n !== i.target) || ((e.isFocused = !1), t.forceRender());
              });
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
          destroy() {
            this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
          }
        }
        class Yr extends Nr {
          constructor(t) {
            super(t), (this.domEventType = ['compositionstart', 'compositionupdate', 'compositionend']);
            const e = this.document;
            e.on('compositionstart', () => {
              e.isComposing = !0;
            }),
              e.on('compositionend', () => {
                e.isComposing = !1;
              });
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        class $r extends Nr {
          constructor(t) {
            super(t), (this.domEventType = ['beforeinput']);
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        function Qr(t) {
          return '[object Range]' == Object.prototype.toString.apply(t);
        }
        function Kr(t) {
          const e = t.ownerDocument.defaultView.getComputedStyle(t);
          return {
            top: parseInt(e.borderTopWidth, 10),
            right: parseInt(e.borderRightWidth, 10),
            bottom: parseInt(e.borderBottomWidth, 10),
            left: parseInt(e.borderLeftWidth, 10),
          };
        }
        const Jr = ['top', 'right', 'bottom', 'left', 'width', 'height'];
        class Zr {
          constructor(t) {
            const e = Qr(t);
            if (
              (Object.defineProperty(this, '_source', { value: t._source || t, writable: !0, enumerable: !1 }),
              oo(t) || e)
            )
              Xr(this, e ? Zr.getDomRangeRects(t)[0] : t.getBoundingClientRect());
            else if (ar(t)) {
              const { innerWidth: e, innerHeight: o } = t;
              Xr(this, { top: 0, right: e, bottom: o, left: 0, width: e, height: o });
            } else Xr(this, t);
          }
          clone() {
            return new Zr(this);
          }
          moveTo(t, e) {
            return (
              (this.top = e), (this.right = t + this.width), (this.bottom = e + this.height), (this.left = t), this
            );
          }
          moveBy(t, e) {
            return (this.top += e), (this.right += t), (this.left += t), (this.bottom += e), this;
          }
          getIntersection(t) {
            const e = {
              top: Math.max(this.top, t.top),
              right: Math.min(this.right, t.right),
              bottom: Math.min(this.bottom, t.bottom),
              left: Math.max(this.left, t.left),
            };
            return (
              (e.width = e.right - e.left),
              (e.height = e.bottom - e.top),
              e.width < 0 || e.height < 0 ? null : new Zr(e)
            );
          }
          getIntersectionArea(t) {
            const e = this.getIntersection(t);
            return e ? e.getArea() : 0;
          }
          getArea() {
            return this.width * this.height;
          }
          getVisible() {
            const t = this._source;
            let e = this.clone();
            if (!ts(t)) {
              let o = t.parentNode || t.commonAncestorContainer;
              for (; o && !ts(o); ) {
                const t = new Zr(o),
                  i = e.getIntersection(t);
                if (!i) return null;
                i.getArea() < e.getArea() && (e = i), (o = o.parentNode);
              }
            }
            return e;
          }
          isEqual(t) {
            for (const e of Jr) if (this[e] !== t[e]) return !1;
            return !0;
          }
          contains(t) {
            const e = this.getIntersection(t);
            return !(!e || !e.isEqual(t));
          }
          excludeScrollbarsAndBorders() {
            const t = this._source;
            let e, o, i;
            if (ar(t))
              (e = t.innerWidth - t.document.documentElement.clientWidth),
                (o = t.innerHeight - t.document.documentElement.clientHeight),
                (i = t.getComputedStyle(t.document.documentElement).direction);
            else {
              const n = Kr(this._source);
              (e = t.offsetWidth - t.clientWidth - n.left - n.right),
                (o = t.offsetHeight - t.clientHeight - n.top - n.bottom),
                (i = t.ownerDocument.defaultView.getComputedStyle(t).direction),
                (this.left += n.left),
                (this.top += n.top),
                (this.right -= n.right),
                (this.bottom -= n.bottom),
                (this.width = this.right - this.left),
                (this.height = this.bottom - this.top);
            }
            return (
              (this.width -= e),
              'ltr' === i ? (this.right -= e) : (this.left += e),
              (this.height -= o),
              (this.bottom -= o),
              this
            );
          }
          static getDomRangeRects(t) {
            const e = [],
              o = Array.from(t.getClientRects());
            if (o.length) for (const t of o) e.push(new Zr(t));
            else {
              let o = t.startContainer;
              On(o) && (o = o.parentNode);
              const i = new Zr(o.getBoundingClientRect());
              (i.right = i.left), (i.width = 0), e.push(i);
            }
            return e;
          }
        }
        function Xr(t, e) {
          for (const o of Jr) t[o] = e[o];
        }
        function ts(t) {
          return !!oo(t) && t === t.ownerDocument.body;
        }
        function es({ target: t, viewportOffset: e = 0 }) {
          const o = ls(t);
          let i = o,
            n = null;
          for (; i; ) {
            let r;
            (r = cs(i == o ? t : n)), is(r, () => ds(t, i));
            const s = ds(t, i);
            if ((os(i, s, e), i.parent != i)) {
              if (((n = i.frameElement), (i = i.parent), !n)) return;
            } else i = null;
          }
        }
        function os(t, e, o) {
          const i = e.clone().moveBy(0, o),
            n = e.clone().moveBy(0, -o),
            r = new Zr(t).excludeScrollbarsAndBorders();
          if (![n, i].every(t => r.contains(t))) {
            let { scrollX: s, scrollY: a } = t;
            rs(n, r) ? (a -= r.top - e.top + o) : ns(i, r) && (a += e.bottom - r.bottom + o),
              ss(e, r) ? (s -= r.left - e.left + o) : as(e, r) && (s += e.right - r.right + o),
              t.scrollTo(s, a);
          }
        }
        function is(t, e) {
          const o = ls(t);
          let i, n;
          for (; t != o.document.body; )
            (n = e()),
              (i = new Zr(t).excludeScrollbarsAndBorders()),
              i.contains(n) ||
                (rs(n, i) ? (t.scrollTop -= i.top - n.top) : ns(n, i) && (t.scrollTop += n.bottom - i.bottom),
                ss(n, i) ? (t.scrollLeft -= i.left - n.left) : as(n, i) && (t.scrollLeft += n.right - i.right)),
              (t = t.parentNode);
        }
        function ns(t, e) {
          return t.bottom > e.bottom;
        }
        function rs(t, e) {
          return t.top < e.top;
        }
        function ss(t, e) {
          return t.left < e.left;
        }
        function as(t, e) {
          return t.right > e.right;
        }
        function ls(t) {
          return Qr(t) ? t.startContainer.ownerDocument.defaultView : t.ownerDocument.defaultView;
        }
        function cs(t) {
          if (Qr(t)) {
            let e = t.commonAncestorContainer;
            return On(e) && (e = e.parentNode), e;
          }
          return t.parentNode;
        }
        function ds(t, e) {
          const o = ls(t),
            i = new Zr(t);
          if (o === e) return i;
          {
            let t = o;
            for (; t != e; ) {
              const e = t.frameElement,
                o = new Zr(e).excludeScrollbarsAndBorders();
              i.moveBy(o.left, o.top), (t = t.parent);
            }
          }
          return i;
        }
        Object.assign(
          {},
          {
            scrollViewportToShowTarget: es,
            scrollAncestorsToShowTarget: function (t) {
              is(cs(t), () => new Zr(t));
            },
          }
        );
        class hs {
          constructor(t) {
            (this.document = new rn(t)),
              (this.domConverter = new ir(this.document)),
              (this.domRoots = new Map()),
              this.set('isRenderingInProgress', !1),
              this.set('hasDomSelection', !1),
              (this._renderer = new Qn(this.domConverter, this.document.selection)),
              this._renderer.bind('isFocused').to(this.document),
              (this._initialDomRootAttributes = new WeakMap()),
              (this._observers = new Map()),
              (this._ongoingChange = !1),
              (this._postFixersInProgress = !1),
              (this._renderingDisabled = !1),
              (this._hasChangedSinceTheLastRendering = !1),
              (this._writer = new Cn(this.document)),
              this.addObserver(Mr),
              this.addObserver(qr),
              this.addObserver(Gr),
              this.addObserver(Rr),
              this.addObserver(Ur),
              this.addObserver(Yr),
              un.isAndroid && this.addObserver($r),
              this.document.on('keydown', Fn),
              vn(this),
              this.on('render', () => {
                this._render(), this.document.fire('layoutChanged'), (this._hasChangedSinceTheLastRendering = !1);
              }),
              this.listenTo(this.document.selection, 'change', () => {
                this._hasChangedSinceTheLastRendering = !0;
              });
          }
          attachDomRoot(t, e = 'main') {
            const o = this.document.getRoot(e);
            o._name = t.tagName.toLowerCase();
            const i = {};
            for (const { name: e, value: n } of Array.from(t.attributes))
              (i[e] = n), 'class' === e ? this._writer.addClass(n.split(' '), o) : this._writer.setAttribute(e, n, o);
            this._initialDomRootAttributes.set(t, i);
            const n = () => {
              this._writer.setAttribute('contenteditable', !o.isReadOnly, o),
                o.isReadOnly ? this._writer.addClass('ck-read-only', o) : this._writer.removeClass('ck-read-only', o);
            };
            n(),
              this.domRoots.set(e, t),
              this.domConverter.bindElements(t, o),
              this._renderer.markToSync('children', o),
              this._renderer.markToSync('attributes', o),
              this._renderer.domDocuments.add(t.ownerDocument),
              o.on('change:children', (t, e) => this._renderer.markToSync('children', e)),
              o.on('change:attributes', (t, e) => this._renderer.markToSync('attributes', e)),
              o.on('change:text', (t, e) => this._renderer.markToSync('text', e)),
              o.on('change:isReadOnly', () => this.change(n)),
              o.on('change', () => {
                this._hasChangedSinceTheLastRendering = !0;
              });
            for (const o of this._observers.values()) o.observe(t, e);
          }
          detachDomRoot(t) {
            const e = this.domRoots.get(t);
            Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t));
            const o = this._initialDomRootAttributes.get(e);
            for (const t in o) e.setAttribute(t, o[t]);
            this.domRoots.delete(t), this.domConverter.unbindDomElement(e);
          }
          getDomRoot(t = 'main') {
            return this.domRoots.get(t);
          }
          addObserver(t) {
            let e = this._observers.get(t);
            if (e) return e;
            (e = new t(this)), this._observers.set(t, e);
            for (const [t, o] of this.domRoots) e.observe(o, t);
            return e.enable(), e;
          }
          getObserver(t) {
            return this._observers.get(t);
          }
          disableObservers() {
            for (const t of this._observers.values()) t.disable();
          }
          enableObservers() {
            for (const t of this._observers.values()) t.enable();
          }
          scrollToTheSelection() {
            const t = this.document.selection.getFirstRange();
            t && es({ target: this.domConverter.viewRangeToDom(t), viewportOffset: 20 });
          }
          focus() {
            if (!this.document.isFocused) {
              const t = this.document.selection.editableElement;
              t && (this.domConverter.focus(t), this.forceRender());
            }
          }
          change(t) {
            if (this.isRenderingInProgress || this._postFixersInProgress)
              throw new uo.b(
                'cannot-change-view-tree: Attempting to make changes to the view when it is in an incorrect state: rendering or post-fixers are in progress. This may cause some unexpected behavior and inconsistency between the DOM and the view.',
                this
              );
            try {
              if (this._ongoingChange) return t(this._writer);
              this._ongoingChange = !0;
              const e = t(this._writer);
              return (
                (this._ongoingChange = !1),
                !this._renderingDisabled &&
                  this._hasChangedSinceTheLastRendering &&
                  ((this._postFixersInProgress = !0),
                  this.document._callPostFixers(this._writer),
                  (this._postFixersInProgress = !1),
                  this.fire('render')),
                e
              );
            } catch (t) {
              uo.b.rethrowUnexpectedError(t, this);
            }
          }
          forceRender() {
            (this._hasChangedSinceTheLastRendering = !0), this.change(() => {});
          }
          destroy() {
            for (const t of this._observers.values()) t.destroy();
            this.document.destroy(), this.stopListening();
          }
          createPositionAt(t, e) {
            return Zi._createAt(t, e);
          }
          createPositionAfter(t) {
            return Zi._createAfter(t);
          }
          createPositionBefore(t) {
            return Zi._createBefore(t);
          }
          createRange(t, e) {
            return new Xi(t, e);
          }
          createRangeOn(t) {
            return Xi._createOn(t);
          }
          createRangeIn(t) {
            return Xi._createIn(t);
          }
          createSelection(t, e, o) {
            return new on(t, e, o);
          }
          _disableRendering(t) {
            (this._renderingDisabled = t), 0 == t && this.change(() => {});
          }
          _render() {
            (this.isRenderingInProgress = !0),
              this.disableObservers(),
              this._renderer.render(),
              this.enableObservers(),
              (this.isRenderingInProgress = !1);
          }
        }
        xo(hs, Hi);
        class us {
          constructor(t) {
            (this.parent = null), (this._attrs = Do(t));
          }
          get index() {
            let t;
            if (!this.parent) return null;
            if (null === (t = this.parent.getChildIndex(this)))
              throw new uo.b("model-node-not-found-in-parent: The node's parent does not contain this node.", this);
            return t;
          }
          get startOffset() {
            let t;
            if (!this.parent) return null;
            if (null === (t = this.parent.getChildStartOffset(this)))
              throw new uo.b("model-node-not-found-in-parent: The node's parent does not contain this node.", this);
            return t;
          }
          get offsetSize() {
            return 1;
          }
          get endOffset() {
            return this.parent ? this.startOffset + this.offsetSize : null;
          }
          get nextSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t + 1)) || null;
          }
          get previousSibling() {
            const t = this.index;
            return (null !== t && this.parent.getChild(t - 1)) || null;
          }
          get root() {
            let t = this;
            for (; t.parent; ) t = t.parent;
            return t;
          }
          isAttached() {
            return this.root.is('rootElement');
          }
          getPath() {
            const t = [];
            let e = this;
            for (; e.parent; ) t.unshift(e.startOffset), (e = e.parent);
            return t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let o = t.includeSelf ? this : this.parent;
            for (; o; ) e[t.parentFirst ? 'push' : 'unshift'](o), (o = o.parent);
            return e;
          }
          getCommonAncestor(t, e = {}) {
            const o = this.getAncestors(e),
              i = t.getAncestors(e);
            let n = 0;
            for (; o[n] == i[n] && o[n]; ) n++;
            return 0 === n ? null : o[n - 1];
          }
          isBefore(t) {
            if (this == t) return !1;
            if (this.root !== t.root) return !1;
            const e = this.getPath(),
              o = t.getPath(),
              i = Io(e, o);
            switch (i) {
              case 'prefix':
                return !0;
              case 'extension':
                return !1;
              default:
                return e[i] < o[i];
            }
          }
          isAfter(t) {
            return this != t && this.root === t.root && !this.isBefore(t);
          }
          hasAttribute(t) {
            return this._attrs.has(t);
          }
          getAttribute(t) {
            return this._attrs.get(t);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          toJSON() {
            const t = {};
            return (
              this._attrs.size && (t.attributes = Array.from(this._attrs).reduce((t, e) => ((t[e[0]] = e[1]), t), {})),
              t
            );
          }
          is(t) {
            return 'node' === t || 'model:node' === t;
          }
          _clone() {
            return new us(this._attrs);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _setAttribute(t, e) {
            this._attrs.set(t, e);
          }
          _setAttributesTo(t) {
            this._attrs = Do(t);
          }
          _removeAttribute(t) {
            return this._attrs.delete(t);
          }
          _clearAttributes() {
            this._attrs.clear();
          }
        }
        class gs extends us {
          constructor(t, e) {
            super(e), (this._data = t || '');
          }
          get offsetSize() {
            return this.data.length;
          }
          get data() {
            return this._data;
          }
          is(t) {
            return 'text' === t || 'model:text' === t || 'node' === t || 'model:node' === t;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.data = this.data), t;
          }
          _clone() {
            return new gs(this.data, this.getAttributes());
          }
          static fromJSON(t) {
            return new gs(t.data, t.attributes);
          }
        }
        class ms {
          constructor(t, e, o) {
            if (((this.textNode = t), e < 0 || e > t.offsetSize))
              throw new uo.b('model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.', this);
            if (o < 0 || e + o > t.offsetSize)
              throw new uo.b('model-textproxy-wrong-length: Given length value is incorrect.', this);
            (this.data = t.data.substring(e, e + o)), (this.offsetInText = e);
          }
          get startOffset() {
            return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null;
          }
          get offsetSize() {
            return this.data.length;
          }
          get endOffset() {
            return null !== this.startOffset ? this.startOffset + this.offsetSize : null;
          }
          get isPartial() {
            return this.offsetSize !== this.textNode.offsetSize;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          is(t) {
            return 'textProxy' === t || 'model:textProxy' === t;
          }
          getPath() {
            const t = this.textNode.getPath();
            return t.length > 0 && (t[t.length - 1] += this.offsetInText), t;
          }
          getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
            const e = [];
            let o = t.includeSelf ? this : this.parent;
            for (; o; ) e[t.parentFirst ? 'push' : 'unshift'](o), (o = o.parent);
            return e;
          }
          hasAttribute(t) {
            return this.textNode.hasAttribute(t);
          }
          getAttribute(t) {
            return this.textNode.getAttribute(t);
          }
          getAttributes() {
            return this.textNode.getAttributes();
          }
          getAttributeKeys() {
            return this.textNode.getAttributeKeys();
          }
        }
        class fs {
          constructor(t) {
            (this._nodes = []), t && this._insertNodes(0, t);
          }
          [Symbol.iterator]() {
            return this._nodes[Symbol.iterator]();
          }
          get length() {
            return this._nodes.length;
          }
          get maxOffset() {
            return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
          }
          getNode(t) {
            return this._nodes[t] || null;
          }
          getNodeIndex(t) {
            const e = this._nodes.indexOf(t);
            return -1 == e ? null : e;
          }
          getNodeStartOffset(t) {
            const e = this.getNodeIndex(t);
            return null === e ? null : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
          }
          indexToOffset(t) {
            if (t == this._nodes.length) return this.maxOffset;
            const e = this._nodes[t];
            if (!e)
              throw new uo.b('model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.', this);
            return this.getNodeStartOffset(e);
          }
          offsetToIndex(t) {
            let e = 0;
            for (const o of this._nodes) {
              if (t >= e && t < e + o.offsetSize) return this.getNodeIndex(o);
              e += o.offsetSize;
            }
            if (e != t)
              throw new uo.b(
                'model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.',
                this,
                { offset: t, nodeList: this }
              );
            return this.length;
          }
          _insertNodes(t, e) {
            for (const t of e)
              if (!(t instanceof us))
                throw new uo.b(
                  'model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.',
                  this
                );
            this._nodes.splice(t, 0, ...e);
          }
          _removeNodes(t, e = 1) {
            return this._nodes.splice(t, e);
          }
          toJSON() {
            return this._nodes.map(t => t.toJSON());
          }
        }
        class ps extends us {
          constructor(t, e, o) {
            super(e), (this.name = t), (this._children = new fs()), o && this._insertChild(0, o);
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          is(t, e = null) {
            return e
              ? e === this.name && ('element' === t || 'model:element' === t)
              : 'element' === t ||
                  'model:element' === t ||
                  t === this.name ||
                  t === 'model:' + this.name ||
                  'node' === t ||
                  'model:node' === t;
          }
          getChild(t) {
            return this._children.getNode(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t) {
            return this._children.getNodeIndex(t);
          }
          getChildStartOffset(t) {
            return this._children.getNodeStartOffset(t);
          }
          offsetToIndex(t) {
            return this._children.offsetToIndex(t);
          }
          getNodeByPath(t) {
            let e = this;
            for (const o of t) e = e.getChild(e.offsetToIndex(o));
            return e;
          }
          toJSON() {
            const t = super.toJSON();
            if (((t.name = this.name), this._children.length > 0)) {
              t.children = [];
              for (const e of this._children) t.children.push(e.toJSON());
            }
            return t;
          }
          _clone(t = !1) {
            const e = t ? Array.from(this._children).map(t => t._clone(!0)) : null;
            return new ps(this.name, this.getAttributes(), e);
          }
          _appendChild(t) {
            this._insertChild(this.childCount, t);
          }
          _insertChild(t, e) {
            const o = (function (t) {
              if ('string' == typeof t) return [new gs(t)];
              yo(t) || (t = [t]);
              return Array.from(t).map(t =>
                'string' == typeof t ? new gs(t) : t instanceof ms ? new gs(t.data, t.getAttributes()) : t
              );
            })(e);
            for (const t of o) null !== t.parent && t._remove(), (t.parent = this);
            this._children._insertNodes(t, o);
          }
          _removeChildren(t, e = 1) {
            const o = this._children._removeNodes(t, e);
            for (const t of o) t.parent = null;
            return o;
          }
          static fromJSON(t) {
            let e = null;
            if (t.children) {
              e = [];
              for (const o of t.children) o.name ? e.push(ps.fromJSON(o)) : e.push(gs.fromJSON(o));
            }
            return new ps(t.name, t.attributes, e);
          }
        }
        class bs {
          constructor(t = {}) {
            if (!t.boundaries && !t.startPosition)
              throw new uo.b(
                'model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.',
                null
              );
            const e = t.direction || 'forward';
            if ('forward' != e && 'backward' != e)
              throw new uo.b(
                'model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',
                t,
                { direction: e }
              );
            (this.direction = e),
              (this.boundaries = t.boundaries || null),
              t.startPosition
                ? (this.position = t.startPosition.clone())
                : (this.position = ks._createAt(this.boundaries['backward' == this.direction ? 'end' : 'start'])),
              (this.position.stickiness = 'toNone'),
              (this.singleCharacters = !!t.singleCharacters),
              (this.shallow = !!t.shallow),
              (this.ignoreElementEnd = !!t.ignoreElementEnd),
              (this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null),
              (this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null),
              (this._visitedParent = this.position.parent);
          }
          [Symbol.iterator]() {
            return this;
          }
          skip(t) {
            let e, o, i, n;
            do {
              (i = this.position), (n = this._visitedParent), ({ done: e, value: o } = this.next());
            } while (!e && t(o));
            e || ((this.position = i), (this._visitedParent = n));
          }
          next() {
            return 'forward' == this.direction ? this._next() : this._previous();
          }
          _next() {
            const t = this.position,
              e = this.position.clone(),
              o = this._visitedParent;
            if (null === o.parent && e.offset === o.maxOffset) return { done: !0 };
            if (o === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return { done: !0 };
            const i = e.parent,
              n = _s(e, i),
              r = n || vs(e, i, n);
            if (r instanceof ps)
              return (
                this.shallow ? e.offset++ : (e.path.push(0), (this._visitedParent = r)),
                (this.position = e),
                ws('elementStart', r, t, e, 1)
              );
            if (r instanceof gs) {
              let i;
              if (this.singleCharacters) i = 1;
              else {
                let t = r.endOffset;
                this._boundaryEndParent == o && this.boundaries.end.offset < t && (t = this.boundaries.end.offset),
                  (i = t - e.offset);
              }
              const n = e.offset - r.startOffset,
                s = new ms(r, n, i);
              return (e.offset += i), (this.position = e), ws('text', s, t, e, i);
            }
            return (
              e.path.pop(),
              e.offset++,
              (this.position = e),
              (this._visitedParent = o.parent),
              this.ignoreElementEnd ? this._next() : ws('elementEnd', o, t, e)
            );
          }
          _previous() {
            const t = this.position,
              e = this.position.clone(),
              o = this._visitedParent;
            if (null === o.parent && 0 === e.offset) return { done: !0 };
            if (o == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return { done: !0 };
            const i = e.parent,
              n = _s(e, i),
              r = n || ys(e, i, n);
            if (r instanceof ps)
              return (
                e.offset--,
                this.shallow
                  ? ((this.position = e), ws('elementStart', r, t, e, 1))
                  : (e.path.push(r.maxOffset),
                    (this.position = e),
                    (this._visitedParent = r),
                    this.ignoreElementEnd ? this._previous() : ws('elementEnd', r, t, e))
              );
            if (r instanceof gs) {
              let i;
              if (this.singleCharacters) i = 1;
              else {
                let t = r.startOffset;
                this._boundaryStartParent == o &&
                  this.boundaries.start.offset > t &&
                  (t = this.boundaries.start.offset),
                  (i = e.offset - t);
              }
              const n = e.offset - r.startOffset,
                s = new ms(r, n - i, i);
              return (e.offset -= i), (this.position = e), ws('text', s, t, e, i);
            }
            return e.path.pop(), (this.position = e), (this._visitedParent = o.parent), ws('elementStart', o, t, e, 1);
          }
        }
        function ws(t, e, o, i, n) {
          return { done: !1, value: { type: t, item: e, previousPosition: o, nextPosition: i, length: n } };
        }
        class ks {
          constructor(t, e, o = 'toNone') {
            if (!t.is('element') && !t.is('documentFragment'))
              throw new uo.b('model-position-root-invalid: Position root invalid.', t);
            if (!(e instanceof Array) || 0 === e.length)
              throw new uo.b(
                'model-position-path-incorrect-format: Position path must be an array with at least one item.',
                t,
                { path: e }
              );
            t.is('rootElement') ? (e = e.slice()) : ((e = [...t.getPath(), ...e]), (t = t.root)),
              (this.root = t),
              (this.path = e),
              (this.stickiness = o);
          }
          get offset() {
            return this.path[this.path.length - 1];
          }
          set offset(t) {
            this.path[this.path.length - 1] = t;
          }
          get parent() {
            let t = this.root;
            for (let e = 0; e < this.path.length - 1; e++)
              if (((t = t.getChild(t.offsetToIndex(this.path[e]))), !t))
                throw new uo.b("model-position-path-incorrect: The position's path is incorrect.", this, {
                  position: this,
                });
            if (t.is('text'))
              throw new uo.b("model-position-path-incorrect: The position's path is incorrect.", this, {
                position: this,
              });
            return t;
          }
          get index() {
            return this.parent.offsetToIndex(this.offset);
          }
          get textNode() {
            return _s(this, this.parent);
          }
          get nodeAfter() {
            const t = this.parent;
            return vs(this, t, _s(this, t));
          }
          get nodeBefore() {
            const t = this.parent;
            return ys(this, t, _s(this, t));
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            return this.offset == this.parent.maxOffset;
          }
          compareWith(t) {
            if (this.root != t.root) return 'different';
            const e = Io(this.path, t.path);
            switch (e) {
              case 'same':
                return 'same';
              case 'prefix':
                return 'before';
              case 'extension':
                return 'after';
              default:
                return this.path[e] < t.path[e] ? 'before' : 'after';
            }
          }
          getLastMatchingPosition(t, e = {}) {
            e.startPosition = this;
            const o = new bs(e);
            return o.skip(t), o.position;
          }
          getParentPath() {
            return this.path.slice(0, -1);
          }
          getAncestors() {
            const t = this.parent;
            return t.is('documentFragment') ? [t] : t.getAncestors({ includeSelf: !0 });
          }
          getCommonPath(t) {
            if (this.root != t.root) return [];
            const e = Io(this.path, t.path),
              o = 'string' == typeof e ? Math.min(this.path.length, t.path.length) : e;
            return this.path.slice(0, o);
          }
          getCommonAncestor(t) {
            const e = this.getAncestors(),
              o = t.getAncestors();
            let i = 0;
            for (; e[i] == o[i] && e[i]; ) i++;
            return 0 === i ? null : e[i - 1];
          }
          getShiftedBy(t) {
            const e = this.clone(),
              o = e.offset + t;
            return (e.offset = o < 0 ? 0 : o), e;
          }
          isAfter(t) {
            return 'after' == this.compareWith(t);
          }
          isBefore(t) {
            return 'before' == this.compareWith(t);
          }
          isEqual(t) {
            return 'same' == this.compareWith(t);
          }
          isTouching(t) {
            let e = null,
              o = null;
            switch (this.compareWith(t)) {
              case 'same':
                return !0;
              case 'before':
                (e = ks._createAt(this)), (o = ks._createAt(t));
                break;
              case 'after':
                (e = ks._createAt(t)), (o = ks._createAt(this));
                break;
              default:
                return !1;
            }
            let i = e.parent;
            for (; e.path.length + o.path.length; ) {
              if (e.isEqual(o)) return !0;
              if (e.path.length > o.path.length) {
                if (e.offset !== i.maxOffset) return !1;
                (e.path = e.path.slice(0, -1)), (i = i.parent), e.offset++;
              } else {
                if (0 !== o.offset) return !1;
                o.path = o.path.slice(0, -1);
              }
            }
          }
          is(t) {
            return 'position' === t || 'model:position' === t;
          }
          hasSameParentAs(t) {
            if (this.root !== t.root) return !1;
            return 'same' == Io(this.getParentPath(), t.getParentPath());
          }
          getTransformedByOperation(t) {
            let e;
            switch (t.type) {
              case 'insert':
                e = this._getTransformedByInsertOperation(t);
                break;
              case 'move':
              case 'remove':
              case 'reinsert':
                e = this._getTransformedByMoveOperation(t);
                break;
              case 'split':
                e = this._getTransformedBySplitOperation(t);
                break;
              case 'merge':
                e = this._getTransformedByMergeOperation(t);
                break;
              default:
                e = ks._createAt(this);
            }
            return e;
          }
          _getTransformedByInsertOperation(t) {
            return this._getTransformedByInsertion(t.position, t.howMany);
          }
          _getTransformedByMoveOperation(t) {
            return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany);
          }
          _getTransformedBySplitOperation(t) {
            const e = t.movedRange;
            return e.containsPosition(this) || (e.start.isEqual(this) && 'toNext' == this.stickiness)
              ? this._getCombined(t.splitPosition, t.moveTargetPosition)
              : t.graveyardPosition
              ? this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
              : this._getTransformedByInsertion(t.insertionPosition, 1);
          }
          _getTransformedByMergeOperation(t) {
            const e = t.movedRange;
            let o;
            return (
              e.containsPosition(this) || e.start.isEqual(this)
                ? ((o = this._getCombined(t.sourcePosition, t.targetPosition)),
                  t.sourcePosition.isBefore(t.targetPosition) &&
                    (o = o._getTransformedByDeletion(t.deletionPosition, 1)))
                : (o = this.isEqual(t.deletionPosition)
                    ? ks._createAt(t.deletionPosition)
                    : this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)),
              o
            );
          }
          _getTransformedByDeletion(t, e) {
            const o = ks._createAt(this);
            if (this.root != t.root) return o;
            if ('same' == Io(t.getParentPath(), this.getParentPath())) {
              if (t.offset < this.offset) {
                if (t.offset + e > this.offset) return null;
                o.offset -= e;
              }
            } else if ('prefix' == Io(t.getParentPath(), this.getParentPath())) {
              const i = t.path.length - 1;
              if (t.offset <= this.path[i]) {
                if (t.offset + e > this.path[i]) return null;
                o.path[i] -= e;
              }
            }
            return o;
          }
          _getTransformedByInsertion(t, e) {
            const o = ks._createAt(this);
            if (this.root != t.root) return o;
            if ('same' == Io(t.getParentPath(), this.getParentPath()))
              (t.offset < this.offset || (t.offset == this.offset && 'toPrevious' != this.stickiness)) &&
                (o.offset += e);
            else if ('prefix' == Io(t.getParentPath(), this.getParentPath())) {
              const i = t.path.length - 1;
              t.offset <= this.path[i] && (o.path[i] += e);
            }
            return o;
          }
          _getTransformedByMove(t, e, o) {
            if (((e = e._getTransformedByDeletion(t, o)), t.isEqual(e))) return ks._createAt(this);
            const i = this._getTransformedByDeletion(t, o);
            return null === i ||
              (t.isEqual(this) && 'toNext' == this.stickiness) ||
              (t.getShiftedBy(o).isEqual(this) && 'toPrevious' == this.stickiness)
              ? this._getCombined(t, e)
              : i._getTransformedByInsertion(e, o);
          }
          _getCombined(t, e) {
            const o = t.path.length - 1,
              i = ks._createAt(e);
            return (
              (i.stickiness = this.stickiness),
              (i.offset = i.offset + this.path[o] - t.offset),
              (i.path = [...i.path, ...this.path.slice(o + 1)]),
              i
            );
          }
          toJSON() {
            return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
          }
          clone() {
            return new this.constructor(this.root, this.path, this.stickiness);
          }
          static _createAt(t, e, o = 'toNone') {
            if (t instanceof ks) return new ks(t.root, t.path, t.stickiness);
            {
              const i = t;
              if ('end' == e) e = i.maxOffset;
              else {
                if ('before' == e) return this._createBefore(i, o);
                if ('after' == e) return this._createAfter(i, o);
                if (0 !== e && !e)
                  throw new uo.b(
                    'model-createPositionAt-offset-required: Model#createPositionAt() requires the offset when the first parameter is a model item.',
                    [this, t]
                  );
              }
              if (!i.is('element') && !i.is('documentFragment'))
                throw new uo.b(
                  'model-position-parent-incorrect: Position parent have to be a element or document fragment.',
                  [this, t]
                );
              const n = i.getPath();
              return n.push(e), new this(i.root, n, o);
            }
          }
          static _createAfter(t, e) {
            if (!t.parent)
              throw new uo.b('model-position-after-root: You cannot make a position after root.', [this, t], {
                root: t,
              });
            return this._createAt(t.parent, t.endOffset, e);
          }
          static _createBefore(t, e) {
            if (!t.parent)
              throw new uo.b('model-position-before-root: You cannot make a position before root.', t, { root: t });
            return this._createAt(t.parent, t.startOffset, e);
          }
          static fromJSON(t, e) {
            if ('$graveyard' === t.root) {
              const o = new ks(e.graveyard, t.path);
              return (o.stickiness = t.stickiness), o;
            }
            if (!e.getRoot(t.root))
              throw new uo.b(
                'model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',
                e,
                { rootName: t.root }
              );
            return new ks(e.getRoot(t.root), t.path, t.stickiness);
          }
        }
        function _s(t, e) {
          const o = e.getChild(e.offsetToIndex(t.offset));
          return o && o.is('text') && o.startOffset < t.offset ? o : null;
        }
        function vs(t, e, o) {
          return null !== o ? null : e.getChild(e.offsetToIndex(t.offset));
        }
        function ys(t, e, o) {
          return null !== o ? null : e.getChild(e.offsetToIndex(t.offset) - 1);
        }
        class xs {
          constructor(t, e = null) {
            (this.start = ks._createAt(t)),
              (this.end = e ? ks._createAt(e) : ks._createAt(t)),
              (this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext'),
              (this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious');
          }
          *[Symbol.iterator]() {
            yield* new bs({ boundaries: this, ignoreElementEnd: !0 });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return 'same' == Io(this.start.getParentPath(), this.end.getParentPath());
          }
          get root() {
            return this.start.root;
          }
          containsPosition(t) {
            return t.isAfter(this.start) && t.isBefore(this.end);
          }
          containsRange(t, e = !1) {
            t.isCollapsed && (e = !1);
            const o = this.containsPosition(t.start) || (e && this.start.isEqual(t.start)),
              i = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
            return o && i;
          }
          containsItem(t) {
            const e = ks._createBefore(t);
            return this.containsPosition(e) || this.start.isEqual(e);
          }
          is(t) {
            return 'range' === t || 'model:range' === t;
          }
          isEqual(t) {
            return this.start.isEqual(t.start) && this.end.isEqual(t.end);
          }
          isIntersecting(t) {
            return this.start.isBefore(t.end) && this.end.isAfter(t.start);
          }
          getDifference(t) {
            const e = [];
            return (
              this.isIntersecting(t)
                ? (this.containsPosition(t.start) && e.push(new xs(this.start, t.start)),
                  this.containsPosition(t.end) && e.push(new xs(t.end, this.end)))
                : e.push(new xs(this.start, this.end)),
              e
            );
          }
          getIntersection(t) {
            if (this.isIntersecting(t)) {
              let e = this.start,
                o = this.end;
              return (
                this.containsPosition(t.start) && (e = t.start),
                this.containsPosition(t.end) && (o = t.end),
                new xs(e, o)
              );
            }
            return null;
          }
          getMinimalFlatRanges() {
            const t = [],
              e = this.start.getCommonPath(this.end).length,
              o = ks._createAt(this.start);
            let i = o.parent;
            for (; o.path.length > e + 1; ) {
              const e = i.maxOffset - o.offset;
              0 !== e && t.push(new xs(o, o.getShiftedBy(e))),
                (o.path = o.path.slice(0, -1)),
                o.offset++,
                (i = i.parent);
            }
            for (; o.path.length <= this.end.path.length; ) {
              const e = this.end.path[o.path.length - 1],
                i = e - o.offset;
              0 !== i && t.push(new xs(o, o.getShiftedBy(i))), (o.offset = e), o.path.push(0);
            }
            return t;
          }
          getWalker(t = {}) {
            return (t.boundaries = this), new bs(t);
          }
          *getItems(t = {}) {
            (t.boundaries = this), (t.ignoreElementEnd = !0);
            const e = new bs(t);
            for (const t of e) yield t.item;
          }
          *getPositions(t = {}) {
            t.boundaries = this;
            const e = new bs(t);
            yield e.position;
            for (const t of e) yield t.nextPosition;
          }
          getTransformedByOperation(t) {
            switch (t.type) {
              case 'insert':
                return this._getTransformedByInsertOperation(t);
              case 'move':
              case 'remove':
              case 'reinsert':
                return this._getTransformedByMoveOperation(t);
              case 'split':
                return [this._getTransformedBySplitOperation(t)];
              case 'merge':
                return [this._getTransformedByMergeOperation(t)];
            }
            return [new xs(this.start, this.end)];
          }
          getTransformedByOperations(t) {
            const e = [new xs(this.start, this.end)];
            for (const o of t)
              for (let t = 0; t < e.length; t++) {
                const i = e[t].getTransformedByOperation(o);
                e.splice(t, 1, ...i), (t += i.length - 1);
              }
            for (let t = 0; t < e.length; t++) {
              const o = e[t];
              for (let i = t + 1; i < e.length; i++) {
                const t = e[i];
                (o.containsRange(t) || t.containsRange(o) || o.isEqual(t)) && e.splice(i, 1);
              }
            }
            return e;
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed) return null;
            const t = this.start.nodeAfter,
              e = this.end.nodeBefore;
            return t && t.is('element') && t === e ? t : null;
          }
          toJSON() {
            return { start: this.start.toJSON(), end: this.end.toJSON() };
          }
          clone() {
            return new this.constructor(this.start, this.end);
          }
          _getTransformedByInsertOperation(t, e = !1) {
            return this._getTransformedByInsertion(t.position, t.howMany, e);
          }
          _getTransformedByMoveOperation(t, e = !1) {
            const o = t.sourcePosition,
              i = t.howMany,
              n = t.targetPosition;
            return this._getTransformedByMove(o, n, i, e);
          }
          _getTransformedBySplitOperation(t) {
            const e = this.start._getTransformedBySplitOperation(t);
            let o = this.end._getTransformedBySplitOperation(t);
            return (
              this.end.isEqual(t.insertionPosition) && (o = this.end.getShiftedBy(1)),
              e.root != o.root && (o = this.end.getShiftedBy(-1)),
              new xs(e, o)
            );
          }
          _getTransformedByMergeOperation(t) {
            if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) return new xs(this.start);
            let e = this.start._getTransformedByMergeOperation(t),
              o = this.end._getTransformedByMergeOperation(t);
            return (
              e.root != o.root && (o = this.end.getShiftedBy(-1)),
              e.isAfter(o)
                ? (t.sourcePosition.isBefore(t.targetPosition)
                    ? ((e = ks._createAt(o)), (e.offset = 0))
                    : (t.deletionPosition.isEqual(e) || (o = t.deletionPosition), (e = t.targetPosition)),
                  new xs(e, o))
                : new xs(e, o)
            );
          }
          _getTransformedByInsertion(t, e, o = !1) {
            if (o && this.containsPosition(t))
              return [new xs(this.start, t), new xs(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))];
            {
              const o = new xs(this.start, this.end);
              return (
                (o.start = o.start._getTransformedByInsertion(t, e)),
                (o.end = o.end._getTransformedByInsertion(t, e)),
                [o]
              );
            }
          }
          _getTransformedByMove(t, e, o, i = !1) {
            if (this.isCollapsed) {
              const i = this.start._getTransformedByMove(t, e, o);
              return [new xs(i)];
            }
            const n = xs._createFromPositionAndShift(t, o),
              r = e._getTransformedByDeletion(t, o);
            if (this.containsPosition(e) && !i && (n.containsPosition(this.start) || n.containsPosition(this.end))) {
              const i = this.start._getTransformedByMove(t, e, o),
                n = this.end._getTransformedByMove(t, e, o);
              return [new xs(i, n)];
            }
            let s;
            const a = this.getDifference(n);
            let l = null;
            const c = this.getIntersection(n);
            if (
              (1 == a.length
                ? (l = new xs(a[0].start._getTransformedByDeletion(t, o), a[0].end._getTransformedByDeletion(t, o)))
                : 2 == a.length && (l = new xs(this.start, this.end._getTransformedByDeletion(t, o))),
              (s = l ? l._getTransformedByInsertion(r, o, null !== c || i) : []),
              c)
            ) {
              const t = new xs(c.start._getCombined(n.start, r), c.end._getCombined(n.start, r));
              2 == s.length ? s.splice(1, 0, t) : s.push(t);
            }
            return s;
          }
          _getTransformedByDeletion(t, e) {
            let o = this.start._getTransformedByDeletion(t, e),
              i = this.end._getTransformedByDeletion(t, e);
            return null == o && null == i ? null : (null == o && (o = t), null == i && (i = t), new xs(o, i));
          }
          static _createFromPositionAndShift(t, e) {
            const o = t,
              i = t.getShiftedBy(e);
            return e > 0 ? new this(o, i) : new this(i, o);
          }
          static _createIn(t) {
            return new this(ks._createAt(t, 0), ks._createAt(t, t.maxOffset));
          }
          static _createOn(t) {
            return this._createFromPositionAndShift(ks._createBefore(t), t.offsetSize);
          }
          static _createFromRanges(t) {
            if (0 === t.length)
              throw new uo.b('range-create-from-ranges-empty-array: At least one range has to be passed.', null);
            if (1 == t.length) return t[0].clone();
            const e = t[0];
            t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
            const o = t.indexOf(e),
              i = new this(e.start, e.end);
            if (o > 0) for (let e = o - 1; t[e].end.isEqual(i.start); e++) i.start = ks._createAt(t[e].start);
            for (let e = o + 1; e < t.length && t[e].start.isEqual(i.end); e++) i.end = ks._createAt(t[e].end);
            return i;
          }
          static fromJSON(t, e) {
            return new this(ks.fromJSON(t.start, e), ks.fromJSON(t.end, e));
          }
        }
        class Cs {
          constructor() {
            (this._modelToViewMapping = new WeakMap()),
              (this._viewToModelMapping = new WeakMap()),
              (this._viewToModelLengthCallbacks = new Map()),
              (this._markerNameToElements = new Map()),
              (this._elementToMarkerNames = new Map()),
              (this._unboundMarkerNames = new Set()),
              this.on(
                'modelToViewPosition',
                (t, e) => {
                  if (e.viewPosition) return;
                  const o = this._modelToViewMapping.get(e.modelPosition.parent);
                  e.viewPosition = this._findPositionIn(o, e.modelPosition.offset);
                },
                { priority: 'low' }
              ),
              this.on(
                'viewToModelPosition',
                (t, e) => {
                  if (e.modelPosition) return;
                  const o = this.findMappedViewAncestor(e.viewPosition),
                    i = this._viewToModelMapping.get(o),
                    n = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, o);
                  e.modelPosition = ks._createAt(i, n);
                },
                { priority: 'low' }
              );
          }
          bindElements(t, e) {
            this._modelToViewMapping.set(t, e), this._viewToModelMapping.set(e, t);
          }
          unbindViewElement(t) {
            const e = this.toModelElement(t);
            if ((this._viewToModelMapping.delete(t), this._elementToMarkerNames.has(t)))
              for (const e of this._elementToMarkerNames.get(t)) this._unboundMarkerNames.add(e);
            this._modelToViewMapping.get(e) == t && this._modelToViewMapping.delete(e);
          }
          unbindModelElement(t) {
            const e = this.toViewElement(t);
            this._modelToViewMapping.delete(t),
              this._viewToModelMapping.get(e) == t && this._viewToModelMapping.delete(e);
          }
          bindElementToMarker(t, e) {
            const o = this._markerNameToElements.get(e) || new Set();
            o.add(t);
            const i = this._elementToMarkerNames.get(t) || new Set();
            i.add(e), this._markerNameToElements.set(e, o), this._elementToMarkerNames.set(t, i);
          }
          unbindElementFromMarkerName(t, e) {
            const o = this._markerNameToElements.get(e);
            o && (o.delete(t), 0 == o.size && this._markerNameToElements.delete(e));
            const i = this._elementToMarkerNames.get(t);
            i && (i.delete(e), 0 == i.size && this._elementToMarkerNames.delete(t));
          }
          flushUnboundMarkerNames() {
            const t = Array.from(this._unboundMarkerNames);
            return this._unboundMarkerNames.clear(), t;
          }
          clearBindings() {
            (this._modelToViewMapping = new WeakMap()),
              (this._viewToModelMapping = new WeakMap()),
              (this._markerNameToElements = new Map()),
              (this._elementToMarkerNames = new Map()),
              (this._unboundMarkerNames = new Set());
          }
          toModelElement(t) {
            return this._viewToModelMapping.get(t);
          }
          toViewElement(t) {
            return this._modelToViewMapping.get(t);
          }
          toModelRange(t) {
            return new xs(this.toModelPosition(t.start), this.toModelPosition(t.end));
          }
          toViewRange(t) {
            return new Xi(this.toViewPosition(t.start), this.toViewPosition(t.end));
          }
          toModelPosition(t) {
            const e = { viewPosition: t, mapper: this };
            return this.fire('viewToModelPosition', e), e.modelPosition;
          }
          toViewPosition(t, e = { isPhantom: !1 }) {
            const o = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
            return this.fire('modelToViewPosition', o), o.viewPosition;
          }
          markerNameToElements(t) {
            const e = this._markerNameToElements.get(t);
            if (!e) return null;
            const o = new Set();
            for (const t of e)
              if (t.is('attributeElement')) for (const e of t.getElementsWithSameId()) o.add(e);
              else o.add(t);
            return o;
          }
          registerViewToModelLength(t, e) {
            this._viewToModelLengthCallbacks.set(t, e);
          }
          findMappedViewAncestor(t) {
            let e = t.parent;
            for (; !this._viewToModelMapping.has(e); ) e = e.parent;
            return e;
          }
          _toModelOffset(t, e, o) {
            if (o != t) {
              return this._toModelOffset(t.parent, t.index, o) + this._toModelOffset(t, e, t);
            }
            if (t.is('text')) return e;
            let i = 0;
            for (let o = 0; o < e; o++) i += this.getModelLength(t.getChild(o));
            return i;
          }
          getModelLength(t) {
            if (this._viewToModelLengthCallbacks.get(t.name)) {
              return this._viewToModelLengthCallbacks.get(t.name)(t);
            }
            if (this._viewToModelMapping.has(t)) return 1;
            if (t.is('text')) return t.data.length;
            if (t.is('uiElement')) return 0;
            {
              let e = 0;
              for (const o of t.getChildren()) e += this.getModelLength(o);
              return e;
            }
          }
          _findPositionIn(t, e) {
            let o,
              i = 0,
              n = 0,
              r = 0;
            if (t.is('text')) return new Zi(t, e);
            for (; n < e; ) (o = t.getChild(r)), (i = this.getModelLength(o)), (n += i), r++;
            return n == e ? this._moveViewPositionToTextNode(new Zi(t, r)) : this._findPositionIn(o, e - (n - i));
          }
          _moveViewPositionToTextNode(t) {
            const e = t.nodeBefore,
              o = t.nodeAfter;
            return e instanceof Oo ? new Zi(e, e.data.length) : o instanceof Oo ? new Zi(o, 0) : t;
          }
        }
        xo(Cs, fo);
        class As {
          constructor() {
            (this._consumable = new Map()), (this._textProxyRegistry = new Map());
          }
          add(t, e) {
            (e = Ts(e)),
              t instanceof ms && (t = this._getSymbolForTextProxy(t)),
              this._consumable.has(t) || this._consumable.set(t, new Map()),
              this._consumable.get(t).set(e, !0);
          }
          consume(t, e) {
            return (
              (e = Ts(e)),
              t instanceof ms && (t = this._getSymbolForTextProxy(t)),
              !!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
            );
          }
          test(t, e) {
            (e = Ts(e)), t instanceof ms && (t = this._getSymbolForTextProxy(t));
            const o = this._consumable.get(t);
            if (void 0 === o) return null;
            const i = o.get(e);
            return void 0 === i ? null : i;
          }
          revert(t, e) {
            (e = Ts(e)), t instanceof ms && (t = this._getSymbolForTextProxy(t));
            const o = this.test(t, e);
            return !1 === o ? (this._consumable.get(t).set(e, !0), !0) : !0 !== o && null;
          }
          _getSymbolForTextProxy(t) {
            let e = null;
            const o = this._textProxyRegistry.get(t.startOffset);
            if (o) {
              const i = o.get(t.endOffset);
              i && (e = i.get(t.parent));
            }
            return e || (e = this._addSymbolForTextProxy(t.startOffset, t.endOffset, t.parent)), e;
          }
          _addSymbolForTextProxy(t, e, o) {
            const i = Symbol('textProxySymbol');
            let n, r;
            return (
              (n = this._textProxyRegistry.get(t)),
              n || ((n = new Map()), this._textProxyRegistry.set(t, n)),
              (r = n.get(e)),
              r || ((r = new Map()), n.set(e, r)),
              r.set(o, i),
              i
            );
          }
        }
        function Ts(t) {
          const e = t.split(':');
          return e.length > 1 ? e[0] + ':' + e[1] : e[0];
        }
        class Ss {
          constructor(t) {
            this.conversionApi = zi({ dispatcher: this }, t);
          }
          convertChanges(t, e, o) {
            for (const e of t.getMarkersToRemove()) this.convertMarkerRemove(e.name, e.range, o);
            for (const e of t.getChanges())
              'insert' == e.type
                ? this.convertInsert(xs._createFromPositionAndShift(e.position, e.length), o)
                : 'remove' == e.type
                ? this.convertRemove(e.position, e.length, e.name, o)
                : this.convertAttribute(e.range, e.attributeKey, e.attributeOldValue, e.attributeNewValue, o);
            for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
              const i = e.get(t).getRange();
              this.convertMarkerRemove(t, i, o), this.convertMarkerAdd(t, i, o);
            }
            for (const e of t.getMarkersToAdd()) this.convertMarkerAdd(e.name, e.range, o);
          }
          convertInsert(t, e) {
            (this.conversionApi.writer = e), (this.conversionApi.consumable = this._createInsertConsumable(t));
            for (const e of t) {
              const t = e.item,
                o = { item: t, range: xs._createFromPositionAndShift(e.previousPosition, e.length) };
              this._testAndFire('insert', o);
              for (const e of t.getAttributeKeys())
                (o.attributeKey = e),
                  (o.attributeOldValue = null),
                  (o.attributeNewValue = t.getAttribute(e)),
                  this._testAndFire('attribute:' + e, o);
            }
            this._clearConversionApi();
          }
          convertRemove(t, e, o, i) {
            (this.conversionApi.writer = i),
              this.fire('remove:' + o, { position: t, length: e }, this.conversionApi),
              this._clearConversionApi();
          }
          convertAttribute(t, e, o, i, n) {
            (this.conversionApi.writer = n),
              (this.conversionApi.consumable = this._createConsumableForRange(t, 'attribute:' + e));
            for (const n of t) {
              const t = {
                item: n.item,
                range: xs._createFromPositionAndShift(n.previousPosition, n.length),
                attributeKey: e,
                attributeOldValue: o,
                attributeNewValue: i,
              };
              this._testAndFire('attribute:' + e, t);
            }
            this._clearConversionApi();
          }
          convertSelection(t, e, o) {
            const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
            if (
              ((this.conversionApi.writer = o),
              (this.conversionApi.consumable = this._createSelectionConsumable(t, i)),
              this.fire('selection', { selection: t }, this.conversionApi),
              t.isCollapsed)
            ) {
              for (const e of i) {
                const o = e.getRange();
                if (!Ps(t.getFirstPosition(), e, this.conversionApi.mapper)) continue;
                const i = { item: t, markerName: e.name, markerRange: o };
                this.conversionApi.consumable.test(t, 'addMarker:' + e.name) &&
                  this.fire('addMarker:' + e.name, i, this.conversionApi);
              }
              for (const e of t.getAttributeKeys()) {
                const o = {
                  item: t,
                  range: t.getFirstRange(),
                  attributeKey: e,
                  attributeOldValue: null,
                  attributeNewValue: t.getAttribute(e),
                };
                this.conversionApi.consumable.test(t, 'attribute:' + o.attributeKey) &&
                  this.fire('attribute:' + o.attributeKey + ':$text', o, this.conversionApi);
              }
              this._clearConversionApi();
            }
          }
          convertMarkerAdd(t, e, o) {
            if (!e.root.document || '$graveyard' == e.root.rootName) return;
            this.conversionApi.writer = o;
            const i = 'addMarker:' + t,
              n = new As();
            if (
              (n.add(e, i),
              (this.conversionApi.consumable = n),
              this.fire(i, { markerName: t, markerRange: e }, this.conversionApi),
              n.test(e, i))
            ) {
              this.conversionApi.consumable = this._createConsumableForRange(e, i);
              for (const o of e.getItems()) {
                if (!this.conversionApi.consumable.test(o, i)) continue;
                const n = { item: o, range: xs._createOn(o), markerName: t, markerRange: e };
                this.fire(i, n, this.conversionApi);
              }
              this._clearConversionApi();
            }
          }
          convertMarkerRemove(t, e, o) {
            e.root.document &&
              '$graveyard' != e.root.rootName &&
              ((this.conversionApi.writer = o),
              this.fire('removeMarker:' + t, { markerName: t, markerRange: e }, this.conversionApi),
              this._clearConversionApi());
          }
          _createInsertConsumable(t) {
            const e = new As();
            for (const o of t) {
              const t = o.item;
              e.add(t, 'insert');
              for (const o of t.getAttributeKeys()) e.add(t, 'attribute:' + o);
            }
            return e;
          }
          _createConsumableForRange(t, e) {
            const o = new As();
            for (const i of t.getItems()) o.add(i, e);
            return o;
          }
          _createSelectionConsumable(t, e) {
            const o = new As();
            o.add(t, 'selection');
            for (const i of e) o.add(t, 'addMarker:' + i.name);
            for (const e of t.getAttributeKeys()) o.add(t, 'attribute:' + e);
            return o;
          }
          _testAndFire(t, e) {
            if (!this.conversionApi.consumable.test(e.item, t)) return;
            const o = e.item.name || '$text';
            this.fire(t + ':' + o, e, this.conversionApi);
          }
          _clearConversionApi() {
            delete this.conversionApi.writer, delete this.conversionApi.consumable;
          }
        }
        function Ps(t, e, o) {
          const i = e.getRange(),
            n = Array.from(t.getAncestors());
          n.shift(), n.reverse();
          return !n.some(t => {
            if (i.containsItem(t)) {
              return !!o.toViewElement(t).getCustomProperty('addHighlight');
            }
          });
        }
        xo(Ss, fo);
        class Es {
          constructor(t, e, o) {
            (this._lastRangeBackward = !1), (this._ranges = []), (this._attrs = new Map()), t && this.setTo(t, e, o);
          }
          get anchor() {
            if (this._ranges.length > 0) {
              const t = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t.end : t.start;
            }
            return null;
          }
          get focus() {
            if (this._ranges.length > 0) {
              const t = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t.start : t.end;
            }
            return null;
          }
          get isCollapsed() {
            return 1 === this._ranges.length && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          isEqual(t) {
            if (this.rangeCount != t.rangeCount) return !1;
            if (0 === this.rangeCount) return !0;
            if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
            for (const e of this._ranges) {
              let o = !1;
              for (const i of t._ranges)
                if (e.isEqual(i)) {
                  o = !0;
                  break;
                }
              if (!o) return !1;
            }
            return !0;
          }
          *getRanges() {
            for (const t of this._ranges) yield new xs(t.start, t.end);
          }
          getFirstRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.start.isBefore(t.start)) || (t = e);
            return t ? new xs(t.start, t.end) : null;
          }
          getLastRange() {
            let t = null;
            for (const e of this._ranges) (t && !e.end.isAfter(t.end)) || (t = e);
            return t ? new xs(t.start, t.end) : null;
          }
          getFirstPosition() {
            const t = this.getFirstRange();
            return t ? t.start.clone() : null;
          }
          getLastPosition() {
            const t = this.getLastRange();
            return t ? t.end.clone() : null;
          }
          setTo(t, e, o) {
            if (null === t) this._setRanges([]);
            else if (t instanceof Es) this._setRanges(t.getRanges(), t.isBackward);
            else if (t && 'function' == typeof t.getRanges) this._setRanges(t.getRanges(), t.isBackward);
            else if (t instanceof xs) this._setRanges([t], !!e && !!e.backward);
            else if (t instanceof ks) this._setRanges([new xs(t)]);
            else if (t instanceof us) {
              const i = !!o && !!o.backward;
              let n;
              if ('in' == e) n = xs._createIn(t);
              else if ('on' == e) n = xs._createOn(t);
              else {
                if (void 0 === e)
                  throw new uo.b(
                    'model-selection-setTo-required-second-parameter: selection.setTo requires the second parameter when the first parameter is a node.',
                    [this, t]
                  );
                n = new xs(ks._createAt(t, e));
              }
              this._setRanges([n], i);
            } else {
              if (!yo(t))
                throw new uo.b('model-selection-setTo-not-selectable: Cannot set the selection to the given place.', [
                  this,
                  t,
                ]);
              this._setRanges(t, e && !!e.backward);
            }
          }
          _setRanges(t, e = !1) {
            const o = (t = Array.from(t)).some(e => {
              if (!(e instanceof xs))
                throw new uo.b(
                  'model-selection-set-ranges-not-range: Selection range set to an object that is not an instance of model.Range.',
                  [this, t]
                );
              return this._ranges.every(t => !t.isEqual(e));
            });
            if (t.length !== this._ranges.length || o) {
              this._removeAllRanges();
              for (const e of t) this._pushRange(e);
              (this._lastRangeBackward = !!e), this.fire('change:range', { directChange: !0 });
            }
          }
          setFocus(t, e) {
            if (null === this.anchor)
              throw new uo.b(
                'model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.',
                [this, t]
              );
            const o = ks._createAt(t, e);
            if ('same' == o.compareWith(this.focus)) return;
            const i = this.anchor;
            this._ranges.length && this._popRange(),
              'before' == o.compareWith(i)
                ? (this._pushRange(new xs(o, i)), (this._lastRangeBackward = !0))
                : (this._pushRange(new xs(i, o)), (this._lastRangeBackward = !1)),
              this.fire('change:range', { directChange: !0 });
          }
          getAttribute(t) {
            return this._attrs.get(t);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          hasAttribute(t) {
            return this._attrs.has(t);
          }
          removeAttribute(t) {
            this.hasAttribute(t) &&
              (this._attrs.delete(t), this.fire('change:attribute', { attributeKeys: [t], directChange: !0 }));
          }
          setAttribute(t, e) {
            this.getAttribute(t) !== e &&
              (this._attrs.set(t, e), this.fire('change:attribute', { attributeKeys: [t], directChange: !0 }));
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          is(t) {
            return 'selection' === t || 'model:selection' === t;
          }
          *getSelectedBlocks() {
            const t = new WeakSet();
            for (const e of this.getRanges()) {
              const o = Ns(e.start, t);
              o && Rs(o, e) && (yield o);
              for (const o of e.getWalker()) {
                const i = o.item;
                'elementEnd' == o.type && Is(i, t, e) && (yield i);
              }
              const i = Ns(e.end, t);
              i && !e.end.isTouching(ks._createAt(i, 0)) && Rs(i, e) && (yield i);
            }
          }
          containsEntireContent(t = this.anchor.root) {
            const e = ks._createAt(t, 0),
              o = ks._createAt(t, 'end');
            return e.isTouching(this.getFirstPosition()) && o.isTouching(this.getLastPosition());
          }
          _pushRange(t) {
            this._checkRange(t), this._ranges.push(new xs(t.start, t.end));
          }
          _checkRange(t) {
            for (let e = 0; e < this._ranges.length; e++)
              if (t.isIntersecting(this._ranges[e]))
                throw new uo.b(
                  'model-selection-range-intersects: Trying to add a range that intersects with another range in the selection.',
                  [this, t],
                  { addedRange: t, intersectingRange: this._ranges[e] }
                );
          }
          _removeAllRanges() {
            for (; this._ranges.length > 0; ) this._popRange();
          }
          _popRange() {
            this._ranges.pop();
          }
        }
        function Ms(t, e) {
          return !e.has(t) && (e.add(t), t.root.document.model.schema.isBlock(t) && t.parent);
        }
        function Is(t, e, o) {
          return Ms(t, e) && Rs(t, o);
        }
        function Ns(t, e) {
          const o = t.parent.root.document.model.schema,
            i = t.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
          let n = !1;
          const r = i.find(t => !n && ((n = o.isLimit(t)), !n && Ms(t, e)));
          return i.forEach(t => e.add(t)), r;
        }
        function Rs(t, e) {
          const o = (function (t) {
            const e = t.root.document.model.schema;
            let o = t.parent;
            for (; o; ) {
              if (e.isBlock(o)) return o;
              o = o.parent;
            }
          })(t);
          if (!o) return !0;
          return !e.containsRange(xs._createOn(o), !0);
        }
        xo(Es, fo);
        class Os extends xs {
          constructor(t, e) {
            super(t, e), Vs.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t) {
            return 'liveRange' === t || 'model:liveRange' === t || 'range' == t || 'model:range' === t;
          }
          toRange() {
            return new xs(this.start, this.end);
          }
          static fromRange(t) {
            return new Os(t.start, t.end);
          }
        }
        function Vs() {
          this.listenTo(
            this.root.document.model,
            'applyOperation',
            (t, e) => {
              const o = e[0];
              o.isDocumentOperation && Ds.call(this, o);
            },
            { priority: 'low' }
          );
        }
        function Ds(t) {
          const e = this.getTransformedByOperation(t),
            o = xs._createFromRanges(e),
            i = !o.isEqual(this),
            n = (function (t, e) {
              switch (e.type) {
                case 'insert':
                  return t.containsPosition(e.position);
                case 'move':
                case 'remove':
                case 'reinsert':
                case 'merge':
                  return (
                    t.containsPosition(e.sourcePosition) ||
                    t.start.isEqual(e.sourcePosition) ||
                    t.containsPosition(e.targetPosition)
                  );
                case 'split':
                  return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition);
              }
              return !1;
            })(this, t);
          let r = null;
          if (i) {
            '$graveyard' == o.root.rootName && (r = 'remove' == t.type ? t.sourcePosition : t.deletionPosition);
            const e = this.toRange();
            (this.start = o.start), (this.end = o.end), this.fire('change:range', e, { deletionPosition: r });
          } else n && this.fire('change:content', this.toRange(), { deletionPosition: r });
        }
        xo(Os, fo);
        class zs {
          constructor(t) {
            (this._selection = new Ls(t)),
              this._selection.delegate('change:range').to(this),
              this._selection.delegate('change:attribute').to(this),
              this._selection.delegate('change:marker').to(this);
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get hasOwnRange() {
            return this._selection.hasOwnRange;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get isGravityOverridden() {
            return this._selection.isGravityOverridden;
          }
          get markers() {
            return this._selection.markers;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          getRanges() {
            return this._selection.getRanges();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getSelectedBlocks() {
            return this._selection.getSelectedBlocks();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          containsEntireContent(t) {
            return this._selection.containsEntireContent(t);
          }
          destroy() {
            this._selection.destroy();
          }
          getAttributeKeys() {
            return this._selection.getAttributeKeys();
          }
          getAttributes() {
            return this._selection.getAttributes();
          }
          getAttribute(t) {
            return this._selection.getAttribute(t);
          }
          hasAttribute(t) {
            return this._selection.hasAttribute(t);
          }
          refresh() {
            this._selection._updateMarkers(), this._selection._updateAttributes(!1);
          }
          is(t) {
            return (
              'selection' === t || 'model:selection' == t || 'documentSelection' == t || 'model:documentSelection' == t
            );
          }
          _setFocus(t, e) {
            this._selection.setFocus(t, e);
          }
          _setTo(t, e, o) {
            this._selection.setTo(t, e, o);
          }
          _setAttribute(t, e) {
            this._selection.setAttribute(t, e);
          }
          _removeAttribute(t) {
            this._selection.removeAttribute(t);
          }
          _getStoredAttributes() {
            return this._selection._getStoredAttributes();
          }
          _overrideGravity() {
            return this._selection.overrideGravity();
          }
          _restoreGravity(t) {
            this._selection.restoreGravity(t);
          }
          static _getStoreAttributeKey(t) {
            return 'selection:' + t;
          }
          static _isStoreAttributeKey(t) {
            return t.startsWith('selection:');
          }
        }
        xo(zs, fo);
        class Ls extends Es {
          constructor(t) {
            super(),
              (this.markers = new Co({ idProperty: 'name' })),
              (this._model = t.model),
              (this._document = t),
              (this._attributePriority = new Map()),
              (this._fixGraveyardRangesData = []),
              (this._hasChangedRange = !1),
              (this._overriddenGravityRegister = new Set()),
              this.listenTo(
                this._model,
                'applyOperation',
                (t, e) => {
                  const o = e[0];
                  if (o.isDocumentOperation && 'marker' != o.type && 'rename' != o.type && 'noop' != o.type) {
                    for (; this._fixGraveyardRangesData.length; ) {
                      const { liveRange: t, sourcePosition: e } = this._fixGraveyardRangesData.shift();
                      this._fixGraveyardSelection(t, e);
                    }
                    this._hasChangedRange &&
                      ((this._hasChangedRange = !1), this.fire('change:range', { directChange: !1 }));
                  }
                },
                { priority: 'lowest' }
              ),
              this.on('change:range', () => {
                for (const t of this.getRanges())
                  if (!this._document._validateSelectionRange(t))
                    throw new uo.b(
                      'document-selection-wrong-position: Range from document selection starts or ends at incorrect position.',
                      this,
                      { range: t }
                    );
              }),
              this.listenTo(this._model.markers, 'update', () => this._updateMarkers()),
              this.listenTo(this._document, 'change', (t, e) => {
                !(function (t, e) {
                  const o = t.document.differ;
                  for (const i of o.getChanges()) {
                    if ('insert' != i.type) continue;
                    const o = i.position.parent;
                    i.length === o.maxOffset &&
                      t.enqueueChange(e, t => {
                        const e = Array.from(o.getAttributeKeys()).filter(t => t.startsWith('selection:'));
                        for (const i of e) t.removeAttribute(i, o);
                      });
                  }
                })(this._model, e);
              });
          }
          get isCollapsed() {
            return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
          }
          get anchor() {
            return super.anchor || this._document._getDefaultRange().start;
          }
          get focus() {
            return super.focus || this._document._getDefaultRange().end;
          }
          get rangeCount() {
            return this._ranges.length ? this._ranges.length : 1;
          }
          get hasOwnRange() {
            return this._ranges.length > 0;
          }
          get isGravityOverridden() {
            return !!this._overriddenGravityRegister.size;
          }
          destroy() {
            for (let t = 0; t < this._ranges.length; t++) this._ranges[t].detach();
            this.stopListening();
          }
          *getRanges() {
            this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
          }
          getFirstRange() {
            return super.getFirstRange() || this._document._getDefaultRange();
          }
          getLastRange() {
            return super.getLastRange() || this._document._getDefaultRange();
          }
          setTo(t, e, o) {
            super.setTo(t, e, o), this._updateAttributes(!0), this._updateMarkers();
          }
          setFocus(t, e) {
            super.setFocus(t, e), this._updateAttributes(!0), this._updateMarkers();
          }
          setAttribute(t, e) {
            if (this._setAttribute(t, e)) {
              const e = [t];
              this.fire('change:attribute', { attributeKeys: e, directChange: !0 });
            }
          }
          removeAttribute(t) {
            if (this._removeAttribute(t)) {
              const e = [t];
              this.fire('change:attribute', { attributeKeys: e, directChange: !0 });
            }
          }
          overrideGravity() {
            const t = co();
            return (
              this._overriddenGravityRegister.add(t),
              1 === this._overriddenGravityRegister.size && this._updateAttributes(!0),
              t
            );
          }
          restoreGravity(t) {
            if (!this._overriddenGravityRegister.has(t))
              throw new uo.b(
                'document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.',
                this,
                { uid: t }
              );
            this._overriddenGravityRegister.delete(t), this.isGravityOverridden || this._updateAttributes(!0);
          }
          _popRange() {
            this._ranges.pop().detach();
          }
          _pushRange(t) {
            const e = this._prepareRange(t);
            e && this._ranges.push(e);
          }
          _prepareRange(t) {
            if ((this._checkRange(t), t.root == this._document.graveyard)) return;
            const e = Os.fromRange(t);
            return (
              e.on('change:range', (t, o, i) => {
                (this._hasChangedRange = !0),
                  e.root == this._document.graveyard &&
                    this._fixGraveyardRangesData.push({ liveRange: e, sourcePosition: i.deletionPosition });
              }),
              e
            );
          }
          _updateMarkers() {
            const t = [];
            let e = !1;
            for (const e of this._model.markers) {
              const o = e.getRange();
              for (const i of this.getRanges()) o.containsRange(i, !i.isCollapsed) && t.push(e);
            }
            const o = Array.from(this.markers);
            for (const o of t) this.markers.has(o) || (this.markers.add(o), (e = !0));
            for (const o of Array.from(this.markers)) t.includes(o) || (this.markers.remove(o), (e = !0));
            e && this.fire('change:marker', { oldMarkers: o, directChange: !1 });
          }
          _updateAttributes(t) {
            const e = Do(this._getSurroundingAttributes()),
              o = Do(this.getAttributes());
            if (t) (this._attributePriority = new Map()), (this._attrs = new Map());
            else
              for (const [t, e] of this._attributePriority)
                'low' == e && (this._attrs.delete(t), this._attributePriority.delete(t));
            this._setAttributesTo(e);
            const i = [];
            for (const [t, e] of this.getAttributes()) (o.has(t) && o.get(t) === e) || i.push(t);
            for (const [t] of o) this.hasAttribute(t) || i.push(t);
            i.length > 0 && this.fire('change:attribute', { attributeKeys: i, directChange: !1 });
          }
          _setAttribute(t, e, o = !0) {
            const i = o ? 'normal' : 'low';
            if ('low' == i && 'normal' == this._attributePriority.get(t)) return !1;
            return super.getAttribute(t) !== e && (this._attrs.set(t, e), this._attributePriority.set(t, i), !0);
          }
          _removeAttribute(t, e = !0) {
            const o = e ? 'normal' : 'low';
            return (
              ('low' != o || 'normal' != this._attributePriority.get(t)) &&
              (this._attributePriority.set(t, o), !!super.hasAttribute(t) && (this._attrs.delete(t), !0))
            );
          }
          _setAttributesTo(t) {
            const e = new Set();
            for (const [e, o] of this.getAttributes()) t.get(e) !== o && this._removeAttribute(e, !1);
            for (const [o, i] of t) {
              this._setAttribute(o, i, !1) && e.add(o);
            }
            return e;
          }
          *_getStoredAttributes() {
            const t = this.getFirstPosition().parent;
            if (this.isCollapsed && t.isEmpty)
              for (const e of t.getAttributeKeys())
                if (e.startsWith('selection:')) {
                  const o = e.substr('selection:'.length);
                  yield [o, t.getAttribute(e)];
                }
          }
          _getSurroundingAttributes() {
            const t = this.getFirstPosition(),
              e = this._model.schema;
            let o = null;
            if (this.isCollapsed) {
              const e = t.textNode ? t.textNode : t.nodeBefore,
                i = t.textNode ? t.textNode : t.nodeAfter;
              if ((this.isGravityOverridden || (o = js(e)), o || (o = js(i)), !this.isGravityOverridden && !o)) {
                let t = e;
                for (; t && !o; ) (t = t.previousSibling), (o = js(t));
              }
              if (!o) {
                let t = i;
                for (; t && !o; ) (t = t.nextSibling), (o = js(t));
              }
              o || (o = this._getStoredAttributes());
            } else {
              const t = this.getFirstRange();
              for (const i of t) {
                if (i.item.is('element') && e.isObject(i.item)) break;
                if ('text' == i.type) {
                  o = i.item.getAttributes();
                  break;
                }
              }
            }
            return o;
          }
          _fixGraveyardSelection(t, e) {
            const o = e.clone(),
              i = this._model.schema.getNearestSelectionRange(o),
              n = this._ranges.indexOf(t);
            if ((this._ranges.splice(n, 1), t.detach(), i && ((r = i), this._ranges.every(t => !r.isEqual(t))))) {
              const t = this._prepareRange(i);
              this._ranges.splice(n, 0, t);
            }
            var r;
          }
        }
        function js(t) {
          return t instanceof ms || t instanceof gs ? t.getAttributes() : null;
        }
        class Bs {
          constructor(t) {
            this._dispatchers = t;
          }
          add(t) {
            for (const e of this._dispatchers) t(e);
            return this;
          }
        }
        var Fs = function (t) {
          return to(t, 5);
        };
        class Hs extends Bs {
          elementToElement(t) {
            return this.add(
              (function (t) {
                return (
                  ((t = Fs(t)).view = Us(t.view, 'container')),
                  e => {
                    var o;
                    e.on(
                      'insert:' + t.model,
                      ((o = t.view),
                      (t, e, i) => {
                        const n = o(e.item, i.writer);
                        if (!n) return;
                        if (!i.consumable.consume(e.item, 'insert')) return;
                        const r = i.mapper.toViewPosition(e.range.start);
                        i.mapper.bindElements(e.item, n), i.writer.insert(r, n);
                      }),
                      { priority: t.converterPriority || 'normal' }
                    );
                  }
                );
              })(t)
            );
          }
          attributeToElement(t) {
            return this.add(
              (function (t) {
                t = Fs(t);
                let e = 'attribute:' + (t.model.key ? t.model.key : t.model);
                t.model.name && (e += ':' + t.model.name);
                if (t.model.values) for (const e of t.model.values) t.view[e] = Us(t.view[e], 'attribute');
                else t.view = Us(t.view, 'attribute');
                const o = qs(t);
                return i => {
                  i.on(
                    e,
                    (function (t) {
                      return (e, o, i) => {
                        const n = t(o.attributeOldValue, i.writer),
                          r = t(o.attributeNewValue, i.writer);
                        if (!n && !r) return;
                        if (!i.consumable.consume(o.item, e.name)) return;
                        const s = i.writer,
                          a = s.document.selection;
                        if (o.item instanceof Es || o.item instanceof zs) s.wrap(a.getFirstRange(), r);
                        else {
                          let t = i.mapper.toViewRange(o.range);
                          null !== o.attributeOldValue && n && (t = s.unwrap(t, n)),
                            null !== o.attributeNewValue && r && s.wrap(t, r);
                        }
                      };
                    })(o),
                    { priority: t.converterPriority || 'normal' }
                  );
                };
              })(t)
            );
          }
          attributeToAttribute(t) {
            return this.add(
              (function (t) {
                t = Fs(t);
                let e = 'attribute:' + (t.model.key ? t.model.key : t.model);
                t.model.name && (e += ':' + t.model.name);
                if (t.model.values) for (const e of t.model.values) t.view[e] = Gs(t.view[e]);
                else t.view = Gs(t.view);
                const o = qs(t);
                return i => {
                  var n;
                  i.on(
                    e,
                    ((n = o),
                    (t, e, o) => {
                      const i = n(e.attributeOldValue, e),
                        r = n(e.attributeNewValue, e);
                      if (!i && !r) return;
                      if (!o.consumable.consume(e.item, t.name)) return;
                      const s = o.mapper.toViewElement(e.item),
                        a = o.writer;
                      if (!s)
                        throw new uo.b(
                          "conversion-attribute-to-attribute-on-text: Trying to convert text node's attribute with attribute-to-attribute converter.",
                          [e, o]
                        );
                      if (null !== e.attributeOldValue && i)
                        if ('class' == i.key) {
                          const t = Array.isArray(i.value) ? i.value : [i.value];
                          for (const e of t) a.removeClass(e, s);
                        } else if ('style' == i.key) {
                          const t = Object.keys(i.value);
                          for (const e of t) a.removeStyle(e, s);
                        } else a.removeAttribute(i.key, s);
                      if (null !== e.attributeNewValue && r)
                        if ('class' == r.key) {
                          const t = Array.isArray(r.value) ? r.value : [r.value];
                          for (const e of t) a.addClass(e, s);
                        } else if ('style' == r.key) {
                          const t = Object.keys(r.value);
                          for (const e of t) a.setStyle(e, r.value[e], s);
                        } else a.setAttribute(r.key, r.value, s);
                    }),
                    { priority: t.converterPriority || 'normal' }
                  );
                };
              })(t)
            );
          }
          markerToElement(t) {
            return this.add(
              (function (t) {
                return (
                  ((t = Fs(t)).view = Us(t.view, 'ui')),
                  e => {
                    var o;
                    e.on(
                      'addMarker:' + t.model,
                      ((o = t.view),
                      (t, e, i) => {
                        e.isOpening = !0;
                        const n = o(e, i.writer);
                        e.isOpening = !1;
                        const r = o(e, i.writer);
                        if (!n || !r) return;
                        const s = e.markerRange;
                        if (s.isCollapsed && !i.consumable.consume(s, t.name)) return;
                        for (const e of s) if (!i.consumable.consume(e.item, t.name)) return;
                        const a = i.mapper,
                          l = i.writer;
                        l.insert(a.toViewPosition(s.start), n),
                          i.mapper.bindElementToMarker(n, e.markerName),
                          s.isCollapsed ||
                            (l.insert(a.toViewPosition(s.end), r), i.mapper.bindElementToMarker(r, e.markerName)),
                          t.stop();
                      }),
                      { priority: t.converterPriority || 'normal' }
                    ),
                      e.on(
                        'removeMarker:' + t.model,
                        (t.view,
                        (t, e, o) => {
                          const i = o.mapper.markerNameToElements(e.markerName);
                          if (i) {
                            for (const t of i)
                              o.mapper.unbindElementFromMarkerName(t, e.markerName),
                                o.writer.clear(o.writer.createRangeOn(t), t);
                            o.writer.clearClonedElementsGroup(e.markerName), t.stop();
                          }
                        }),
                        { priority: t.converterPriority || 'normal' }
                      );
                  }
                );
              })(t)
            );
          }
          markerToHighlight(t) {
            return this.add(
              (function (t) {
                return e => {
                  var o;
                  e.on(
                    'addMarker:' + t.model,
                    ((o = t.view),
                    (t, e, i) => {
                      if (!e.item) return;
                      if (!(e.item instanceof Es || e.item instanceof zs || e.item.is('textProxy'))) return;
                      const n = Ys(o, e, i);
                      if (!n) return;
                      if (!i.consumable.consume(e.item, t.name)) return;
                      const r = i.writer,
                        s = Ws(r, n),
                        a = r.document.selection;
                      if (e.item instanceof Es || e.item instanceof zs) r.wrap(a.getFirstRange(), s, a);
                      else {
                        const t = i.mapper.toViewRange(e.range),
                          o = r.wrap(t, s);
                        for (const t of o.getItems())
                          if (t.is('attributeElement') && t.isSimilar(s)) {
                            i.mapper.bindElementToMarker(t, e.markerName);
                            break;
                          }
                      }
                    }),
                    { priority: t.converterPriority || 'normal' }
                  ),
                    e.on(
                      'addMarker:' + t.model,
                      (function (t) {
                        return (e, o, i) => {
                          if (!o.item) return;
                          if (!(o.item instanceof ps)) return;
                          const n = Ys(t, o, i);
                          if (!n) return;
                          if (!i.consumable.test(o.item, e.name)) return;
                          const r = i.mapper.toViewElement(o.item);
                          if (r && r.getCustomProperty('addHighlight')) {
                            i.consumable.consume(o.item, e.name);
                            for (const t of xs._createIn(o.item)) i.consumable.consume(t.item, e.name);
                            r.getCustomProperty('addHighlight')(r, n, i.writer),
                              i.mapper.bindElementToMarker(r, o.markerName);
                          }
                        };
                      })(t.view),
                      { priority: t.converterPriority || 'normal' }
                    ),
                    e.on(
                      'removeMarker:' + t.model,
                      (function (t) {
                        return (e, o, i) => {
                          if (o.markerRange.isCollapsed) return;
                          const n = Ys(t, o, i);
                          if (!n) return;
                          const r = Ws(i.writer, n),
                            s = i.mapper.markerNameToElements(o.markerName);
                          if (s) {
                            for (const t of s)
                              i.mapper.unbindElementFromMarkerName(t, o.markerName),
                                t.is('attributeElement')
                                  ? i.writer.unwrap(i.writer.createRangeOn(t), r)
                                  : t.getCustomProperty('removeHighlight')(t, n.id, i.writer);
                            i.writer.clearClonedElementsGroup(o.markerName), e.stop();
                          }
                        };
                      })(t.view),
                      { priority: t.converterPriority || 'normal' }
                    );
                };
              })(t)
            );
          }
        }
        function Ws(t, e) {
          const o = t.createAttributeElement('span', e.attributes);
          return e.classes && o._addClass(e.classes), e.priority && (o._priority = e.priority), (o._id = e.id), o;
        }
        function Us(t, e) {
          return 'function' == typeof t
            ? t
            : (o, i) =>
                (function (t, e, o) {
                  'string' == typeof t && (t = { name: t });
                  let i;
                  const n = Object.assign({}, t.attributes);
                  if ('container' == o) i = e.createContainerElement(t.name, n);
                  else if ('attribute' == o) {
                    const o = { priority: t.priority || sn.DEFAULT_PRIORITY };
                    i = e.createAttributeElement(t.name, n, o);
                  } else i = e.createUIElement(t.name, n);
                  if (t.styles) {
                    const o = Object.keys(t.styles);
                    for (const n of o) e.setStyle(n, t.styles[n], i);
                  }
                  if (t.classes) {
                    const o = t.classes;
                    if ('string' == typeof o) e.addClass(o, i);
                    else for (const t of o) e.addClass(t, i);
                  }
                  return i;
                })(t, i, e);
        }
        function qs(t) {
          return t.model.values
            ? (e, o) => {
                const i = t.view[e];
                return i ? i(e, o) : null;
              }
            : t.view;
        }
        function Gs(t) {
          return 'string' == typeof t
            ? e => ({ key: t, value: e })
            : 'object' == typeof t
            ? t.value
              ? () => t
              : e => ({ key: t.key, value: e })
            : t;
        }
        function Ys(t, e, o) {
          const i = 'function' == typeof t ? t(e, o) : t;
          return i ? (i.priority || (i.priority = 10), i.id || (i.id = e.markerName), i) : null;
        }
        class $s extends Bs {
          elementToElement(t) {
            return this.add(Qs(t));
          }
          elementToAttribute(t) {
            return this.add(
              (function (t) {
                Js((t = Fs(t)));
                const e = Zs(t, !1),
                  o = Ks(t.view),
                  i = o ? 'element:' + o : 'element';
                return o => {
                  o.on(i, e, { priority: t.converterPriority || 'low' });
                };
              })(t)
            );
          }
          attributeToAttribute(t) {
            return this.add(
              (function (t) {
                t = Fs(t);
                let e = null;
                ('string' == typeof t.view || t.view.key) &&
                  (e = (function (t) {
                    'string' == typeof t.view && (t.view = { key: t.view });
                    const e = t.view.key;
                    let o;
                    if ('class' == e || 'style' == e) {
                      o = { ['class' == e ? 'classes' : 'styles']: t.view.value };
                    } else {
                      const i = void 0 === t.view.value ? /[\s\S]*/ : t.view.value;
                      o = { attributes: { [e]: i } };
                    }
                    t.view.name && (o.name = t.view.name);
                    return (t.view = o), e;
                  })(t));
                Js(t, e);
                const o = Zs(t, !0);
                return e => {
                  e.on('element', o, { priority: t.converterPriority || 'low' });
                };
              })(t)
            );
          }
          elementToMarker(t) {
            return this.add(
              (function (t) {
                return (
                  (function (t) {
                    const e = t.model;
                    t.model = (t, o) => {
                      const i = 'string' == typeof e ? e : e(t);
                      return o.createElement('$marker', { 'data-name': i });
                    };
                  })((t = Fs(t))),
                  Qs(t)
                );
              })(t)
            );
          }
        }
        function Qs(t) {
          const e = (function (t) {
              const e = t.view ? new zo(t.view) : null;
              return (o, i, n) => {
                let r = {};
                if (e) {
                  const t = e.match(i.viewItem);
                  if (!t) return;
                  r = t.match;
                }
                r.name = !0;
                const s =
                  ((a = t.model),
                  (l = i.viewItem),
                  (c = n.writer),
                  a instanceof Function ? a(l, c) : c.createElement(a));
                var a, l, c;
                if (!s) return;
                if (!n.consumable.test(i.viewItem, r)) return;
                const d = n.splitToAllowedParent(s, i.modelCursor);
                if (!d) return;
                n.writer.insert(s, d.position),
                  n.convertChildren(i.viewItem, n.writer.createPositionAt(s, 0)),
                  n.consumable.consume(i.viewItem, r);
                const h = n.getSplitParts(s);
                (i.modelRange = new xs(
                  n.writer.createPositionBefore(s),
                  n.writer.createPositionAfter(h[h.length - 1])
                )),
                  d.cursorParent
                    ? (i.modelCursor = n.writer.createPositionAt(d.cursorParent, 0))
                    : (i.modelCursor = i.modelRange.end);
              };
            })((t = Fs(t))),
            o = Ks(t.view),
            i = o ? 'element:' + o : 'element';
          return o => {
            o.on(i, e, { priority: t.converterPriority || 'normal' });
          };
        }
        function Ks(t) {
          return 'string' == typeof t ? t : 'object' == typeof t && 'string' == typeof t.name ? t.name : null;
        }
        function Js(t, e = null) {
          const o = null === e || (t => t.getAttribute(e)),
            i = 'object' != typeof t.model ? t.model : t.model.key,
            n = 'object' != typeof t.model || void 0 === t.model.value ? o : t.model.value;
          t.model = { key: i, value: n };
        }
        function Zs(t, e) {
          const o = new zo(t.view);
          return (i, n, r) => {
            const s = o.match(n.viewItem);
            if (!s) return;
            const a = t.model.key,
              l = 'function' == typeof t.model.value ? t.model.value(n.viewItem) : t.model.value;
            if (null === l) return;
            if (
              (!(function (t, e) {
                const o = 'function' == typeof t ? t(e) : t;
                if ('object' == typeof o && !Ks(o)) return !1;
                return !o.classes && !o.attributes && !o.styles;
              })(t.view, n.viewItem)
                ? delete s.match.name
                : (s.match.name = !0),
              !r.consumable.test(n.viewItem, s.match))
            )
              return;
            n.modelRange || (n = Object.assign(n, r.convertChildren(n.viewItem, n.modelCursor)));
            (function (t, e, o, i) {
              let n = !1;
              for (const r of Array.from(t.getItems({ shallow: o })))
                i.schema.checkAttribute(r, e.key) && (i.writer.setAttribute(e.key, e.value, r), (n = !0));
              return n;
            })(n.modelRange, { key: a, value: l }, e, r) && r.consumable.consume(n.viewItem, s.match);
          };
        }
        class Xs {
          constructor(t, e) {
            (this.model = t),
              (this.view = new hs(e)),
              (this.mapper = new Cs()),
              (this.downcastDispatcher = new Ss({ mapper: this.mapper }));
            const o = this.model.document,
              i = o.selection,
              n = this.model.markers;
            this.listenTo(
              this.model,
              '_beforeChanges',
              () => {
                this.view._disableRendering(!0);
              },
              { priority: 'highest' }
            ),
              this.listenTo(
                this.model,
                '_afterChanges',
                () => {
                  this.view._disableRendering(!1);
                },
                { priority: 'lowest' }
              ),
              this.listenTo(
                o,
                'change',
                () => {
                  this.view.change(t => {
                    this.downcastDispatcher.convertChanges(o.differ, n, t),
                      this.downcastDispatcher.convertSelection(i, n, t);
                  });
                },
                { priority: 'low' }
              ),
              this.listenTo(
                this.view.document,
                'selectionChange',
                (function (t, e) {
                  return (o, i) => {
                    const n = i.newSelection,
                      r = new Es(),
                      s = [];
                    for (const t of n.getRanges()) s.push(e.toModelRange(t));
                    r.setTo(s, { backward: n.isBackward }),
                      r.isEqual(t.document.selection) ||
                        t.change(t => {
                          t.setSelection(r);
                        });
                  };
                })(this.model, this.mapper)
              ),
              this.downcastDispatcher.on(
                'insert:$text',
                (t, e, o) => {
                  if (!o.consumable.consume(e.item, 'insert')) return;
                  const i = o.writer,
                    n = o.mapper.toViewPosition(e.range.start),
                    r = i.createText(e.item.data);
                  i.insert(n, r);
                },
                { priority: 'lowest' }
              ),
              this.downcastDispatcher.on(
                'remove',
                (t, e, o) => {
                  const i = o.mapper.toViewPosition(e.position),
                    n = e.position.getShiftedBy(e.length),
                    r = o.mapper.toViewPosition(n, { isPhantom: !0 }),
                    s = o.writer.createRange(i, r),
                    a = o.writer.remove(s.getTrimmed());
                  for (const t of o.writer.createRangeIn(a).getItems()) o.mapper.unbindViewElement(t);
                },
                { priority: 'low' }
              ),
              this.downcastDispatcher.on(
                'selection',
                (t, e, o) => {
                  const i = o.writer,
                    n = i.document.selection;
                  for (const t of n.getRanges())
                    t.isCollapsed && t.end.parent.isAttached() && o.writer.mergeAttributes(t.start);
                  i.setSelection(null);
                },
                { priority: 'low' }
              ),
              this.downcastDispatcher.on(
                'selection',
                (t, e, o) => {
                  const i = e.selection;
                  if (i.isCollapsed) return;
                  if (!o.consumable.consume(i, 'selection')) return;
                  const n = [];
                  for (const t of i.getRanges()) {
                    const e = o.mapper.toViewRange(t);
                    n.push(e);
                  }
                  o.writer.setSelection(n, { backward: i.isBackward });
                },
                { priority: 'low' }
              ),
              this.downcastDispatcher.on(
                'selection',
                (t, e, o) => {
                  const i = e.selection;
                  if (!i.isCollapsed) return;
                  if (!o.consumable.consume(i, 'selection')) return;
                  const n = o.writer,
                    r = i.getFirstPosition(),
                    s = o.mapper.toViewPosition(r),
                    a = n.breakAttributes(s);
                  n.setSelection(a);
                },
                { priority: 'low' }
              ),
              this.view.document.roots.bindTo(this.model.document.roots).using(t => {
                if ('$graveyard' == t.rootName) return null;
                const e = new Ki(this.view.document, t.name);
                return (e.rootName = t.rootName), this.mapper.bindElements(t, e), e;
              });
          }
          destroy() {
            this.view.destroy(), this.stopListening();
          }
        }
        xo(Xs, Hi);
        class ta {
          constructor() {
            this._commands = new Map();
          }
          add(t, e) {
            this._commands.set(t, e);
          }
          get(t) {
            return this._commands.get(t);
          }
          execute(t, ...e) {
            const o = this.get(t);
            if (!o)
              throw new uo.b('commandcollection-command-not-found: Command does not exist.', this, { commandName: t });
            o.execute(...e);
          }
          *names() {
            yield* this._commands.keys();
          }
          *commands() {
            yield* this._commands.values();
          }
          [Symbol.iterator]() {
            return this._commands[Symbol.iterator]();
          }
          destroy() {
            for (const t of this.commands()) t.destroy();
          }
        }
        class ea {
          constructor() {
            this._consumables = new Map();
          }
          add(t, e) {
            let o;
            t.is('text') || t.is('documentFragment')
              ? this._consumables.set(t, !0)
              : (this._consumables.has(t)
                  ? (o = this._consumables.get(t))
                  : ((o = new oa(t)), this._consumables.set(t, o)),
                o.add(e));
          }
          test(t, e) {
            const o = this._consumables.get(t);
            return void 0 === o ? null : t.is('text') || t.is('documentFragment') ? o : o.test(e);
          }
          consume(t, e) {
            return (
              !!this.test(t, e) &&
              (t.is('text') || t.is('documentFragment')
                ? this._consumables.set(t, !1)
                : this._consumables.get(t).consume(e),
              !0)
            );
          }
          revert(t, e) {
            const o = this._consumables.get(t);
            void 0 !== o && (t.is('text') || t.is('documentFragment') ? this._consumables.set(t, !0) : o.revert(e));
          }
          static consumablesFromElement(t) {
            const e = { element: t, name: !0, attributes: [], classes: [], styles: [] },
              o = t.getAttributeKeys();
            for (const t of o) 'style' != t && 'class' != t && e.attributes.push(t);
            const i = t.getClassNames();
            for (const t of i) e.classes.push(t);
            const n = t.getStyleNames();
            for (const t of n) e.styles.push(t);
            return e;
          }
          static createFrom(t, e) {
            if ((e || (e = new ea(t)), t.is('text'))) return e.add(t), e;
            t.is('element') && e.add(t, ea.consumablesFromElement(t)), t.is('documentFragment') && e.add(t);
            for (const o of t.getChildren()) e = ea.createFrom(o, e);
            return e;
          }
        }
        class oa {
          constructor(t) {
            (this.element = t),
              (this._canConsumeName = null),
              (this._consumables = { attributes: new Map(), styles: new Map(), classes: new Map() });
          }
          add(t) {
            t.name && (this._canConsumeName = !0);
            for (const e in this._consumables) e in t && this._add(e, t[e]);
          }
          test(t) {
            if (t.name && !this._canConsumeName) return this._canConsumeName;
            for (const e in this._consumables)
              if (e in t) {
                const o = this._test(e, t[e]);
                if (!0 !== o) return o;
              }
            return !0;
          }
          consume(t) {
            t.name && (this._canConsumeName = !1);
            for (const e in this._consumables) e in t && this._consume(e, t[e]);
          }
          revert(t) {
            t.name && (this._canConsumeName = !0);
            for (const e in this._consumables) e in t && this._revert(e, t[e]);
          }
          _add(t, e) {
            const o = Vt(e) ? e : [e],
              i = this._consumables[t];
            for (const e of o) {
              if ('attributes' === t && ('class' === e || 'style' === e))
                throw new uo.b(
                  'viewconsumable-invalid-attribute: Classes and styles should be handled separately.',
                  this
                );
              if ((i.set(e, !0), 'styles' === t))
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) i.set(t, !0);
            }
          }
          _test(t, e) {
            const o = Vt(e) ? e : [e],
              i = this._consumables[t];
            for (const e of o)
              if ('attributes' !== t || ('class' !== e && 'style' !== e)) {
                const t = i.get(e);
                if (void 0 === t) return null;
                if (!t) return !1;
              } else {
                const t = 'class' == e ? 'classes' : 'styles',
                  o = this._test(t, [...this._consumables[t].keys()]);
                if (!0 !== o) return o;
              }
            return !0;
          }
          _consume(t, e) {
            const o = Vt(e) ? e : [e],
              i = this._consumables[t];
            for (const e of o)
              if ('attributes' !== t || ('class' !== e && 'style' !== e)) {
                if ((i.set(e, !1), 'styles' == t))
                  for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) i.set(t, !1);
              } else {
                const t = 'class' == e ? 'classes' : 'styles';
                this._consume(t, [...this._consumables[t].keys()]);
              }
          }
          _revert(t, e) {
            const o = Vt(e) ? e : [e],
              i = this._consumables[t];
            for (const e of o)
              if ('attributes' !== t || ('class' !== e && 'style' !== e)) {
                !1 === i.get(e) && i.set(e, !0);
              } else {
                const t = 'class' == e ? 'classes' : 'styles';
                this._revert(t, [...this._consumables[t].keys()]);
              }
          }
        }
        class ia {
          constructor() {
            (this._sourceDefinitions = {}),
              (this._attributeProperties = {}),
              this.decorate('checkChild'),
              this.decorate('checkAttribute'),
              this.on(
                'checkAttribute',
                (t, e) => {
                  e[0] = new na(e[0]);
                },
                { priority: 'highest' }
              ),
              this.on(
                'checkChild',
                (t, e) => {
                  (e[0] = new na(e[0])), (e[1] = this.getDefinition(e[1]));
                },
                { priority: 'highest' }
              );
          }
          register(t, e) {
            if (this._sourceDefinitions[t])
              throw new uo.b(
                'schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.',
                this,
                { itemName: t }
              );
            (this._sourceDefinitions[t] = [Object.assign({}, e)]), this._clearCache();
          }
          extend(t, e) {
            if (!this._sourceDefinitions[t])
              throw new uo.b(
                'schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.',
                this,
                { itemName: t }
              );
            this._sourceDefinitions[t].push(Object.assign({}, e)), this._clearCache();
          }
          getDefinitions() {
            return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
          }
          getDefinition(t) {
            let e;
            return (
              (e = 'string' == typeof t ? t : t.is && (t.is('text') || t.is('textProxy')) ? '$text' : t.name),
              this.getDefinitions()[e]
            );
          }
          isRegistered(t) {
            return !!this.getDefinition(t);
          }
          isBlock(t) {
            const e = this.getDefinition(t);
            return !(!e || !e.isBlock);
          }
          isLimit(t) {
            const e = this.getDefinition(t);
            return !!e && !(!e.isLimit && !e.isObject);
          }
          isObject(t) {
            const e = this.getDefinition(t);
            return !(!e || !e.isObject);
          }
          isInline(t) {
            const e = this.getDefinition(t);
            return !(!e || !e.isInline);
          }
          checkChild(t, e) {
            return !!e && this._checkContextMatch(e, t);
          }
          checkAttribute(t, e) {
            const o = this.getDefinition(t.last);
            return !!o && o.allowAttributes.includes(e);
          }
          checkMerge(t, e = null) {
            if (t instanceof ks) {
              const e = t.nodeBefore,
                o = t.nodeAfter;
              if (!(e instanceof ps))
                throw new uo.b(
                  'schema-check-merge-no-element-before: The node before the merge position must be an element.',
                  this
                );
              if (!(o instanceof ps))
                throw new uo.b(
                  'schema-check-merge-no-element-after: The node after the merge position must be an element.',
                  this
                );
              return this.checkMerge(e, o);
            }
            for (const o of e.getChildren()) if (!this.checkChild(t, o)) return !1;
            return !0;
          }
          addChildCheck(t) {
            this.on(
              'checkChild',
              (e, [o, i]) => {
                if (!i) return;
                const n = t(o, i);
                'boolean' == typeof n && (e.stop(), (e.return = n));
              },
              { priority: 'high' }
            );
          }
          addAttributeCheck(t) {
            this.on(
              'checkAttribute',
              (e, [o, i]) => {
                const n = t(o, i);
                'boolean' == typeof n && (e.stop(), (e.return = n));
              },
              { priority: 'high' }
            );
          }
          setAttributeProperties(t, e) {
            this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e);
          }
          getAttributeProperties(t) {
            return this._attributeProperties[t] || {};
          }
          getLimitElement(t) {
            let e;
            if (t instanceof ks) e = t.parent;
            else {
              e = (t instanceof xs ? [t] : Array.from(t.getRanges())).reduce((t, e) => {
                const o = e.getCommonAncestor();
                return t ? t.getCommonAncestor(o, { includeSelf: !0 }) : o;
              }, null);
            }
            for (; !this.isLimit(e) && e.parent; ) e = e.parent;
            return e;
          }
          checkAttributeInSelection(t, e) {
            if (t.isCollapsed) {
              const o = [...t.getFirstPosition().getAncestors(), new gs('', t.getAttributes())];
              return this.checkAttribute(o, e);
            }
            {
              const o = t.getRanges();
              for (const t of o) for (const o of t) if (this.checkAttribute(o.item, e)) return !0;
            }
            return !1;
          }
          *getValidRanges(t, e) {
            t = (function* (t) {
              for (const e of t) yield* e.getMinimalFlatRanges();
            })(t);
            for (const o of t) yield* this._getValidRangesForRange(o, e);
          }
          getNearestSelectionRange(t, e = 'both') {
            if (this.checkChild(t, '$text')) return new xs(t);
            let o, i;
            const n =
              t
                .getAncestors()
                .reverse()
                .find(t => this.isLimit(t)) || t.root;
            ('both' != e && 'backward' != e) ||
              (o = new bs({ boundaries: xs._createIn(n), startPosition: t, direction: 'backward' })),
              ('both' != e && 'forward' != e) || (i = new bs({ boundaries: xs._createIn(n), startPosition: t }));
            for (const t of (function* (t, e) {
              let o = !1;
              for (; !o; ) {
                if (((o = !0), t)) {
                  const e = t.next();
                  e.done || ((o = !1), yield { walker: t, value: e.value });
                }
                if (e) {
                  const t = e.next();
                  t.done || ((o = !1), yield { walker: e, value: t.value });
                }
              }
            })(o, i)) {
              const e = t.walker == o ? 'elementEnd' : 'elementStart',
                i = t.value;
              if (i.type == e && this.isObject(i.item)) return xs._createOn(i.item);
              if (this.checkChild(i.nextPosition, '$text')) return new xs(i.nextPosition);
            }
            return null;
          }
          findAllowedParent(t, e) {
            let o = t.parent;
            for (; o; ) {
              if (this.checkChild(o, e)) return o;
              if (this.isLimit(o)) return null;
              o = o.parent;
            }
            return null;
          }
          removeDisallowedAttributes(t, e) {
            for (const o of t)
              if (o.is('text')) fa(this, o, e);
              else {
                const t = xs._createIn(o).getPositions();
                for (const o of t) {
                  fa(this, o.nodeBefore || o.parent, e);
                }
              }
          }
          createContext(t) {
            return new na(t);
          }
          _clearCache() {
            this._compiledDefinitions = null;
          }
          _compile() {
            const t = {},
              e = this._sourceDefinitions,
              o = Object.keys(e);
            for (const i of o) t[i] = ra(e[i], i);
            for (const e of o) sa(t, e);
            for (const e of o) aa(t, e);
            for (const e of o) la(t, e), ca(t, e);
            for (const e of o) da(t, e), ha(t, e);
            this._compiledDefinitions = t;
          }
          _checkContextMatch(t, e, o = e.length - 1) {
            const i = e.getItem(o);
            if (t.allowIn.includes(i.name)) {
              if (0 == o) return !0;
              {
                const t = this.getDefinition(i);
                return this._checkContextMatch(t, e, o - 1);
              }
            }
            return !1;
          }
          *_getValidRangesForRange(t, e) {
            let o = t.start,
              i = t.start;
            for (const n of t.getItems({ shallow: !0 }))
              n.is('element') && (yield* this._getValidRangesForRange(xs._createIn(n), e)),
                this.checkAttribute(n, e) || (o.isEqual(i) || (yield new xs(o, i)), (o = ks._createAfter(n))),
                (i = ks._createAfter(n));
            o.isEqual(i) || (yield new xs(o, i));
          }
        }
        xo(ia, Hi);
        class na {
          constructor(t) {
            if (t instanceof na) return t;
            'string' == typeof t ? (t = [t]) : Array.isArray(t) || (t = t.getAncestors({ includeSelf: !0 })),
              t[0] && 'string' != typeof t[0] && t[0].is('documentFragment') && t.shift(),
              (this._items = t.map(ma));
          }
          get length() {
            return this._items.length;
          }
          get last() {
            return this._items[this._items.length - 1];
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
          push(t) {
            const e = new na([t]);
            return (e._items = [...this._items, ...e._items]), e;
          }
          getItem(t) {
            return this._items[t];
          }
          *getNames() {
            yield* this._items.map(t => t.name);
          }
          endsWith(t) {
            return Array.from(this.getNames()).join(' ').endsWith(t);
          }
          startsWith(t) {
            return Array.from(this.getNames()).join(' ').startsWith(t);
          }
        }
        function ra(t, e) {
          const o = {
            name: e,
            allowIn: [],
            allowContentOf: [],
            allowWhere: [],
            allowAttributes: [],
            allowAttributesOf: [],
            inheritTypesFrom: [],
          };
          return (
            (function (t, e) {
              for (const o of t) {
                const t = Object.keys(o).filter(t => t.startsWith('is'));
                for (const i of t) e[i] = o[i];
              }
            })(t, o),
            ua(t, o, 'allowIn'),
            ua(t, o, 'allowContentOf'),
            ua(t, o, 'allowWhere'),
            ua(t, o, 'allowAttributes'),
            ua(t, o, 'allowAttributesOf'),
            ua(t, o, 'inheritTypesFrom'),
            (function (t, e) {
              for (const o of t) {
                const t = o.inheritAllFrom;
                t &&
                  (e.allowContentOf.push(t),
                  e.allowWhere.push(t),
                  e.allowAttributesOf.push(t),
                  e.inheritTypesFrom.push(t));
              }
            })(t, o),
            o
          );
        }
        function sa(t, e) {
          for (const o of t[e].allowContentOf)
            if (t[o]) {
              ga(t, o).forEach(t => {
                t.allowIn.push(e);
              });
            }
          delete t[e].allowContentOf;
        }
        function aa(t, e) {
          for (const o of t[e].allowWhere) {
            const i = t[o];
            if (i) {
              const o = i.allowIn;
              t[e].allowIn.push(...o);
            }
          }
          delete t[e].allowWhere;
        }
        function la(t, e) {
          for (const o of t[e].allowAttributesOf) {
            const i = t[o];
            if (i) {
              const o = i.allowAttributes;
              t[e].allowAttributes.push(...o);
            }
          }
          delete t[e].allowAttributesOf;
        }
        function ca(t, e) {
          const o = t[e];
          for (const e of o.inheritTypesFrom) {
            const i = t[e];
            if (i) {
              const t = Object.keys(i).filter(t => t.startsWith('is'));
              for (const e of t) e in o || (o[e] = i[e]);
            }
          }
          delete o.inheritTypesFrom;
        }
        function da(t, e) {
          const o = t[e],
            i = o.allowIn.filter(e => t[e]);
          o.allowIn = Array.from(new Set(i));
        }
        function ha(t, e) {
          const o = t[e];
          o.allowAttributes = Array.from(new Set(o.allowAttributes));
        }
        function ua(t, e, o) {
          for (const i of t) 'string' == typeof i[o] ? e[o].push(i[o]) : Array.isArray(i[o]) && e[o].push(...i[o]);
        }
        function ga(t, e) {
          const o = t[e];
          return ((i = t), Object.keys(i).map(t => i[t])).filter(t => t.allowIn.includes(o.name));
          var i;
        }
        function ma(t) {
          return 'string' == typeof t
            ? { name: t, *getAttributeKeys() {}, getAttribute() {} }
            : {
                name: t.is('element') ? t.name : '$text',
                *getAttributeKeys() {
                  yield* t.getAttributeKeys();
                },
                getAttribute: e => t.getAttribute(e),
              };
        }
        function fa(t, e, o) {
          for (const i of e.getAttributeKeys()) t.checkAttribute(e, i) || o.removeAttribute(i, e);
        }
        class pa {
          constructor(t = {}) {
            (this._splitParts = new Map()),
              (this._modelCursor = null),
              (this.conversionApi = Object.assign({}, t)),
              (this.conversionApi.convertItem = this._convertItem.bind(this)),
              (this.conversionApi.convertChildren = this._convertChildren.bind(this)),
              (this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this)),
              (this.conversionApi.getSplitParts = this._getSplitParts.bind(this));
          }
          convert(t, e, o = ['$root']) {
            this.fire('viewCleanup', t),
              (this._modelCursor = (function (t, e) {
                let o;
                for (const i of new na(t)) {
                  const t = {};
                  for (const e of i.getAttributeKeys()) t[e] = i.getAttribute(e);
                  const n = e.createElement(i.name, t);
                  o && e.append(n, o), (o = ks._createAt(n, 0));
                }
                return o;
              })(o, e)),
              (this.conversionApi.writer = e),
              (this.conversionApi.consumable = ea.createFrom(t)),
              (this.conversionApi.store = {});
            const { modelRange: i } = this._convertItem(t, this._modelCursor),
              n = e.createDocumentFragment();
            if (i) {
              this._removeEmptyElements();
              for (const t of Array.from(this._modelCursor.parent.getChildren())) e.append(t, n);
              n.markers = (function (t, e) {
                const o = new Set(),
                  i = new Map(),
                  n = xs._createIn(t).getItems();
                for (const t of n) '$marker' == t.name && o.add(t);
                for (const t of o) {
                  const o = t.getAttribute('data-name'),
                    n = e.createPositionBefore(t);
                  i.has(o) ? (i.get(o).end = n.clone()) : i.set(o, new xs(n.clone())), e.remove(t);
                }
                return i;
              })(n, e);
            }
            return (
              (this._modelCursor = null),
              this._splitParts.clear(),
              (this.conversionApi.writer = null),
              (this.conversionApi.store = null),
              n
            );
          }
          _convertItem(t, e) {
            const o = Object.assign({ viewItem: t, modelCursor: e, modelRange: null });
            if (
              (t.is('element')
                ? this.fire('element:' + t.name, o, this.conversionApi)
                : t.is('text')
                ? this.fire('text', o, this.conversionApi)
                : this.fire('documentFragment', o, this.conversionApi),
              o.modelRange && !(o.modelRange instanceof xs))
            )
              throw new uo.b(
                'view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.',
                this
              );
            return { modelRange: o.modelRange, modelCursor: o.modelCursor };
          }
          _convertChildren(t, e) {
            const o = new xs(e);
            let i = e;
            for (const e of Array.from(t.getChildren())) {
              const t = this._convertItem(e, i);
              t.modelRange instanceof xs && ((o.end = t.modelRange.end), (i = t.modelCursor));
            }
            return { modelRange: o, modelCursor: i };
          }
          _splitToAllowedParent(t, e) {
            const o = this.conversionApi.schema.findAllowedParent(e, t);
            if (!o) return null;
            if (o === e.parent) return { position: e };
            if (this._modelCursor.parent.getAncestors().includes(o)) return null;
            const i = this.conversionApi.writer.split(e, o),
              n = [];
            for (const t of i.range.getWalker())
              if ('elementEnd' == t.type) n.push(t.item);
              else {
                const e = n.pop(),
                  o = t.item;
                this._registerSplitPair(e, o);
              }
            return { position: i.position, cursorParent: i.range.end.parent };
          }
          _registerSplitPair(t, e) {
            this._splitParts.has(t) || this._splitParts.set(t, [t]);
            const o = this._splitParts.get(t);
            this._splitParts.set(e, o), o.push(e);
          }
          _getSplitParts(t) {
            let e;
            return (e = this._splitParts.has(t) ? this._splitParts.get(t) : [t]), e;
          }
          _removeEmptyElements() {
            let t = !1;
            for (const e of this._splitParts.keys())
              e.isEmpty && (this.conversionApi.writer.remove(e), this._splitParts.delete(e), (t = !0));
            t && this._removeEmptyElements();
          }
        }
        xo(pa, fo);
        class ba {
          constructor(t, e) {
            (this.model = t),
              (this.stylesProcessor = e),
              this.processor,
              (this.mapper = new Cs()),
              (this.downcastDispatcher = new Ss({ mapper: this.mapper })),
              this.downcastDispatcher.on(
                'insert:$text',
                (t, e, o) => {
                  if (!o.consumable.consume(e.item, 'insert')) return;
                  const i = o.writer,
                    n = o.mapper.toViewPosition(e.range.start),
                    r = i.createText(e.item.data);
                  i.insert(n, r);
                },
                { priority: 'lowest' }
              ),
              (this.upcastDispatcher = new pa({ schema: t.schema })),
              (this.viewDocument = new rn(e)),
              (this._viewWriter = new Cn(this.viewDocument)),
              this.upcastDispatcher.on(
                'text',
                (t, e, o) => {
                  if (o.schema.checkChild(e.modelCursor, '$text') && o.consumable.consume(e.viewItem)) {
                    const t = o.writer.createText(e.viewItem.data);
                    o.writer.insert(t, e.modelCursor),
                      (e.modelRange = xs._createFromPositionAndShift(e.modelCursor, t.offsetSize)),
                      (e.modelCursor = e.modelRange.end);
                  }
                },
                { priority: 'lowest' }
              ),
              this.upcastDispatcher.on(
                'element',
                (t, e, o) => {
                  if (!e.modelRange && o.consumable.consume(e.viewItem, { name: !0 })) {
                    const { modelRange: t, modelCursor: i } = o.convertChildren(e.viewItem, e.modelCursor);
                    (e.modelRange = t), (e.modelCursor = i);
                  }
                },
                { priority: 'lowest' }
              ),
              this.upcastDispatcher.on(
                'documentFragment',
                (t, e, o) => {
                  if (!e.modelRange && o.consumable.consume(e.viewItem, { name: !0 })) {
                    const { modelRange: t, modelCursor: i } = o.convertChildren(e.viewItem, e.modelCursor);
                    (e.modelRange = t), (e.modelCursor = i);
                  }
                },
                { priority: 'lowest' }
              ),
              this.decorate('init'),
              this.on(
                'init',
                () => {
                  this.fire('ready');
                },
                { priority: 'lowest' }
              );
          }
          get(t) {
            const { rootName: e = 'main', trim: o = 'empty' } = t || {};
            if (!this._checkIfRootsExists([e]))
              throw new uo.b(
                'datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.',
                this
              );
            const i = this.model.document.getRoot(e);
            return 'empty' !== o || this.model.hasContent(i, { ignoreWhitespaces: !0 }) ? this.stringify(i) : '';
          }
          stringify(t) {
            const e = this.toView(t);
            return this.processor.toData(e);
          }
          toView(t) {
            const e = this.viewDocument,
              o = this._viewWriter;
            this.mapper.clearBindings();
            const i = xs._createIn(t),
              n = new xn(e);
            if (
              (this.mapper.bindElements(t, n), this.downcastDispatcher.convertInsert(i, o), !t.is('documentFragment'))
            ) {
              const e = (function (t) {
                const e = [],
                  o = t.root.document;
                if (!o) return [];
                const i = xs._createIn(t);
                for (const t of o.model.markers) {
                  const o = i.getIntersection(t.getRange());
                  o && e.push([t.name, o]);
                }
                return e;
              })(t);
              for (const [t, i] of e) this.downcastDispatcher.convertMarkerAdd(t, i, o);
            }
            return n;
          }
          init(t) {
            if (this.model.document.version)
              throw new uo.b(
                'datacontroller-init-document-not-empty: Trying to set initial data to not empty document.',
                this
              );
            let e = {};
            if (('string' == typeof t ? (e.main = t) : (e = t), !this._checkIfRootsExists(Object.keys(e))))
              throw new uo.b(
                'datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.',
                this
              );
            return (
              this.model.enqueueChange('transparent', t => {
                for (const o of Object.keys(e)) {
                  const i = this.model.document.getRoot(o);
                  t.insert(this.parse(e[o], i), i, 0);
                }
              }),
              Promise.resolve()
            );
          }
          set(t) {
            let e = {};
            if (('string' == typeof t ? (e.main = t) : (e = t), !this._checkIfRootsExists(Object.keys(e))))
              throw new uo.b(
                'datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.',
                this
              );
            this.model.enqueueChange('transparent', t => {
              t.setSelection(null), t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
              for (const o of Object.keys(e)) {
                const i = this.model.document.getRoot(o);
                t.remove(t.createRangeIn(i)), t.insert(this.parse(e[o], i), i, 0);
              }
            });
          }
          parse(t, e = '$root') {
            const o = this.processor.toView(t);
            return this.toModel(o, e);
          }
          toModel(t, e = '$root') {
            return this.model.change(o => this.upcastDispatcher.convert(t, o, e));
          }
          addStyleProcessorRules(t) {
            t(this.stylesProcessor);
          }
          destroy() {
            this.stopListening();
          }
          _checkIfRootsExists(t) {
            for (const e of t) if (!this.model.document.getRootNames().includes(e)) return !1;
            return !0;
          }
        }
        xo(ba, Hi);
        class wa {
          constructor(t, e) {
            (this._helpers = new Map()),
              (this._downcast = Array.isArray(t) ? t : [t]),
              this._createConversionHelpers({ name: 'downcast', dispatchers: this._downcast, isDowncast: !0 }),
              (this._upcast = Array.isArray(e) ? e : [e]),
              this._createConversionHelpers({ name: 'upcast', dispatchers: this._upcast, isDowncast: !1 });
          }
          addAlias(t, e) {
            const o = this._downcast.includes(e);
            if (!this._upcast.includes(e) && !o)
              throw new uo.b(
                'conversion-add-alias-dispatcher-not-registered: Trying to register and alias for a dispatcher that nas not been registered.',
                this
              );
            this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: o });
          }
          for(t) {
            if (!this._helpers.has(t))
              throw new uo.b(
                'conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.',
                this
              );
            return this._helpers.get(t);
          }
          elementToElement(t) {
            this.for('downcast').elementToElement(t);
            for (const { model: e, view: o } of ka(t))
              this.for('upcast').elementToElement({ model: e, view: o, converterPriority: t.converterPriority });
          }
          attributeToElement(t) {
            this.for('downcast').attributeToElement(t);
            for (const { model: e, view: o } of ka(t))
              this.for('upcast').elementToAttribute({ view: o, model: e, converterPriority: t.converterPriority });
          }
          attributeToAttribute(t) {
            this.for('downcast').attributeToAttribute(t);
            for (const { model: e, view: o } of ka(t)) this.for('upcast').attributeToAttribute({ view: o, model: e });
          }
          _createConversionHelpers({ name: t, dispatchers: e, isDowncast: o }) {
            if (this._helpers.has(t))
              throw new uo.b(
                'conversion-group-exists: Trying to register a group name that has already been registered.',
                this
              );
            const i = o ? new Hs(e) : new $s(e);
            this._helpers.set(t, i);
          }
        }
        function* ka(t) {
          if (t.model.values)
            for (const e of t.model.values) {
              const o = { key: t.model.key, value: e },
                i = t.view[e],
                n = t.upcastAlso ? t.upcastAlso[e] : void 0;
              yield* _a(o, i, n);
            }
          else yield* _a(t.model, t.view, t.upcastAlso);
        }
        function* _a(t, e, o) {
          if ((yield { model: t, view: e }, o)) {
            o = Array.isArray(o) ? o : [o];
            for (const e of o) yield { model: t, view: e };
          }
        }
        class va {
          constructor(t = 'default') {
            (this.operations = []), (this.type = t);
          }
          get baseVersion() {
            for (const t of this.operations) if (null !== t.baseVersion) return t.baseVersion;
            return null;
          }
          addOperation(t) {
            return (t.batch = this), this.operations.push(t), t;
          }
        }
        class ya {
          constructor(t) {
            (this.baseVersion = t), (this.isDocumentOperation = null !== this.baseVersion), (this.batch = null);
          }
          _validate() {}
          toJSON() {
            const t = Object.assign({}, this);
            return (t.__className = this.constructor.className), delete t.batch, delete t.isDocumentOperation, t;
          }
          static get className() {
            return 'Operation';
          }
          static fromJSON(t) {
            return new this(t.baseVersion);
          }
        }
        class xa {
          constructor(t) {
            (this.markers = new Map()), (this._children = new fs()), t && this._insertChild(0, t);
          }
          [Symbol.iterator]() {
            return this.getChildren();
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          is(t) {
            return 'documentFragment' === t || 'model:documentFragment' === t;
          }
          getChild(t) {
            return this._children.getNode(t);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t) {
            return this._children.getNodeIndex(t);
          }
          getChildStartOffset(t) {
            return this._children.getNodeStartOffset(t);
          }
          getPath() {
            return [];
          }
          getNodeByPath(t) {
            let e = this;
            for (const o of t) e = e.getChild(e.offsetToIndex(o));
            return e;
          }
          offsetToIndex(t) {
            return this._children.offsetToIndex(t);
          }
          toJSON() {
            const t = [];
            for (const e of this._children) t.push(e.toJSON());
            return t;
          }
          static fromJSON(t) {
            const e = [];
            for (const o of t) o.name ? e.push(ps.fromJSON(o)) : e.push(gs.fromJSON(o));
            return new xa(e);
          }
          _appendChild(t) {
            this._insertChild(this.childCount, t);
          }
          _insertChild(t, e) {
            const o = (function (t) {
              if ('string' == typeof t) return [new gs(t)];
              yo(t) || (t = [t]);
              return Array.from(t).map(t =>
                'string' == typeof t ? new gs(t) : t instanceof ms ? new gs(t.data, t.getAttributes()) : t
              );
            })(e);
            for (const t of o) null !== t.parent && t._remove(), (t.parent = this);
            this._children._insertNodes(t, o);
          }
          _removeChildren(t, e = 1) {
            const o = this._children._removeNodes(t, e);
            for (const t of o) t.parent = null;
            return o;
          }
        }
        function Ca(t, e) {
          const o = (e = Sa(e)).reduce((t, e) => t + e.offsetSize, 0),
            i = t.parent;
          Ea(t);
          const n = t.index;
          return i._insertChild(n, e), Pa(i, n + e.length), Pa(i, n), new xs(t, t.getShiftedBy(o));
        }
        function Aa(t) {
          if (!t.isFlat)
            throw new uo.b(
              'operation-utils-remove-range-not-flat: Trying to remove a range which starts and ends in different element.',
              this
            );
          const e = t.start.parent;
          Ea(t.start), Ea(t.end);
          const o = e._removeChildren(t.start.index, t.end.index - t.start.index);
          return Pa(e, t.start.index), o;
        }
        function Ta(t, e) {
          if (!t.isFlat)
            throw new uo.b(
              'operation-utils-move-range-not-flat: Trying to move a range which starts and ends in different element.',
              this
            );
          const o = Aa(t);
          return Ca((e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset)), o);
        }
        function Sa(t) {
          const e = [];
          t instanceof Array || (t = [t]);
          for (let o = 0; o < t.length; o++)
            if ('string' == typeof t[o]) e.push(new gs(t[o]));
            else if (t[o] instanceof ms) e.push(new gs(t[o].data, t[o].getAttributes()));
            else if (t[o] instanceof xa || t[o] instanceof fs) for (const i of t[o]) e.push(i);
            else t[o] instanceof us && e.push(t[o]);
          for (let t = 1; t < e.length; t++) {
            const o = e[t],
              i = e[t - 1];
            o instanceof gs &&
              i instanceof gs &&
              Ma(o, i) &&
              (e.splice(t - 1, 2, new gs(i.data + o.data, i.getAttributes())), t--);
          }
          return e;
        }
        function Pa(t, e) {
          const o = t.getChild(e - 1),
            i = t.getChild(e);
          if (o && i && o.is('text') && i.is('text') && Ma(o, i)) {
            const n = new gs(o.data + i.data, o.getAttributes());
            t._removeChildren(e - 1, 2), t._insertChild(e - 1, n);
          }
        }
        function Ea(t) {
          const e = t.textNode,
            o = t.parent;
          if (e) {
            const i = t.offset - e.startOffset,
              n = e.index;
            o._removeChildren(n, 1);
            const r = new gs(e.data.substr(0, i), e.getAttributes()),
              s = new gs(e.data.substr(i), e.getAttributes());
            o._insertChild(n, [r, s]);
          }
        }
        function Ma(t, e) {
          const o = t.getAttributes(),
            i = e.getAttributes();
          for (const t of o) {
            if (t[1] !== e.getAttribute(t[0])) return !1;
            i.next();
          }
          return i.next().done;
        }
        var Ia = function (t, e) {
          return Pr(t, e);
        };
        class Na extends ya {
          constructor(t, e, o, i, n) {
            super(n),
              (this.range = t.clone()),
              (this.key = e),
              (this.oldValue = void 0 === o ? null : o),
              (this.newValue = void 0 === i ? null : i);
          }
          get type() {
            return null === this.oldValue
              ? 'addAttribute'
              : null === this.newValue
              ? 'removeAttribute'
              : 'changeAttribute';
          }
          clone() {
            return new Na(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Na(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          toJSON() {
            const t = super.toJSON();
            return (t.range = this.range.toJSON()), t;
          }
          _validate() {
            if (!this.range.isFlat)
              throw new uo.b('attribute-operation-range-not-flat: The range to change is not flat.', this);
            for (const t of this.range.getItems({ shallow: !0 })) {
              if (null !== this.oldValue && !Ia(t.getAttribute(this.key), this.oldValue))
                throw new uo.b(
                  "attribute-operation-wrong-old-value: Changed node has different attribute value than operation's old attribute value.",
                  this,
                  { item: t, key: this.key, value: this.oldValue }
                );
              if (null === this.oldValue && null !== this.newValue && t.hasAttribute(this.key))
                throw new uo.b(
                  'attribute-operation-attribute-exists: The attribute with given key already exists.',
                  this,
                  { node: t, key: this.key }
                );
            }
          }
          _execute() {
            Ia(this.oldValue, this.newValue) ||
              (function (t, e, o) {
                Ea(t.start), Ea(t.end);
                for (const i of t.getItems({ shallow: !0 })) {
                  const t = i.is('textProxy') ? i.textNode : i;
                  null !== o ? t._setAttribute(e, o) : t._removeAttribute(e), Pa(t.parent, t.index);
                }
                Pa(t.end.parent, t.end.index);
              })(this.range, this.key, this.newValue);
          }
          static get className() {
            return 'AttributeOperation';
          }
          static fromJSON(t, e) {
            return new Na(xs.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion);
          }
        }
        class Ra extends ya {
          constructor(t, e) {
            super(null), (this.sourcePosition = t.clone()), (this.howMany = e);
          }
          get type() {
            return 'detach';
          }
          toJSON() {
            const t = super.toJSON();
            return (t.sourcePosition = this.sourcePosition.toJSON()), t;
          }
          _validate() {
            if (this.sourcePosition.root.document)
              throw new uo.b('detach-operation-on-document-node: Cannot detach document node.', this);
          }
          _execute() {
            Aa(xs._createFromPositionAndShift(this.sourcePosition, this.howMany));
          }
          static get className() {
            return 'DetachOperation';
          }
        }
        class Oa extends ya {
          constructor(t, e, o, i) {
            super(i),
              (this.sourcePosition = t.clone()),
              (this.sourcePosition.stickiness = 'toNext'),
              (this.howMany = e),
              (this.targetPosition = o.clone()),
              (this.targetPosition.stickiness = 'toNone');
          }
          get type() {
            return '$graveyard' == this.targetPosition.root.rootName
              ? 'remove'
              : '$graveyard' == this.sourcePosition.root.rootName
              ? 'reinsert'
              : 'move';
          }
          clone() {
            return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
          }
          getMovedRangeStart() {
            return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
          }
          getReversed() {
            const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
            return new this.constructor(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1);
          }
          _validate() {
            const t = this.sourcePosition.parent,
              e = this.targetPosition.parent,
              o = this.sourcePosition.offset,
              i = this.targetPosition.offset;
            if (o + this.howMany > t.maxOffset)
              throw new uo.b('move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.', this);
            if (t === e && o < i && i < o + this.howMany)
              throw new uo.b(
                'move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.',
                this
              );
            if (
              this.sourcePosition.root == this.targetPosition.root &&
              'prefix' == Io(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (this.targetPosition.path[t] >= o && this.targetPosition.path[t] < o + this.howMany)
                throw new uo.b(
                  'move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.',
                  this
                );
            }
          }
          _execute() {
            Ta(xs._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.sourcePosition = this.sourcePosition.toJSON()), (t.targetPosition = this.targetPosition.toJSON()), t
            );
          }
          static get className() {
            return 'MoveOperation';
          }
          static fromJSON(t, e) {
            const o = ks.fromJSON(t.sourcePosition, e),
              i = ks.fromJSON(t.targetPosition, e);
            return new this(o, t.howMany, i, t.baseVersion);
          }
        }
        class Va extends ya {
          constructor(t, e, o) {
            super(o),
              (this.position = t.clone()),
              (this.position.stickiness = 'toNone'),
              (this.nodes = new fs(Sa(e))),
              (this.shouldReceiveAttributes = !1);
          }
          get type() {
            return 'insert';
          }
          get howMany() {
            return this.nodes.maxOffset;
          }
          clone() {
            const t = new fs([...this.nodes].map(t => t._clone(!0))),
              e = new Va(this.position, t, this.baseVersion);
            return (e.shouldReceiveAttributes = this.shouldReceiveAttributes), e;
          }
          getReversed() {
            const t = this.position.root.document.graveyard,
              e = new ks(t, [0]);
            return new Oa(this.position, this.nodes.maxOffset, e, this.baseVersion + 1);
          }
          _validate() {
            const t = this.position.parent;
            if (!t || t.maxOffset < this.position.offset)
              throw new uo.b('insert-operation-position-invalid: Insertion position is invalid.', this);
          }
          _execute() {
            const t = this.nodes;
            (this.nodes = new fs([...t].map(t => t._clone(!0)))), Ca(this.position, t);
          }
          toJSON() {
            const t = super.toJSON();
            return (t.position = this.position.toJSON()), (t.nodes = this.nodes.toJSON()), t;
          }
          static get className() {
            return 'InsertOperation';
          }
          static fromJSON(t, e) {
            const o = [];
            for (const e of t.nodes) e.name ? o.push(ps.fromJSON(e)) : o.push(gs.fromJSON(e));
            const i = new Va(ks.fromJSON(t.position, e), o, t.baseVersion);
            return (i.shouldReceiveAttributes = t.shouldReceiveAttributes), i;
          }
        }
        class Da extends ya {
          constructor(t, e, o, i, n, r) {
            super(r),
              (this.name = t),
              (this.oldRange = e ? e.clone() : null),
              (this.newRange = o ? o.clone() : null),
              (this.affectsData = n),
              (this._markers = i);
          }
          get type() {
            return 'marker';
          }
          clone() {
            return new Da(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
          }
          getReversed() {
            return new Da(
              this.name,
              this.newRange,
              this.oldRange,
              this._markers,
              this.affectsData,
              this.baseVersion + 1
            );
          }
          _execute() {
            const t = this.newRange ? '_set' : '_remove';
            this._markers[t](this.name, this.newRange, !0, this.affectsData);
          }
          toJSON() {
            const t = super.toJSON();
            return (
              this.oldRange && (t.oldRange = this.oldRange.toJSON()),
              this.newRange && (t.newRange = this.newRange.toJSON()),
              delete t._markers,
              t
            );
          }
          static get className() {
            return 'MarkerOperation';
          }
          static fromJSON(t, e) {
            return new Da(
              t.name,
              t.oldRange ? xs.fromJSON(t.oldRange, e) : null,
              t.newRange ? xs.fromJSON(t.newRange, e) : null,
              e.model.markers,
              t.affectsData,
              t.baseVersion
            );
          }
        }
        class za extends ya {
          constructor(t, e, o, i) {
            super(i),
              (this.position = t),
              (this.position.stickiness = 'toNext'),
              (this.oldName = e),
              (this.newName = o);
          }
          get type() {
            return 'rename';
          }
          clone() {
            return new za(this.position.clone(), this.oldName, this.newName, this.baseVersion);
          }
          getReversed() {
            return new za(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
          }
          _validate() {
            const t = this.position.nodeAfter;
            if (!(t instanceof ps))
              throw new uo.b(
                'rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.',
                this
              );
            if (t.name !== this.oldName)
              throw new uo.b(
                "rename-operation-wrong-name: Element to change has different name than operation's old name.",
                this
              );
          }
          _execute() {
            this.position.nodeAfter.name = this.newName;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.position = this.position.toJSON()), t;
          }
          static get className() {
            return 'RenameOperation';
          }
          static fromJSON(t, e) {
            return new za(ks.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion);
          }
        }
        class La extends ya {
          constructor(t, e, o, i, n) {
            super(n), (this.root = t), (this.key = e), (this.oldValue = o), (this.newValue = i);
          }
          get type() {
            return null === this.oldValue
              ? 'addRootAttribute'
              : null === this.newValue
              ? 'removeRootAttribute'
              : 'changeRootAttribute';
          }
          clone() {
            return new La(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new La(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          _validate() {
            if (this.root != this.root.root || this.root.is('documentFragment'))
              throw new uo.b('rootattribute-operation-not-a-root: The element to change is not a root element.', this, {
                root: this.root,
                key: this.key,
              });
            if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue)
              throw new uo.b(
                "rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation's old attribute value.",
                this,
                { root: this.root, key: this.key }
              );
            if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key))
              throw new uo.b(
                'rootattribute-operation-attribute-exists: The attribute with given key already exists.',
                this,
                { root: this.root, key: this.key }
              );
          }
          _execute() {
            null !== this.newValue
              ? this.root._setAttribute(this.key, this.newValue)
              : this.root._removeAttribute(this.key);
          }
          toJSON() {
            const t = super.toJSON();
            return (t.root = this.root.toJSON()), t;
          }
          static get className() {
            return 'RootAttributeOperation';
          }
          static fromJSON(t, e) {
            if (!e.getRoot(t.root))
              throw new uo.b(
                'rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.',
                this,
                { rootName: t.root }
              );
            return new La(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion);
          }
        }
        class ja extends ya {
          constructor(t, e, o, i, n) {
            super(n),
              (this.sourcePosition = t.clone()),
              (this.sourcePosition.stickiness = 'toPrevious'),
              (this.howMany = e),
              (this.targetPosition = o.clone()),
              (this.targetPosition.stickiness = 'toNext'),
              (this.graveyardPosition = i.clone());
          }
          get type() {
            return 'merge';
          }
          get deletionPosition() {
            return new ks(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
          }
          get movedRange() {
            const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new xs(this.sourcePosition, t);
          }
          clone() {
            return new this.constructor(
              this.sourcePosition,
              this.howMany,
              this.targetPosition,
              this.graveyardPosition,
              this.baseVersion
            );
          }
          getReversed() {
            const t = this.targetPosition._getTransformedByMergeOperation(this),
              e = this.sourcePosition.path.slice(0, -1),
              o = new ks(this.sourcePosition.root, e)._getTransformedByMergeOperation(this),
              i = new Ba(t, this.howMany, this.graveyardPosition, this.baseVersion + 1);
            return (i.insertionPosition = o), i;
          }
          _validate() {
            const t = this.sourcePosition.parent,
              e = this.targetPosition.parent;
            if (!t.parent)
              throw new uo.b('merge-operation-source-position-invalid: Merge source position is invalid.', this);
            if (!e.parent)
              throw new uo.b('merge-operation-target-position-invalid: Merge target position is invalid.', this);
            if (this.howMany != t.maxOffset)
              throw new uo.b(
                'merge-operation-how-many-invalid: Merge operation specifies wrong number of nodes to move.',
                this
              );
          }
          _execute() {
            const t = this.sourcePosition.parent;
            Ta(xs._createIn(t), this.targetPosition), Ta(xs._createOn(t), this.graveyardPosition);
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.sourcePosition = t.sourcePosition.toJSON()),
              (t.targetPosition = t.targetPosition.toJSON()),
              (t.graveyardPosition = t.graveyardPosition.toJSON()),
              t
            );
          }
          static get className() {
            return 'MergeOperation';
          }
          static fromJSON(t, e) {
            const o = ks.fromJSON(t.sourcePosition, e),
              i = ks.fromJSON(t.targetPosition, e),
              n = ks.fromJSON(t.graveyardPosition, e);
            return new this(o, t.howMany, i, n, t.baseVersion);
          }
        }
        class Ba extends ya {
          constructor(t, e, o, i) {
            super(i),
              (this.splitPosition = t.clone()),
              (this.splitPosition.stickiness = 'toNext'),
              (this.howMany = e),
              (this.insertionPosition = Ba.getInsertionPosition(t)),
              (this.insertionPosition.stickiness = 'toNone'),
              (this.graveyardPosition = o ? o.clone() : null),
              this.graveyardPosition && (this.graveyardPosition.stickiness = 'toNext');
          }
          get type() {
            return 'split';
          }
          get moveTargetPosition() {
            const t = this.insertionPosition.path.slice();
            return t.push(0), new ks(this.insertionPosition.root, t);
          }
          get movedRange() {
            const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new xs(this.splitPosition, t);
          }
          clone() {
            const t = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
            return (t.insertionPosition = this.insertionPosition), t;
          }
          getReversed() {
            const t = this.splitPosition.root.document.graveyard,
              e = new ks(t, [0]);
            return new ja(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1);
          }
          _validate() {
            const t = this.splitPosition.parent,
              e = this.splitPosition.offset;
            if (!t || t.maxOffset < e)
              throw new uo.b('split-operation-position-invalid: Split position is invalid.', this);
            if (!t.parent) throw new uo.b('split-operation-split-in-root: Cannot split root element.', this);
            if (this.howMany != t.maxOffset - this.splitPosition.offset)
              throw new uo.b(
                'split-operation-how-many-invalid: Split operation specifies wrong number of nodes to move.',
                this
              );
            if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
              throw new uo.b('split-operation-graveyard-position-invalid: Graveyard position invalid.', this);
          }
          _execute() {
            const t = this.splitPosition.parent;
            if (this.graveyardPosition)
              Ta(xs._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
            else {
              const e = t._clone();
              Ca(this.insertionPosition, e);
            }
            Ta(
              new xs(ks._createAt(t, this.splitPosition.offset), ks._createAt(t, t.maxOffset)),
              this.moveTargetPosition
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.splitPosition = this.splitPosition.toJSON()),
              (t.insertionPosition = this.insertionPosition.toJSON()),
              this.graveyardPosition && (t.graveyardPosition = this.graveyardPosition.toJSON()),
              t
            );
          }
          static get className() {
            return 'SplitOperation';
          }
          static getInsertionPosition(t) {
            const e = t.path.slice(0, -1);
            return e[e.length - 1]++, new ks(t.root, e);
          }
          static fromJSON(t, e) {
            const o = ks.fromJSON(t.splitPosition, e),
              i = ks.fromJSON(t.insertionPosition, e),
              n = t.graveyardPosition ? ks.fromJSON(t.graveyardPosition, e) : null,
              r = new this(o, t.howMany, n, t.baseVersion);
            return (r.insertionPosition = i), r;
          }
        }
        class Fa extends ps {
          constructor(t, e, o = 'main') {
            super(e), (this._document = t), (this.rootName = o);
          }
          get document() {
            return this._document;
          }
          is(t, e) {
            return e
              ? e === this.name &&
                  ('rootElement' === t || 'model:rootElement' === t || 'element' === t || 'model:element' === t)
              : 'rootElement' === t ||
                  'model:rootElement' === t ||
                  'element' === t ||
                  'model:element' === t ||
                  t === this.name ||
                  t === 'model:' + this.name ||
                  'node' === t ||
                  'model:node' === t;
          }
          toJSON() {
            return this.rootName;
          }
        }
        class Ha {
          constructor(t, e) {
            (this.model = t), (this.batch = e);
          }
          createText(t, e) {
            return new gs(t, e);
          }
          createElement(t, e) {
            return new ps(t, e);
          }
          createDocumentFragment() {
            return new xa();
          }
          insert(t, e, o = 0) {
            if ((this._assertWriterUsedCorrectly(), t instanceof gs && '' == t.data)) return;
            const i = ks._createAt(e, o);
            if (t.parent) {
              if (Ya(t.root, i.root)) return void this.move(xs._createOn(t), i);
              if (t.root.document)
                throw new uo.b(
                  'model-writer-insert-forbidden-move: Cannot move a node from a document to a different tree. It is forbidden to move a node that was already in a document outside of it.',
                  this
                );
              this.remove(t);
            }
            const n = i.root.document ? i.root.document.version : null,
              r = new Va(i, t, n);
            if (
              (t instanceof gs && (r.shouldReceiveAttributes = !0),
              this.batch.addOperation(r),
              this.model.applyOperation(r),
              t instanceof xa)
            )
              for (const [e, o] of t.markers) {
                const t = ks._createAt(o.root, 0),
                  n = {
                    range: new xs(o.start._getCombined(t, i), o.end._getCombined(t, i)),
                    usingOperation: !0,
                    affectsData: !0,
                  };
                this.model.markers.has(e) ? this.updateMarker(e, n) : this.addMarker(e, n);
              }
          }
          insertText(t, e, o, i) {
            e instanceof xa || e instanceof ps || e instanceof ks
              ? this.insert(this.createText(t), e, o)
              : this.insert(this.createText(t, e), o, i);
          }
          insertElement(t, e, o, i) {
            e instanceof xa || e instanceof ps || e instanceof ks
              ? this.insert(this.createElement(t), e, o)
              : this.insert(this.createElement(t, e), o, i);
          }
          append(t, e) {
            this.insert(t, e, 'end');
          }
          appendText(t, e, o) {
            e instanceof xa || e instanceof ps
              ? this.insert(this.createText(t), e, 'end')
              : this.insert(this.createText(t, e), o, 'end');
          }
          appendElement(t, e, o) {
            e instanceof xa || e instanceof ps
              ? this.insert(this.createElement(t), e, 'end')
              : this.insert(this.createElement(t, e), o, 'end');
          }
          setAttribute(t, e, o) {
            if ((this._assertWriterUsedCorrectly(), o instanceof xs)) {
              const i = o.getMinimalFlatRanges();
              for (const o of i) Wa(this, t, e, o);
            } else Ua(this, t, e, o);
          }
          setAttributes(t, e) {
            for (const [o, i] of Do(t)) this.setAttribute(o, i, e);
          }
          removeAttribute(t, e) {
            if ((this._assertWriterUsedCorrectly(), e instanceof xs)) {
              const o = e.getMinimalFlatRanges();
              for (const e of o) Wa(this, t, null, e);
            } else Ua(this, t, null, e);
          }
          clearAttributes(t) {
            this._assertWriterUsedCorrectly();
            const e = t => {
              for (const e of t.getAttributeKeys()) this.removeAttribute(e, t);
            };
            if (t instanceof xs) for (const o of t.getItems()) e(o);
            else e(t);
          }
          move(t, e, o) {
            if ((this._assertWriterUsedCorrectly(), !(t instanceof xs)))
              throw new uo.b('writer-move-invalid-range: Invalid range to move.', this);
            if (!t.isFlat) throw new uo.b('writer-move-range-not-flat: Range to move is not flat.', this);
            const i = ks._createAt(e, o);
            if (i.isEqual(t.start)) return;
            if ((this._addOperationForAffectedMarkers('move', t), !Ya(t.root, i.root)))
              throw new uo.b(
                'writer-move-different-document: Range is going to be moved between different documents.',
                this
              );
            const n = t.root.document ? t.root.document.version : null,
              r = new Oa(t.start, t.end.offset - t.start.offset, i, n);
            this.batch.addOperation(r), this.model.applyOperation(r);
          }
          remove(t) {
            this._assertWriterUsedCorrectly();
            const e = (t instanceof xs ? t : xs._createOn(t)).getMinimalFlatRanges().reverse();
            for (const t of e)
              this._addOperationForAffectedMarkers('move', t),
                Ga(t.start, t.end.offset - t.start.offset, this.batch, this.model);
          }
          merge(t) {
            this._assertWriterUsedCorrectly();
            const e = t.nodeBefore,
              o = t.nodeAfter;
            if ((this._addOperationForAffectedMarkers('merge', t), !(e instanceof ps)))
              throw new uo.b('writer-merge-no-element-before: Node before merge position must be an element.', this);
            if (!(o instanceof ps))
              throw new uo.b('writer-merge-no-element-after: Node after merge position must be an element.', this);
            t.root.document ? this._merge(t) : this._mergeDetached(t);
          }
          createPositionFromPath(t, e, o) {
            return this.model.createPositionFromPath(t, e, o);
          }
          createPositionAt(t, e) {
            return this.model.createPositionAt(t, e);
          }
          createPositionAfter(t) {
            return this.model.createPositionAfter(t);
          }
          createPositionBefore(t) {
            return this.model.createPositionBefore(t);
          }
          createRange(t, e) {
            return this.model.createRange(t, e);
          }
          createRangeIn(t) {
            return this.model.createRangeIn(t);
          }
          createRangeOn(t) {
            return this.model.createRangeOn(t);
          }
          createSelection(t, e, o) {
            return this.model.createSelection(t, e, o);
          }
          _mergeDetached(t) {
            const e = t.nodeBefore,
              o = t.nodeAfter;
            this.move(xs._createIn(o), ks._createAt(e, 'end')), this.remove(o);
          }
          _merge(t) {
            const e = ks._createAt(t.nodeBefore, 'end'),
              o = ks._createAt(t.nodeAfter, 0),
              i = t.root.document.graveyard,
              n = new ks(i, [0]),
              r = t.root.document.version,
              s = new ja(o, t.nodeAfter.maxOffset, e, n, r);
            this.batch.addOperation(s), this.model.applyOperation(s);
          }
          rename(t, e) {
            if ((this._assertWriterUsedCorrectly(), !(t instanceof ps)))
              throw new uo.b(
                'writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.',
                this
              );
            const o = t.root.document ? t.root.document.version : null,
              i = new za(ks._createBefore(t), t.name, e, o);
            this.batch.addOperation(i), this.model.applyOperation(i);
          }
          split(t, e) {
            this._assertWriterUsedCorrectly();
            let o,
              i,
              n = t.parent;
            if (!n.parent)
              throw new uo.b('writer-split-element-no-parent: Element with no parent can not be split.', this);
            if ((e || (e = n.parent), !t.parent.getAncestors({ includeSelf: !0 }).includes(e)))
              throw new uo.b('writer-split-invalid-limit-element: Limit element is not a position ancestor.', this);
            do {
              const e = n.root.document ? n.root.document.version : null,
                r = n.maxOffset - t.offset,
                s = new Ba(t, r, null, e);
              this.batch.addOperation(s),
                this.model.applyOperation(s),
                o || i || ((o = n), (i = t.parent.nextSibling)),
                (n = (t = this.createPositionAfter(t.parent)).parent);
            } while (n !== e);
            return { position: t, range: new xs(ks._createAt(o, 'end'), ks._createAt(i, 0)) };
          }
          wrap(t, e) {
            if ((this._assertWriterUsedCorrectly(), !t.isFlat))
              throw new uo.b('writer-wrap-range-not-flat: Range to wrap is not flat.', this);
            const o = e instanceof ps ? e : new ps(e);
            if (o.childCount > 0)
              throw new uo.b('writer-wrap-element-not-empty: Element to wrap with is not empty.', this);
            if (null !== o.parent)
              throw new uo.b(
                'writer-wrap-element-attached: Element to wrap with is already attached to tree model.',
                this
              );
            this.insert(o, t.start);
            const i = new xs(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
            this.move(i, ks._createAt(o, 0));
          }
          unwrap(t) {
            if ((this._assertWriterUsedCorrectly(), null === t.parent))
              throw new uo.b('writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.', this);
            this.move(xs._createIn(t), this.createPositionAfter(t)), this.remove(t);
          }
          addMarker(t, e) {
            if ((this._assertWriterUsedCorrectly(), !e || 'boolean' != typeof e.usingOperation))
              throw new uo.b(
                'writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.',
                this
              );
            const o = e.usingOperation,
              i = e.range,
              n = void 0 !== e.affectsData && e.affectsData;
            if (this.model.markers.has(t))
              throw new uo.b('writer-addMarker-marker-exists: Marker with provided name already exists.', this);
            if (!i)
              throw new uo.b('writer-addMarker-no-range: Range parameter is required when adding a new marker.', this);
            return o ? (qa(this, t, null, i, n), this.model.markers.get(t)) : this.model.markers._set(t, i, o, n);
          }
          updateMarker(t, e) {
            this._assertWriterUsedCorrectly();
            const o = 'string' == typeof t ? t : t.name,
              i = this.model.markers.get(o);
            if (!i)
              throw new uo.b('writer-updateMarker-marker-not-exists: Marker with provided name does not exists.', this);
            if (!e) return void this.model.markers._refresh(i);
            const n = 'boolean' == typeof e.usingOperation,
              r = 'boolean' == typeof e.affectsData,
              s = r ? e.affectsData : i.affectsData;
            if (!n && !e.range && !r)
              throw new uo.b(
                'writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.',
                this
              );
            const a = i.getRange(),
              l = e.range ? e.range : a;
            n && e.usingOperation !== i.managedUsingOperations
              ? e.usingOperation
                ? qa(this, o, null, l, s)
                : (qa(this, o, a, null, s), this.model.markers._set(o, l, void 0, s))
              : i.managedUsingOperations
              ? qa(this, o, a, l, s)
              : this.model.markers._set(o, l, void 0, s);
          }
          removeMarker(t) {
            this._assertWriterUsedCorrectly();
            const e = 'string' == typeof t ? t : t.name;
            if (!this.model.markers.has(e))
              throw new uo.b('writer-removeMarker-no-marker: Trying to remove marker which does not exist.', this);
            const o = this.model.markers.get(e);
            if (!o.managedUsingOperations) return void this.model.markers._remove(e);
            qa(this, e, o.getRange(), null, o.affectsData);
          }
          setSelection(t, e, o) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(t, e, o);
          }
          setSelectionFocus(t, e) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t, e);
          }
          setSelectionAttribute(t, e) {
            if ((this._assertWriterUsedCorrectly(), 'string' == typeof t)) this._setSelectionAttribute(t, e);
            else for (const [e, o] of Do(t)) this._setSelectionAttribute(e, o);
          }
          removeSelectionAttribute(t) {
            if ((this._assertWriterUsedCorrectly(), 'string' == typeof t)) this._removeSelectionAttribute(t);
            else for (const e of t) this._removeSelectionAttribute(e);
          }
          overrideSelectionGravity() {
            return this.model.document.selection._overrideGravity();
          }
          restoreSelectionGravity(t) {
            this.model.document.selection._restoreGravity(t);
          }
          _setSelectionAttribute(t, e) {
            const o = this.model.document.selection;
            if (o.isCollapsed && o.anchor.parent.isEmpty) {
              const i = zs._getStoreAttributeKey(t);
              this.setAttribute(i, e, o.anchor.parent);
            }
            o._setAttribute(t, e);
          }
          _removeSelectionAttribute(t) {
            const e = this.model.document.selection;
            if (e.isCollapsed && e.anchor.parent.isEmpty) {
              const o = zs._getStoreAttributeKey(t);
              this.removeAttribute(o, e.anchor.parent);
            }
            e._removeAttribute(t);
          }
          _assertWriterUsedCorrectly() {
            if (this.model._currentWriter !== this)
              throw new uo.b('writer-incorrect-use: Trying to use a writer outside the change() block.', this);
          }
          _addOperationForAffectedMarkers(t, e) {
            for (const o of this.model.markers) {
              if (!o.managedUsingOperations) continue;
              const i = o.getRange();
              let n = !1;
              if ('move' === t)
                n =
                  e.containsPosition(i.start) ||
                  e.start.isEqual(i.start) ||
                  e.containsPosition(i.end) ||
                  e.end.isEqual(i.end);
              else {
                const t = e.nodeBefore,
                  o = e.nodeAfter,
                  r = i.start.parent == t && i.start.isAtEnd,
                  s = i.end.parent == o && 0 == i.end.offset,
                  a = i.end.nodeAfter == o,
                  l = i.start.nodeAfter == o;
                n = r || s || a || l;
              }
              n && this.updateMarker(o.name, { range: i });
            }
          }
        }
        function Wa(t, e, o, i) {
          const n = t.model,
            r = n.document;
          let s,
            a,
            l,
            c = i.start;
          for (const t of i.getWalker({ shallow: !0 }))
            (l = t.item.getAttribute(e)), s && a != l && (a != o && d(), (c = s)), (s = t.nextPosition), (a = l);
          function d() {
            const i = new xs(c, s),
              l = i.root.document ? r.version : null,
              d = new Na(i, e, a, o, l);
            t.batch.addOperation(d), n.applyOperation(d);
          }
          s instanceof ks && s != c && a != o && d();
        }
        function Ua(t, e, o, i) {
          const n = t.model,
            r = n.document,
            s = i.getAttribute(e);
          let a, l;
          if (s != o) {
            if (i.root === i) {
              const t = i.document ? r.version : null;
              l = new La(i, e, s, o, t);
            } else {
              a = new xs(ks._createBefore(i), t.createPositionAfter(i));
              const n = a.root.document ? r.version : null;
              l = new Na(a, e, s, o, n);
            }
            t.batch.addOperation(l), n.applyOperation(l);
          }
        }
        function qa(t, e, o, i, n) {
          const r = t.model,
            s = r.document,
            a = new Da(e, o, i, r.markers, n, s.version);
          t.batch.addOperation(a), r.applyOperation(a);
        }
        function Ga(t, e, o, i) {
          let n;
          if (t.root.document) {
            const o = i.document,
              r = new ks(o.graveyard, [0]);
            n = new Oa(t, e, r, o.version);
          } else n = new Ra(t, e);
          o.addOperation(n), i.applyOperation(n);
        }
        function Ya(t, e) {
          return t === e || (t instanceof Fa && e instanceof Fa);
        }
        class $a {
          constructor(t) {
            (this._markerCollection = t),
              (this._changesInElement = new Map()),
              (this._elementSnapshots = new Map()),
              (this._changedMarkers = new Map()),
              (this._changeCount = 0),
              (this._cachedChanges = null),
              (this._cachedChangesWithGraveyard = null);
          }
          get isEmpty() {
            return 0 == this._changesInElement.size && 0 == this._changedMarkers.size;
          }
          refreshItem(t) {
            if (this._isInInsertedElement(t.parent)) return;
            this._markRemove(t.parent, t.startOffset, t.offsetSize),
              this._markInsert(t.parent, t.startOffset, t.offsetSize);
            const e = xs._createOn(t);
            for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
              const e = t.getRange();
              this.bufferMarkerChange(t.name, e, e, t.affectsData);
            }
            this._cachedChanges = null;
          }
          bufferOperation(t) {
            switch (t.type) {
              case 'insert':
                if (this._isInInsertedElement(t.position.parent)) return;
                this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                break;
              case 'addAttribute':
              case 'removeAttribute':
              case 'changeAttribute':
                for (const e of t.range.getItems({ shallow: !0 }))
                  this._isInInsertedElement(e.parent) || this._markAttribute(e);
                break;
              case 'remove':
              case 'move':
              case 'reinsert': {
                if (
                  t.sourcePosition.isEqual(t.targetPosition) ||
                  t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)
                )
                  return;
                const e = this._isInInsertedElement(t.sourcePosition.parent),
                  o = this._isInInsertedElement(t.targetPosition.parent);
                e || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany),
                  o || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
                break;
              }
              case 'rename': {
                if (this._isInInsertedElement(t.position.parent)) return;
                this._markRemove(t.position.parent, t.position.offset, 1),
                  this._markInsert(t.position.parent, t.position.offset, 1);
                const e = xs._createFromPositionAndShift(t.position, 1);
                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                  const e = t.getRange();
                  this.bufferMarkerChange(t.name, e, e, t.affectsData);
                }
                break;
              }
              case 'split': {
                const e = t.splitPosition.parent;
                this._isInInsertedElement(e) || this._markRemove(e, t.splitPosition.offset, t.howMany),
                  this._isInInsertedElement(t.insertionPosition.parent) ||
                    this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1),
                  t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
                break;
              }
              case 'merge': {
                const e = t.sourcePosition.parent;
                this._isInInsertedElement(e.parent) || this._markRemove(e.parent, e.startOffset, 1);
                const o = t.graveyardPosition.parent;
                this._markInsert(o, t.graveyardPosition.offset, 1);
                const i = t.targetPosition.parent;
                this._isInInsertedElement(i) || this._markInsert(i, t.targetPosition.offset, e.maxOffset);
                break;
              }
            }
            this._cachedChanges = null;
          }
          bufferMarkerChange(t, e, o, i) {
            const n = this._changedMarkers.get(t);
            n
              ? ((n.newRange = o),
                (n.affectsData = i),
                null == n.oldRange && null == n.newRange && this._changedMarkers.delete(t))
              : this._changedMarkers.set(t, { oldRange: e, newRange: o, affectsData: i });
          }
          getMarkersToRemove() {
            const t = [];
            for (const [e, o] of this._changedMarkers) null != o.oldRange && t.push({ name: e, range: o.oldRange });
            return t;
          }
          getMarkersToAdd() {
            const t = [];
            for (const [e, o] of this._changedMarkers) null != o.newRange && t.push({ name: e, range: o.newRange });
            return t;
          }
          getChangedMarkers() {
            return Array.from(this._changedMarkers).map(t => ({
              name: t[0],
              data: { oldRange: t[1].oldRange, newRange: t[1].newRange },
            }));
          }
          hasDataChanges() {
            for (const [, t] of this._changedMarkers) if (t.affectsData) return !0;
            return this._changesInElement.size > 0;
          }
          getChanges(t = { includeChangesInGraveyard: !1 }) {
            if (this._cachedChanges)
              return t.includeChangesInGraveyard
                ? this._cachedChangesWithGraveyard.slice()
                : this._cachedChanges.slice();
            const e = [];
            for (const t of this._changesInElement.keys()) {
              const o = this._changesInElement
                  .get(t)
                  .sort((t, e) =>
                    t.offset === e.offset
                      ? t.type != e.type
                        ? 'remove' == t.type
                          ? -1
                          : 1
                        : 0
                      : t.offset < e.offset
                      ? -1
                      : 1
                  ),
                i = this._elementSnapshots.get(t),
                n = Qa(t.getChildren()),
                r = Ka(i.length, o);
              let s = 0,
                a = 0;
              for (const o of r)
                if ('i' === o) e.push(this._getInsertDiff(t, s, n[s].name)), s++;
                else if ('r' === o) e.push(this._getRemoveDiff(t, s, i[a].name)), a++;
                else if ('a' === o) {
                  const o = n[s].attributes,
                    r = i[a].attributes;
                  let l;
                  if ('$text' == n[s].name) l = new xs(ks._createAt(t, s), ks._createAt(t, s + 1));
                  else {
                    const e = t.offsetToIndex(s);
                    l = new xs(ks._createAt(t, s), ks._createAt(t.getChild(e), 0));
                  }
                  e.push(...this._getAttributesDiff(l, r, o)), s++, a++;
                } else s++, a++;
            }
            e.sort((t, e) =>
              t.position.root != e.position.root
                ? t.position.root.rootName < e.position.root.rootName
                  ? -1
                  : 1
                : t.position.isEqual(e.position)
                ? t.changeCount - e.changeCount
                : t.position.isBefore(e.position)
                ? -1
                : 1
            );
            for (let t = 1; t < e.length; t++) {
              const o = e[t - 1],
                i = e[t],
                n =
                  'remove' == o.type &&
                  'remove' == i.type &&
                  '$text' == o.name &&
                  '$text' == i.name &&
                  o.position.isEqual(i.position),
                r =
                  'insert' == o.type &&
                  'insert' == i.type &&
                  '$text' == o.name &&
                  '$text' == i.name &&
                  o.position.parent == i.position.parent &&
                  o.position.offset + o.length == i.position.offset,
                s =
                  'attribute' == o.type &&
                  'attribute' == i.type &&
                  o.position.parent == i.position.parent &&
                  o.range.isFlat &&
                  i.range.isFlat &&
                  o.position.offset + o.length == i.position.offset &&
                  o.attributeKey == i.attributeKey &&
                  o.attributeOldValue == i.attributeOldValue &&
                  o.attributeNewValue == i.attributeNewValue;
              (n || r || s) &&
                (e[t - 1].length++,
                s && (e[t - 1].range.end = e[t - 1].range.end.getShiftedBy(1)),
                e.splice(t, 1),
                t--);
            }
            for (const t of e) delete t.changeCount, 'attribute' == t.type && (delete t.position, delete t.length);
            return (
              (this._changeCount = 0),
              (this._cachedChangesWithGraveyard = e.slice()),
              (this._cachedChanges = e.slice().filter(Ja)),
              t.includeChangesInGraveyard ? this._cachedChangesWithGraveyard : this._cachedChanges
            );
          }
          reset() {
            this._changesInElement.clear(),
              this._elementSnapshots.clear(),
              this._changedMarkers.clear(),
              (this._cachedChanges = null);
          }
          _markInsert(t, e, o) {
            const i = { type: 'insert', offset: e, howMany: o, count: this._changeCount++ };
            this._markChange(t, i);
          }
          _markRemove(t, e, o) {
            const i = { type: 'remove', offset: e, howMany: o, count: this._changeCount++ };
            this._markChange(t, i), this._removeAllNestedChanges(t, e, o);
          }
          _markAttribute(t) {
            const e = { type: 'attribute', offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++ };
            this._markChange(t.parent, e);
          }
          _markChange(t, e) {
            this._makeSnapshot(t);
            const o = this._getChangesForElement(t);
            this._handleChange(e, o), o.push(e);
            for (let t = 0; t < o.length; t++) o[t].howMany < 1 && (o.splice(t, 1), t--);
          }
          _getChangesForElement(t) {
            let e;
            return (
              this._changesInElement.has(t)
                ? (e = this._changesInElement.get(t))
                : ((e = []), this._changesInElement.set(t, e)),
              e
            );
          }
          _makeSnapshot(t) {
            this._elementSnapshots.has(t) || this._elementSnapshots.set(t, Qa(t.getChildren()));
          }
          _handleChange(t, e) {
            t.nodesToHandle = t.howMany;
            for (const o of e) {
              const i = t.offset + t.howMany,
                n = o.offset + o.howMany;
              if (
                'insert' == t.type &&
                ('insert' == o.type &&
                  (t.offset <= o.offset
                    ? (o.offset += t.howMany)
                    : t.offset < n && ((o.howMany += t.nodesToHandle), (t.nodesToHandle = 0))),
                'remove' == o.type && t.offset < o.offset && (o.offset += t.howMany),
                'attribute' == o.type)
              )
                if (t.offset <= o.offset) o.offset += t.howMany;
                else if (t.offset < n) {
                  const n = o.howMany;
                  (o.howMany = t.offset - o.offset),
                    e.unshift({ type: 'attribute', offset: i, howMany: n - o.howMany, count: this._changeCount++ });
                }
              if ('remove' == t.type) {
                if ('insert' == o.type)
                  if (i <= o.offset) o.offset -= t.howMany;
                  else if (i <= n)
                    if (t.offset < o.offset) {
                      const e = i - o.offset;
                      (o.offset = t.offset), (o.howMany -= e), (t.nodesToHandle -= e);
                    } else (o.howMany -= t.nodesToHandle), (t.nodesToHandle = 0);
                  else if (t.offset <= o.offset) (t.nodesToHandle -= o.howMany), (o.howMany = 0);
                  else if (t.offset < n) {
                    const e = n - t.offset;
                    (o.howMany -= e), (t.nodesToHandle -= e);
                  }
                if (
                  ('remove' == o.type &&
                    (i <= o.offset
                      ? (o.offset -= t.howMany)
                      : t.offset < o.offset && ((t.nodesToHandle += o.howMany), (o.howMany = 0))),
                  'attribute' == o.type)
                )
                  if (i <= o.offset) o.offset -= t.howMany;
                  else if (t.offset < o.offset) {
                    const e = i - o.offset;
                    (o.offset = t.offset), (o.howMany -= e);
                  } else if (t.offset < n)
                    if (i <= n) {
                      const i = o.howMany;
                      o.howMany = t.offset - o.offset;
                      const n = i - o.howMany - t.nodesToHandle;
                      e.unshift({ type: 'attribute', offset: t.offset, howMany: n, count: this._changeCount++ });
                    } else o.howMany -= n - t.offset;
              }
              if ('attribute' == t.type) {
                if ('insert' == o.type)
                  if (t.offset < o.offset && i > o.offset) {
                    if (i > n) {
                      const t = { type: 'attribute', offset: n, howMany: i - n, count: this._changeCount++ };
                      this._handleChange(t, e), e.push(t);
                    }
                    (t.nodesToHandle = o.offset - t.offset), (t.howMany = t.nodesToHandle);
                  } else
                    t.offset >= o.offset &&
                      t.offset < n &&
                      (i > n ? ((t.nodesToHandle = i - n), (t.offset = n)) : (t.nodesToHandle = 0));
                if ('remove' == o.type && t.offset < o.offset && i > o.offset) {
                  const n = { type: 'attribute', offset: o.offset, howMany: i - o.offset, count: this._changeCount++ };
                  this._handleChange(n, e),
                    e.push(n),
                    (t.nodesToHandle = o.offset - t.offset),
                    (t.howMany = t.nodesToHandle);
                }
                'attribute' == o.type &&
                  (t.offset >= o.offset && i <= n
                    ? ((t.nodesToHandle = 0), (t.howMany = 0), (t.offset = 0))
                    : t.offset <= o.offset && i >= n && (o.howMany = 0));
              }
            }
            (t.howMany = t.nodesToHandle), delete t.nodesToHandle;
          }
          _getInsertDiff(t, e, o) {
            return {
              type: 'insert',
              position: ks._createAt(t, e),
              name: o,
              length: 1,
              changeCount: this._changeCount++,
            };
          }
          _getRemoveDiff(t, e, o) {
            return {
              type: 'remove',
              position: ks._createAt(t, e),
              name: o,
              length: 1,
              changeCount: this._changeCount++,
            };
          }
          _getAttributesDiff(t, e, o) {
            const i = [];
            o = new Map(o);
            for (const [n, r] of e) {
              const e = o.has(n) ? o.get(n) : null;
              e !== r &&
                i.push({
                  type: 'attribute',
                  position: t.start,
                  range: t.clone(),
                  length: 1,
                  attributeKey: n,
                  attributeOldValue: r,
                  attributeNewValue: e,
                  changeCount: this._changeCount++,
                }),
                o.delete(n);
            }
            for (const [e, n] of o)
              i.push({
                type: 'attribute',
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: e,
                attributeOldValue: null,
                attributeNewValue: n,
                changeCount: this._changeCount++,
              });
            return i;
          }
          _isInInsertedElement(t) {
            const e = t.parent;
            if (!e) return !1;
            const o = this._changesInElement.get(e),
              i = t.startOffset;
            if (o) for (const t of o) if ('insert' == t.type && i >= t.offset && i < t.offset + t.howMany) return !0;
            return this._isInInsertedElement(e);
          }
          _removeAllNestedChanges(t, e, o) {
            const i = new xs(ks._createAt(t, e), ks._createAt(t, e + o));
            for (const t of i.getItems({ shallow: !0 }))
              t.is('element') &&
                (this._elementSnapshots.delete(t),
                this._changesInElement.delete(t),
                this._removeAllNestedChanges(t, 0, t.maxOffset));
          }
        }
        function Qa(t) {
          const e = [];
          for (const o of t)
            if (o.is('text'))
              for (let t = 0; t < o.data.length; t++) e.push({ name: '$text', attributes: new Map(o.getAttributes()) });
            else e.push({ name: o.name, attributes: new Map(o.getAttributes()) });
          return e;
        }
        function Ka(t, e) {
          const o = [];
          let i = 0,
            n = 0;
          for (const t of e) {
            if (t.offset > i) {
              for (let e = 0; e < t.offset - i; e++) o.push('e');
              n += t.offset - i;
            }
            if ('insert' == t.type) {
              for (let e = 0; e < t.howMany; e++) o.push('i');
              i = t.offset + t.howMany;
            } else if ('remove' == t.type) {
              for (let e = 0; e < t.howMany; e++) o.push('r');
              (i = t.offset), (n += t.howMany);
            } else o.push(...'a'.repeat(t.howMany).split('')), (i = t.offset + t.howMany), (n += t.howMany);
          }
          if (n < t) for (let e = 0; e < t - n - i; e++) o.push('e');
          return o;
        }
        function Ja(t) {
          const e = t.position && '$graveyard' == t.position.root.rootName,
            o = t.range && '$graveyard' == t.range.root.rootName;
          return !e && !o;
        }
        class Za {
          constructor() {
            (this._operations = []), (this._undoPairs = new Map()), (this._undoneOperations = new Set());
          }
          addOperation(t) {
            this._operations.includes(t) || this._operations.push(t);
          }
          getOperations(t = 0, e = Number.POSITIVE_INFINITY) {
            return t < 0 ? [] : this._operations.slice(t, e);
          }
          getOperation(t) {
            return this._operations[t];
          }
          setOperationAsUndone(t, e) {
            this._undoPairs.set(e, t), this._undoneOperations.add(t);
          }
          isUndoingOperation(t) {
            return this._undoPairs.has(t);
          }
          isUndoneOperation(t) {
            return this._undoneOperations.has(t);
          }
          getUndoneOperation(t) {
            return this._undoPairs.get(t);
          }
        }
        function Xa(t, e) {
          return (
            !!(o = t.charAt(e - 1)) &&
            1 == o.length &&
            /[\ud800-\udbff]/.test(o) &&
            (function (t) {
              return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t);
            })(t.charAt(e))
          );
          var o;
        }
        function tl(t, e) {
          return (
            !!(o = t.charAt(e)) &&
            1 == o.length &&
            /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(o)
          );
          var o;
        }
        class el {
          constructor(t) {
            (this.model = t),
              (this.version = 0),
              (this.history = new Za(this)),
              (this.selection = new zs(this)),
              (this.roots = new Co({ idProperty: 'rootName' })),
              (this.differ = new $a(t.markers)),
              (this._postFixers = new Set()),
              (this._hasSelectionChangedFromTheLastChangeBlock = !1),
              this.createRoot('$root', '$graveyard'),
              this.listenTo(
                t,
                'applyOperation',
                (t, e) => {
                  const o = e[0];
                  if (o.isDocumentOperation && o.baseVersion !== this.version)
                    throw new uo.b(
                      'model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.',
                      this,
                      { operation: o }
                    );
                },
                { priority: 'highest' }
              ),
              this.listenTo(
                t,
                'applyOperation',
                (t, e) => {
                  const o = e[0];
                  o.isDocumentOperation && this.differ.bufferOperation(o);
                },
                { priority: 'high' }
              ),
              this.listenTo(
                t,
                'applyOperation',
                (t, e) => {
                  const o = e[0];
                  o.isDocumentOperation && (this.version++, this.history.addOperation(o));
                },
                { priority: 'low' }
              ),
              this.listenTo(this.selection, 'change', () => {
                this._hasSelectionChangedFromTheLastChangeBlock = !0;
              }),
              this.listenTo(t.markers, 'update', (t, e, o, i) => {
                this.differ.bufferMarkerChange(e.name, o, i, e.affectsData),
                  null === o &&
                    e.on('change', (t, o) => {
                      this.differ.bufferMarkerChange(e.name, o, e.getRange(), e.affectsData);
                    });
              });
          }
          get graveyard() {
            return this.getRoot('$graveyard');
          }
          createRoot(t = '$root', e = 'main') {
            if (this.roots.get(e))
              throw new uo.b('model-document-createRoot-name-exists: Root with specified name already exists.', this, {
                name: e,
              });
            const o = new Fa(this, t, e);
            return this.roots.add(o), o;
          }
          destroy() {
            this.selection.destroy(), this.stopListening();
          }
          getRoot(t = 'main') {
            return this.roots.get(t);
          }
          getRootNames() {
            return Array.from(this.roots, t => t.rootName).filter(t => '$graveyard' != t);
          }
          registerPostFixer(t) {
            this._postFixers.add(t);
          }
          toJSON() {
            const t = No(this);
            return (t.selection = '[engine.model.DocumentSelection]'), (t.model = '[engine.model.Model]'), t;
          }
          _handleChangeBlock(t) {
            this._hasDocumentChangedFromTheLastChangeBlock() &&
              (this._callPostFixers(t),
              this.selection.refresh(),
              this.differ.hasDataChanges() ? this.fire('change:data', t.batch) : this.fire('change', t.batch),
              this.selection.refresh(),
              this.differ.reset()),
              (this._hasSelectionChangedFromTheLastChangeBlock = !1);
          }
          _hasDocumentChangedFromTheLastChangeBlock() {
            return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
          }
          _getDefaultRoot() {
            for (const t of this.roots) if (t !== this.graveyard) return t;
            return this.graveyard;
          }
          _getDefaultRange() {
            const t = this._getDefaultRoot(),
              e = this.model,
              o = e.schema,
              i = e.createPositionFromPath(t, [0]);
            return o.getNearestSelectionRange(i) || e.createRange(i);
          }
          _validateSelectionRange(t) {
            return ol(t.start) && ol(t.end);
          }
          _callPostFixers(t) {
            let e = !1;
            do {
              for (const o of this._postFixers) if ((this.selection.refresh(), (e = o(t)), e)) break;
            } while (e);
          }
        }
        function ol(t) {
          const e = t.textNode;
          if (e) {
            const o = e.data,
              i = t.offset - e.startOffset;
            return !Xa(o, i) && !tl(o, i);
          }
          return !0;
        }
        xo(el, fo);
        class il {
          constructor() {
            this._markers = new Map();
          }
          [Symbol.iterator]() {
            return this._markers.values();
          }
          has(t) {
            return this._markers.has(t);
          }
          get(t) {
            return this._markers.get(t) || null;
          }
          _set(t, e, o = !1, i = !1) {
            const n = t instanceof nl ? t.name : t,
              r = this._markers.get(n);
            if (r) {
              const t = r.getRange();
              let s = !1;
              return (
                t.isEqual(e) || (r._attachLiveRange(Os.fromRange(e)), (s = !0)),
                o != r.managedUsingOperations && ((r._managedUsingOperations = o), (s = !0)),
                'boolean' == typeof i && i != r.affectsData && ((r._affectsData = i), (s = !0)),
                s && this.fire('update:' + n, r, t, e),
                r
              );
            }
            const s = Os.fromRange(e),
              a = new nl(n, s, o, i);
            return this._markers.set(n, a), this.fire('update:' + n, a, null, e), a;
          }
          _remove(t) {
            const e = t instanceof nl ? t.name : t,
              o = this._markers.get(e);
            return (
              !!o &&
              (this._markers.delete(e), this.fire('update:' + e, o, o.getRange(), null), this._destroyMarker(o), !0)
            );
          }
          _refresh(t) {
            const e = t instanceof nl ? t.name : t,
              o = this._markers.get(e);
            if (!o)
              throw new uo.b(
                'markercollection-refresh-marker-not-exists: Marker with provided name does not exists.',
                this
              );
            const i = o.getRange();
            this.fire('update:' + e, o, i, i, o.managedUsingOperations, o.affectsData);
          }
          *getMarkersAtPosition(t) {
            for (const e of this) e.getRange().containsPosition(t) && (yield e);
          }
          *getMarkersIntersectingRange(t) {
            for (const e of this) null !== e.getRange().getIntersection(t) && (yield e);
          }
          destroy() {
            for (const t of this._markers.values()) this._destroyMarker(t);
            (this._markers = null), this.stopListening();
          }
          *getMarkersGroup(t) {
            for (const e of this._markers.values()) e.name.startsWith(t + ':') && (yield e);
          }
          _destroyMarker(t) {
            t.stopListening(), t._detachLiveRange();
          }
        }
        xo(il, fo);
        class nl {
          constructor(t, e, o, i) {
            (this.name = t),
              (this._liveRange = this._attachLiveRange(e)),
              (this._managedUsingOperations = o),
              (this._affectsData = i);
          }
          get managedUsingOperations() {
            if (!this._liveRange) throw new uo.b('marker-destroyed: Cannot use a destroyed marker instance.', this);
            return this._managedUsingOperations;
          }
          get affectsData() {
            if (!this._liveRange) throw new uo.b('marker-destroyed: Cannot use a destroyed marker instance.', this);
            return this._affectsData;
          }
          getStart() {
            if (!this._liveRange) throw new uo.b('marker-destroyed: Cannot use a destroyed marker instance.', this);
            return this._liveRange.start.clone();
          }
          getEnd() {
            if (!this._liveRange) throw new uo.b('marker-destroyed: Cannot use a destroyed marker instance.', this);
            return this._liveRange.end.clone();
          }
          getRange() {
            if (!this._liveRange) throw new uo.b('marker-destroyed: Cannot use a destroyed marker instance.', this);
            return this._liveRange.toRange();
          }
          is(t) {
            return 'marker' === t || 'model:marker' === t;
          }
          _attachLiveRange(t) {
            return (
              this._liveRange && this._detachLiveRange(),
              t.delegate('change:range').to(this),
              t.delegate('change:content').to(this),
              (this._liveRange = t),
              t
            );
          }
          _detachLiveRange() {
            this._liveRange.stopDelegating('change:range', this),
              this._liveRange.stopDelegating('change:content', this),
              this._liveRange.detach(),
              (this._liveRange = null);
          }
        }
        xo(nl, fo);
        class rl extends ya {
          get type() {
            return 'noop';
          }
          clone() {
            return new rl(this.baseVersion);
          }
          getReversed() {
            return new rl(this.baseVersion + 1);
          }
          _execute() {}
          static get className() {
            return 'NoOperation';
          }
        }
        const sl = {};
        (sl[Na.className] = Na),
          (sl[Va.className] = Va),
          (sl[Da.className] = Da),
          (sl[Oa.className] = Oa),
          (sl[rl.className] = rl),
          (sl[ya.className] = ya),
          (sl[za.className] = za),
          (sl[La.className] = La),
          (sl[Ba.className] = Ba),
          (sl[ja.className] = ja);
        class al extends ks {
          constructor(t, e, o = 'toNone') {
            if ((super(t, e, o), !this.root.is('rootElement')))
              throw new uo.b(
                "model-liveposition-root-not-rootelement: LivePosition's root has to be an instance of RootElement.",
                t
              );
            ll.call(this);
          }
          detach() {
            this.stopListening();
          }
          is(t) {
            return 'livePosition' === t || 'model:livePosition' === t || 'position' == t || 'model:position' === t;
          }
          toPosition() {
            return new ks(this.root, this.path.slice(), this.stickiness);
          }
          static fromPosition(t, e) {
            return new this(t.root, t.path.slice(), e || t.stickiness);
          }
        }
        function ll() {
          this.listenTo(
            this.root.document.model,
            'applyOperation',
            (t, e) => {
              const o = e[0];
              o.isDocumentOperation && cl.call(this, o);
            },
            { priority: 'low' }
          );
        }
        function cl(t) {
          const e = this.getTransformedByOperation(t);
          if (!this.isEqual(e)) {
            const t = this.toPosition();
            (this.path = e.path), (this.root = e.root), this.fire('change', t);
          }
        }
        xo(al, fo);
        class dl {
          constructor(t, e, o) {
            (this.model = t),
              (this.writer = e),
              (this.position = o),
              (this.canMergeWith = new Set([this.position.parent])),
              (this.schema = t.schema),
              (this._filterAttributesOf = []),
              (this._affectedStart = null),
              (this._affectedEnd = null);
          }
          handleNodes(t, e) {
            t = Array.from(t);
            for (let o = 0; o < t.length; o++) {
              const i = t[o];
              this._handleNode(i, { isFirst: 0 === o && e.isFirst, isLast: o === t.length - 1 && e.isLast });
            }
            this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer),
              (this._filterAttributesOf = []);
          }
          getSelectionRange() {
            return this.nodeToSelect
              ? xs._createOn(this.nodeToSelect)
              : this.model.schema.getNearestSelectionRange(this.position);
          }
          getAffectedRange() {
            return this._affectedStart ? new xs(this._affectedStart, this._affectedEnd) : null;
          }
          destroy() {
            this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
          }
          _handleNode(t, e) {
            if (this.schema.isObject(t)) return void this._handleObject(t, e);
            this._checkAndSplitToAllowedPosition(t, e)
              ? (this._insert(t), this._mergeSiblingsOf(t, e))
              : this._handleDisallowedNode(t, e);
          }
          _handleObject(t, e) {
            this._checkAndSplitToAllowedPosition(t) ? this._insert(t) : this._tryAutoparagraphing(t, e);
          }
          _handleDisallowedNode(t, e) {
            t.is('element') ? this.handleNodes(t.getChildren(), e) : this._tryAutoparagraphing(t, e);
          }
          _insert(t) {
            if (!this.schema.checkChild(this.position, t))
              throw new uo.b(
                'insertcontent-wrong-position: Given node cannot be inserted on the given position.',
                this,
                { node: t, position: this.position }
              );
            const e = al.fromPosition(this.position, 'toNext');
            this._setAffectedBoundaries(this.position),
              this.writer.insert(t, this.position),
              (this.position = e.toPosition()),
              e.detach(),
              this.schema.isObject(t) && !this.schema.checkChild(this.position, '$text')
                ? (this.nodeToSelect = t)
                : (this.nodeToSelect = null),
              this._filterAttributesOf.push(t);
          }
          _setAffectedBoundaries(t) {
            this._affectedStart || (this._affectedStart = al.fromPosition(t, 'toPrevious')),
              (this._affectedEnd && !this._affectedEnd.isBefore(t)) ||
                (this._affectedEnd && this._affectedEnd.detach(), (this._affectedEnd = al.fromPosition(t, 'toNext')));
          }
          _mergeSiblingsOf(t, e) {
            if (!(t instanceof ps)) return;
            const o = this._canMergeLeft(t, e),
              i = this._canMergeRight(t, e),
              n = al._createBefore(t);
            n.stickiness = 'toNext';
            const r = al._createAfter(t);
            if (((r.stickiness = 'toNext'), o)) {
              const t = al.fromPosition(this.position);
              (t.stickiness = 'toNext'),
                this._affectedStart.isEqual(n) &&
                  (this._affectedStart.detach(),
                  (this._affectedStart = al._createAt(n.nodeBefore, 'end', 'toPrevious'))),
                this.writer.merge(n),
                n.isEqual(this._affectedEnd) &&
                  e.isLast &&
                  (this._affectedEnd.detach(), (this._affectedEnd = al._createAt(n.nodeBefore, 'end', 'toNext'))),
                (this.position = t.toPosition()),
                t.detach();
            }
            if (i) {
              if (!this.position.isEqual(r)) throw new uo.b('insertcontent-invalid-insertion-position', this);
              this.position = ks._createAt(r.nodeBefore, 'end');
              const t = al.fromPosition(this.position, 'toPrevious');
              this._affectedEnd.isEqual(r) &&
                (this._affectedEnd.detach(), (this._affectedEnd = al._createAt(r.nodeBefore, 'end', 'toNext'))),
                this.writer.merge(r),
                r.getShiftedBy(-1).isEqual(this._affectedStart) &&
                  e.isFirst &&
                  (this._affectedStart.detach(), (this._affectedStart = al._createAt(r.nodeBefore, 0, 'toPrevious'))),
                (this.position = t.toPosition()),
                t.detach();
            }
            (o || i) && this._filterAttributesOf.push(this.position.parent), n.detach(), r.detach();
          }
          _canMergeLeft(t, e) {
            const o = t.previousSibling;
            return e.isFirst && o instanceof ps && this.canMergeWith.has(o) && this.model.schema.checkMerge(o, t);
          }
          _canMergeRight(t, e) {
            const o = t.nextSibling;
            return e.isLast && o instanceof ps && this.canMergeWith.has(o) && this.model.schema.checkMerge(t, o);
          }
          _tryAutoparagraphing(t, e) {
            const o = this.writer.createElement('paragraph');
            this._getAllowedIn(o, this.position.parent) &&
              this.schema.checkChild(o, t) &&
              (o._appendChild(t), this._handleNode(o, e));
          }
          _checkAndSplitToAllowedPosition(t) {
            const e = this._getAllowedIn(t, this.position.parent);
            if (!e) return !1;
            for (; e != this.position.parent; ) {
              if (this.schema.isLimit(this.position.parent)) return !1;
              if (this.position.isAtStart) {
                const t = this.position.parent;
                (this.position = this.writer.createPositionBefore(t)),
                  t.isEmpty && t.parent === e && this.writer.remove(t);
              } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent);
              else {
                const t = this.writer.createPositionAfter(this.position.parent);
                this._setAffectedBoundaries(this.position),
                  this.writer.split(this.position),
                  (this.position = t),
                  this.canMergeWith.add(this.position.nodeAfter);
              }
            }
            return !0;
          }
          _getAllowedIn(t, e) {
            return this.schema.checkChild(e, t) ? e : e.parent ? this._getAllowedIn(t, e.parent) : null;
          }
        }
        function hl(t, e, o = {}) {
          if (e.isCollapsed) return;
          const i = e.getFirstRange();
          if ('$graveyard' == i.root.rootName) return;
          const n = t.schema;
          t.change(t => {
            if (
              !o.doNotResetEntireContent &&
              (function (t, e) {
                const o = t.getLimitElement(e);
                if (!e.containsEntireContent(o)) return !1;
                const i = e.getFirstRange();
                if (i.start.parent == i.end.parent) return !1;
                return t.checkChild(o, 'paragraph');
              })(n, e)
            )
              return void (function (t, e) {
                const o = t.model.schema.getLimitElement(e);
                t.remove(t.createRangeIn(o)), ul(t, t.createPositionAt(o, 0), e);
              })(t, e);
            const r = i.start,
              s = al.fromPosition(i.end, 'toNext');
            i.start.isTouching(i.end) || t.remove(i),
              o.leaveUnmerged ||
                (!(function t(e, o, i) {
                  const n = o.parent,
                    r = i.parent;
                  if (n == r) return;
                  if (e.model.schema.isLimit(n) || e.model.schema.isLimit(r)) return;
                  if (
                    !(function (t, e, o) {
                      const i = new xs(t, e);
                      for (const t of i.getWalker()) if (o.isLimit(t.item)) return !1;
                      return !0;
                    })(o, i, e.model.schema)
                  )
                    return;
                  (o = e.createPositionAfter(n)), (i = e.createPositionBefore(r)).isEqual(o) || e.insert(r, o);
                  e.merge(o);
                  for (; i.parent.isEmpty; ) {
                    const t = i.parent;
                    (i = e.createPositionBefore(t)), e.remove(t);
                  }
                  t(e, o, i);
                })(t, r, s),
                n.removeDisallowedAttributes(r.parent.getChildren(), t)),
              gl(t, e, r),
              !o.doNotAutoparagraph &&
                (function (t, e) {
                  const o = t.checkChild(e, '$text'),
                    i = t.checkChild(e, 'paragraph');
                  return !o && i;
                })(n, r) &&
                ul(t, r, e),
              s.detach();
          });
        }
        function ul(t, e, o) {
          const i = t.createElement('paragraph');
          t.insert(i, e), gl(t, o, t.createPositionAt(i, 0));
        }
        function gl(t, e, o) {
          e instanceof zs ? t.setSelection(o) : e.setTo(o);
        }
        function ml(t, e) {
          if ('text' == e.type)
            return 'word' === t.unit
              ? (function (t, e) {
                  let o = t.position.textNode;
                  if (o) {
                    let i = t.position.offset - o.startOffset;
                    for (; !pl(o.data, i, e) && !bl(o, i, e); ) {
                      t.next();
                      const n = e ? t.position.nodeAfter : t.position.nodeBefore;
                      if (n && n.is('text')) {
                        const i = n.data.charAt(e ? 0 : n.data.length - 1);
                        ' ,.?!:;"-()'.includes(i) || (t.next(), (o = t.position.textNode));
                      }
                      i = t.position.offset - o.startOffset;
                    }
                  }
                  return t.position;
                })(t.walker, t.isForward)
              : (function (t, e) {
                  const o = t.position.textNode;
                  if (o) {
                    const i = o.data;
                    let n = t.position.offset - o.startOffset;
                    for (; Xa(i, n) || ('character' == e && tl(i, n)); )
                      t.next(), (n = t.position.offset - o.startOffset);
                  }
                  return t.position;
                })(t.walker, t.unit, t.isForward);
          if (e.type == (t.isForward ? 'elementStart' : 'elementEnd')) {
            if (t.schema.isObject(e.item)) return ks._createAt(e.item, t.isForward ? 'after' : 'before');
            if (t.schema.checkChild(e.nextPosition, '$text')) return e.nextPosition;
          } else {
            if (t.schema.isLimit(e.item)) return void t.walker.skip(() => !0);
            if (t.schema.checkChild(e.nextPosition, '$text')) return e.nextPosition;
          }
        }
        function fl(t, e) {
          const o = t.root,
            i = ks._createAt(o, e ? 'end' : 0);
          return e ? new xs(t, i) : new xs(i, t);
        }
        function pl(t, e, o) {
          const i = e + (o ? 0 : -1);
          return ' ,.?!:;"-()'.includes(t.charAt(i));
        }
        function bl(t, e, o) {
          return e === (o ? t.endOffset : 0);
        }
        function wl(t, e) {
          const o = [];
          Array.from(t.getItems({ direction: 'backward' }))
            .map(t => e.createRangeOn(t))
            .filter(
              e =>
                (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
                (e.end.isBefore(t.end) || e.end.isEqual(t.end))
            )
            .forEach(t => {
              o.push(t.start.parent), e.remove(t);
            }),
            o.forEach(t => {
              let o = t;
              for (; o.parent && o.isEmpty; ) {
                const t = e.createRangeOn(o);
                (o = o.parent), e.remove(t);
              }
            });
        }
        function kl(t) {
          t.document.registerPostFixer(e =>
            (function (t, e) {
              const o = e.document.selection,
                i = e.schema,
                n = [];
              let r = !1;
              for (const t of o.getRanges()) {
                const e = _l(t, i);
                e ? (n.push(e), (r = !0)) : n.push(t);
              }
              r &&
                t.setSelection(
                  (function (t) {
                    const e = [];
                    e.push(t.shift());
                    for (const o of t) {
                      const t = e.pop();
                      if (o.isIntersecting(t)) {
                        const i = t.start.isAfter(o.start) ? o.start : t.start,
                          n = t.end.isAfter(o.end) ? t.end : o.end,
                          r = new xs(i, n);
                        e.push(r);
                      } else e.push(t), e.push(o);
                    }
                    return e;
                  })(n),
                  { backward: o.isBackward }
                );
            })(e, t)
          );
        }
        function _l(t, e) {
          return t.isCollapsed
            ? (function (t, e) {
                const o = t.start,
                  i = e.getNearestSelectionRange(o);
                if (!i) return null;
                if (!i.isCollapsed) return i;
                const n = i.start;
                if (o.isEqual(n)) return null;
                return new xs(n);
              })(t, e)
            : (function (t, e) {
                const o = t.start,
                  i = t.end,
                  n = e.checkChild(o, '$text'),
                  r = e.checkChild(i, '$text'),
                  s = e.getLimitElement(o),
                  a = e.getLimitElement(i);
                if (s === a) {
                  if (n && r) return null;
                  if (
                    (function (t, e, o) {
                      const i = (t.nodeAfter && !o.isLimit(t.nodeAfter)) || o.checkChild(t, '$text'),
                        n = (e.nodeBefore && !o.isLimit(e.nodeBefore)) || o.checkChild(e, '$text');
                      return i || n;
                    })(o, i, e)
                  ) {
                    const t = o.nodeAfter && e.isObject(o.nodeAfter) ? null : e.getNearestSelectionRange(o, 'forward'),
                      n = i.nodeBefore && e.isObject(i.nodeBefore) ? null : e.getNearestSelectionRange(i, 'backward'),
                      r = t ? t.start : o,
                      s = n ? n.start : i;
                    return new xs(r, s);
                  }
                }
                const l = s && !s.is('rootElement'),
                  c = a && !a.is('rootElement');
                if (l || c) {
                  const t = o.nodeAfter && i.nodeBefore && o.nodeAfter.parent === i.nodeBefore.parent,
                    n = l && (!t || !yl(o.nodeAfter, e)),
                    r = c && (!t || !yl(i.nodeBefore, e));
                  let d = o,
                    h = i;
                  return n && (d = ks._createBefore(vl(s, e))), r && (h = ks._createAfter(vl(a, e))), new xs(d, h);
                }
                return null;
              })(t, e);
        }
        function vl(t, e) {
          let o = t,
            i = o;
          for (; e.isLimit(i) && i.parent; ) (o = i), (i = i.parent);
          return o;
        }
        function yl(t, e) {
          return t && e.isObject(t);
        }
        class xl {
          constructor() {
            (this.markers = new il()),
              (this.document = new el(this)),
              (this.schema = new ia()),
              (this._pendingChanges = []),
              (this._currentWriter = null),
              ['insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(t =>
                this.decorate(t)
              ),
              this.on(
                'applyOperation',
                (t, e) => {
                  e[0]._validate();
                },
                { priority: 'highest' }
              ),
              this.schema.register('$root', { isLimit: !0 }),
              this.schema.register('$block', { allowIn: '$root', isBlock: !0 }),
              this.schema.register('$text', { allowIn: '$block', isInline: !0 }),
              this.schema.register('$clipboardHolder', { allowContentOf: '$root', isLimit: !0 }),
              this.schema.extend('$text', { allowIn: '$clipboardHolder' }),
              this.schema.register('$marker'),
              this.schema.addChildCheck((t, e) => {
                if ('$marker' === e.name) return !0;
              }),
              kl(this);
          }
          change(t) {
            try {
              return 0 === this._pendingChanges.length
                ? (this._pendingChanges.push({ batch: new va(), callback: t }), this._runPendingChanges()[0])
                : t(this._currentWriter);
            } catch (t) {
              uo.b.rethrowUnexpectedError(t, this);
            }
          }
          enqueueChange(t, e) {
            try {
              'string' == typeof t ? (t = new va(t)) : 'function' == typeof t && ((e = t), (t = new va())),
                this._pendingChanges.push({ batch: t, callback: e }),
                1 == this._pendingChanges.length && this._runPendingChanges();
            } catch (t) {
              uo.b.rethrowUnexpectedError(t, this);
            }
          }
          applyOperation(t) {
            t._execute();
          }
          insertContent(t, e, o) {
            return (function (t, e, o, i) {
              return t.change(n => {
                let r;
                (r = o ? (o instanceof Es || o instanceof zs ? o : n.createSelection(o, i)) : t.document.selection),
                  r.isCollapsed || t.deleteContent(r, { doNotAutoparagraph: !0 });
                const s = new dl(t, n, r.anchor);
                let a;
                (a = e.is('documentFragment') ? e.getChildren() : [e]), s.handleNodes(a, { isFirst: !0, isLast: !0 });
                const l = s.getSelectionRange();
                l && (r instanceof zs ? n.setSelection(l) : r.setTo(l));
                const c = s.getAffectedRange() || t.createRange(r.anchor);
                return s.destroy(), c;
              });
            })(this, t, e, o);
          }
          deleteContent(t, e) {
            hl(this, t, e);
          }
          modifySelection(t, e) {
            !(function (t, e, o = {}) {
              const i = t.schema,
                n = 'backward' != o.direction,
                r = o.unit ? o.unit : 'character',
                s = e.focus,
                a = new bs({ boundaries: fl(s, n), singleCharacters: !0, direction: n ? 'forward' : 'backward' }),
                l = { walker: a, schema: i, isForward: n, unit: r };
              let c;
              for (; (c = a.next()); ) {
                if (c.done) return;
                const o = ml(l, c.value);
                if (o)
                  return void (e instanceof zs
                    ? t.change(t => {
                        t.setSelectionFocus(o);
                      })
                    : e.setFocus(o));
              }
            })(this, t, e);
          }
          getSelectedContent(t) {
            return (function (t, e) {
              return t.change(t => {
                const o = t.createDocumentFragment(),
                  i = e.getFirstRange();
                if (!i || i.isCollapsed) return o;
                const n = i.start.root,
                  r = i.start.getCommonPath(i.end),
                  s = n.getNodeByPath(r);
                let a;
                a =
                  i.start.parent == i.end.parent
                    ? i
                    : t.createRange(
                        t.createPositionAt(s, i.start.path[r.length]),
                        t.createPositionAt(s, i.end.path[r.length] + 1)
                      );
                const l = a.end.offset - a.start.offset;
                for (const e of a.getItems({ shallow: !0 }))
                  e.is('textProxy') ? t.appendText(e.data, e.getAttributes(), o) : t.append(e._clone(!0), o);
                if (a != i) {
                  const e = i._getTransformedByMove(a.start, t.createPositionAt(o, 0), l)[0],
                    n = t.createRange(t.createPositionAt(o, 0), e.start);
                  wl(t.createRange(e.end, t.createPositionAt(o, 'end')), t), wl(n, t);
                }
                return o;
              });
            })(this, t);
          }
          hasContent(t, e) {
            const o = t instanceof ps ? xs._createIn(t) : t;
            if (o.isCollapsed) return !1;
            for (const t of this.markers.getMarkersIntersectingRange(o)) if (t.affectsData) return !0;
            const { ignoreWhitespaces: i = !1 } = e || {};
            for (const t of o.getItems())
              if (t.is('textProxy')) {
                if (!i) return !0;
                if (-1 !== t.data.search(/\S/)) return !0;
              } else if (this.schema.isObject(t)) return !0;
            return !1;
          }
          createPositionFromPath(t, e, o) {
            return new ks(t, e, o);
          }
          createPositionAt(t, e) {
            return ks._createAt(t, e);
          }
          createPositionAfter(t) {
            return ks._createAfter(t);
          }
          createPositionBefore(t) {
            return ks._createBefore(t);
          }
          createRange(t, e) {
            return new xs(t, e);
          }
          createRangeIn(t) {
            return xs._createIn(t);
          }
          createRangeOn(t) {
            return xs._createOn(t);
          }
          createSelection(t, e, o) {
            return new Es(t, e, o);
          }
          createBatch(t) {
            return new va(t);
          }
          createOperationFromJSON(t) {
            return class {
              static fromJSON(t, e) {
                return sl[t.__className].fromJSON(t, e);
              }
            }.fromJSON(t, this.document);
          }
          destroy() {
            this.document.destroy(), this.stopListening();
          }
          _runPendingChanges() {
            const t = [];
            for (this.fire('_beforeChanges'); this._pendingChanges.length; ) {
              const e = this._pendingChanges[0].batch;
              this._currentWriter = new Ha(this, e);
              const o = this._pendingChanges[0].callback(this._currentWriter);
              t.push(o),
                this.document._handleChangeBlock(this._currentWriter),
                this._pendingChanges.shift(),
                (this._currentWriter = null);
            }
            return this.fire('_afterChanges'), t;
          }
        }
        xo(xl, Hi);
        class Cl {
          constructor() {
            this._listener = Object.create(lr);
          }
          listenTo(t) {
            this._listener.listenTo(t, 'keydown', (t, e) => {
              this._listener.fire('_keydown:' + pn(e), e);
            });
          }
          set(t, e, o = {}) {
            const i = bn(t),
              n = o.priority;
            this._listener.listenTo(
              this._listener,
              '_keydown:' + i,
              (t, o) => {
                e(o, () => {
                  o.preventDefault(), o.stopPropagation(), t.stop();
                }),
                  (t.return = !0);
              },
              { priority: n }
            );
          }
          press(t) {
            return !!this._listener.fire('_keydown:' + pn(t), t);
          }
          destroy() {
            this._listener.stopListening();
          }
        }
        class Al extends Cl {
          constructor(t) {
            super(), (this.editor = t);
          }
          set(t, e, o = {}) {
            if ('string' == typeof e) {
              const t = e;
              e = (e, o) => {
                this.editor.execute(t), o();
              };
            }
            super.set(t, e, o);
          }
        }
        class Tl {
          constructor(t = {}) {
            (this._context = t.context || new Mo({ language: t.language })), this._context._addEditor(this, !t.context);
            const e = Array.from(this.constructor.builtinPlugins || []);
            (this.config = new io(t, this.constructor.defaultConfig)),
              this.config.define('plugins', e),
              this.config.define(this._context._getEditorConfig()),
              (this.plugins = new Ao(this, e, this._context.plugins)),
              (this.locale = this._context.locale),
              (this.t = this.locale.t),
              (this.commands = new ta()),
              this.set('state', 'initializing'),
              this.once('ready', () => (this.state = 'ready'), { priority: 'high' }),
              this.once('destroy', () => (this.state = 'destroyed'), { priority: 'high' }),
              this.set('isReadOnly', !1),
              (this.model = new xl());
            const o = new Mi();
            (this.data = new ba(this.model, o)),
              (this.editing = new Xs(this.model, o)),
              this.editing.view.document.bind('isReadOnly').to(this),
              (this.conversion = new wa(
                [this.editing.downcastDispatcher, this.data.downcastDispatcher],
                this.data.upcastDispatcher
              )),
              this.conversion.addAlias('dataDowncast', this.data.downcastDispatcher),
              this.conversion.addAlias('editingDowncast', this.editing.downcastDispatcher),
              (this.keystrokes = new Al(this)),
              this.keystrokes.listenTo(this.editing.view.document);
          }
          initPlugins() {
            const t = this.config,
              e = t.get('plugins'),
              o = t.get('removePlugins') || [],
              i = t.get('extraPlugins') || [];
            return this.plugins.init(e.concat(i), o);
          }
          destroy() {
            let t = Promise.resolve();
            return (
              'initializing' == this.state && (t = new Promise(t => this.once('ready', t))),
              t
                .then(() => {
                  this.fire('destroy'), this.stopListening(), this.commands.destroy();
                })
                .then(() => this.plugins.destroy())
                .then(() => {
                  this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
                })
                .then(() => this._context._removeEditor(this))
            );
          }
          execute(...t) {
            try {
              this.commands.execute(...t);
            } catch (t) {
              uo.b.rethrowUnexpectedError(t, this);
            }
          }
        }
        xo(Tl, Hi);
        var Sl = {
          setData(t) {
            this.data.set(t);
          },
          getData(t) {
            return this.data.get(t);
          },
        };
        class Pl {
          getHtml(t) {
            const e = document.implementation.createHTMLDocument('').createElement('div');
            return e.appendChild(t), e.innerHTML;
          }
        }
        class El {
          constructor(t) {
            (this._domParser = new DOMParser()),
              (this._domConverter = new ir(t, { blockFillerMode: 'nbsp' })),
              (this._htmlWriter = new Pl());
          }
          toData(t) {
            const e = this._domConverter.viewToDom(t, document);
            return this._htmlWriter.getHtml(e);
          }
          toView(t) {
            const e = this._toDom(t);
            return this._domConverter.domToView(e);
          }
          _toDom(t) {
            const e = this._domParser.parseFromString(t, 'text/html'),
              o = e.createDocumentFragment(),
              i = e.body.childNodes;
            for (; i.length > 0; ) o.appendChild(i[0]);
            return o;
          }
        }
        class Ml {
          constructor(t) {
            (this.editor = t), (this._components = new Map());
          }
          *names() {
            for (const t of this._components.values()) yield t.originalName;
          }
          add(t, e) {
            if (this.has(t))
              throw new uo.b('componentfactory-item-exists: The item already exists in the component factory.', this, {
                name: t,
              });
            this._components.set(Il(t), { callback: e, originalName: t });
          }
          create(t) {
            if (!this.has(t))
              throw new uo.b(
                'componentfactory-item-missing: The required component is not registered in the factory.',
                this,
                { name: t }
              );
            return this._components.get(Il(t)).callback(this.editor.locale);
          }
          has(t) {
            return this._components.has(Il(t));
          }
        }
        function Il(t) {
          return String(t).toLowerCase();
        }
        class Nl {
          constructor() {
            this.set('isFocused', !1),
              this.set('focusedElement', null),
              (this._elements = new Set()),
              (this._nextEventLoopTimeout = null);
          }
          add(t) {
            if (this._elements.has(t)) throw new uo.b('focusTracker-add-element-already-exist', this);
            this.listenTo(t, 'focus', () => this._focus(t), { useCapture: !0 }),
              this.listenTo(t, 'blur', () => this._blur(), { useCapture: !0 }),
              this._elements.add(t);
          }
          remove(t) {
            t === this.focusedElement && this._blur(t),
              this._elements.has(t) && (this.stopListening(t), this._elements.delete(t));
          }
          destroy() {
            this.stopListening();
          }
          _focus(t) {
            clearTimeout(this._nextEventLoopTimeout), (this.focusedElement = t), (this.isFocused = !0);
          }
          _blur() {
            clearTimeout(this._nextEventLoopTimeout),
              (this._nextEventLoopTimeout = setTimeout(() => {
                (this.focusedElement = null), (this.isFocused = !1);
              }, 0));
          }
        }
        xo(Nl, lr), xo(Nl, Hi);
        class Rl {
          constructor(t) {
            (this.editor = t),
              (this.componentFactory = new Ml(t)),
              (this.focusTracker = new Nl()),
              (this._editableElementsMap = new Map()),
              this.listenTo(t.editing.view.document, 'layoutChanged', () => this.update());
          }
          get element() {
            return null;
          }
          update() {
            this.fire('update');
          }
          destroy() {
            this.stopListening(), this.focusTracker.destroy();
            for (const t of this._editableElementsMap.values()) t.ckeditorInstance = null;
            this._editableElementsMap = new Map();
          }
          setEditableElement(t, e) {
            this._editableElementsMap.set(t, e), e.ckeditorInstance || (e.ckeditorInstance = this.editor);
          }
          getEditableElement(t = 'main') {
            return this._editableElementsMap.get(t);
          }
          getEditableElementsNames() {
            return this._editableElementsMap.keys();
          }
          get _editableElements() {
            return (
              console.warn(
                'editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.',
                { editorUI: this }
              ),
              this._editableElementsMap
            );
          }
        }
        xo(Rl, fo);
        o(15);
        const Ol = new WeakMap();
        function Vl(t) {
          const { view: e, element: o, text: i, isDirectHost: n = !0 } = t,
            r = e.document;
          Ol.has(r) || (Ol.set(r, new Map()), r.registerPostFixer(t => zl(r, t))),
            Ol.get(r).set(o, { text: i, isDirectHost: n }),
            e.change(t => zl(r, t));
        }
        function Dl(t, e) {
          return !!e.hasClass('ck-placeholder') && (t.removeClass('ck-placeholder', e), !0);
        }
        function zl(t, e) {
          const o = Ol.get(t);
          let i = !1;
          for (const [t, n] of o) Ll(e, t, n) && (i = !0);
          return i;
        }
        function Ll(t, e, o) {
          const { text: i, isDirectHost: n } = o,
            r = n
              ? e
              : (function (t) {
                  if (1 === t.childCount) {
                    const e = t.getChild(0);
                    if (e.is('element') && !e.is('uiElement')) return e;
                  }
                  return null;
                })(e);
          let s = !1;
          return (
            !!r &&
            ((o.hostElement = r),
            r.getAttribute('data-placeholder') !== i && (t.setAttribute('data-placeholder', i, r), (s = !0)),
            !(function (t) {
              if (!t.isAttached()) return !1;
              const e = !Array.from(t.getChildren()).some(t => !t.is('uiElement')),
                o = t.document;
              if (!o.isFocused && e) return !0;
              const i = o.selection.anchor;
              return !(!e || !i || i.parent === t);
            })(r)
              ? Dl(t, r) && (s = !0)
              : (function (t, e) {
                  return !e.hasClass('ck-placeholder') && (t.addClass('ck-placeholder', e), !0);
                })(t, r) && (s = !0),
            s)
          );
        }
        class jl extends Rl {
          constructor(t, e) {
            var o;
            super(t),
              (this.view = e),
              (this._toolbarConfig =
                ((o = t.config.get('toolbar')),
                Array.isArray(o) ? { items: o } : o ? Object.assign({ items: [] }, o) : { items: [] }));
          }
          init() {
            const t = this.editor,
              e = this.view,
              o = t.editing.view,
              i = e.editable,
              n = o.document.getRoot();
            (e.editable.name = n.rootName), e.render();
            const r = i.element;
            this.setEditableElement(i.name, r),
              this.focusTracker.add(r),
              e.editable.bind('isFocused').to(this.focusTracker),
              o.attachDomRoot(r),
              this._initPlaceholder(),
              this._initToolbar(),
              this.fire('ready');
          }
          destroy() {
            const t = this.view;
            this.editor.editing.view.detachDomRoot(t.editable.name), t.destroy(), super.destroy();
          }
          _initToolbar() {
            const t = this.editor,
              e = this.view.toolbar;
            e.fillFromConfig(this._toolbarConfig.items, this.componentFactory),
              (function ({
                origin: t,
                originKeystrokeHandler: e,
                originFocusTracker: o,
                toolbar: i,
                beforeFocus: n,
                afterBlur: r,
              }) {
                o.add(i.element),
                  e.set('Alt+F10', (t, e) => {
                    o.isFocused && !i.focusTracker.isFocused && (n && n(), i.focus(), e());
                  }),
                  i.keystrokes.set('Esc', (e, o) => {
                    i.focusTracker.isFocused && (t.focus(), r && r(), o());
                  });
              })({
                origin: t.editing.view,
                originFocusTracker: this.focusTracker,
                originKeystrokeHandler: t.keystrokes,
                toolbar: e,
              });
          }
          _initPlaceholder() {
            const t = this.editor,
              e = t.editing.view,
              o = e.document.getRoot(),
              i = t.sourceElement,
              n =
                t.config.get('placeholder') ||
                (i && 'textarea' === i.tagName.toLowerCase() && i.getAttribute('placeholder'));
            n && Vl({ view: e, element: o, text: n, isDirectHost: !1 });
          }
        }
        class Bl extends Co {
          constructor(t = []) {
            super(t, { idProperty: 'viewUid' }),
              this.on('add', (t, e, o) => {
                this._renderViewIntoCollectionParent(e, o);
              }),
              this.on('remove', (t, e) => {
                e.element && this._parentElement && e.element.remove();
              }),
              (this._parentElement = null);
          }
          destroy() {
            this.map(t => t.destroy());
          }
          setParent(t) {
            this._parentElement = t;
            for (const t of this) this._renderViewIntoCollectionParent(t);
          }
          delegate(...t) {
            if (!t.length || !t.every(t => 'string' == typeof t))
              throw new uo.b('ui-viewcollection-delegate-wrong-events: All event names must be strings.', this);
            return {
              to: e => {
                for (const o of this) for (const i of t) o.delegate(i).to(e);
                this.on('add', (o, i) => {
                  for (const o of t) i.delegate(o).to(e);
                }),
                  this.on('remove', (o, i) => {
                    for (const o of t) i.stopDelegating(o, e);
                  });
              },
            };
          }
          _renderViewIntoCollectionParent(t, e) {
            t.isRendered || t.render(),
              t.element &&
                this._parentElement &&
                this._parentElement.insertBefore(t.element, this._parentElement.children[e]);
          }
        }
        class Fl {
          constructor(t) {
            Object.assign(this, Jl(Kl(t))), (this._isRendered = !1), (this._revertData = null);
          }
          render() {
            const t = this._renderNode({ intoFragment: !0 });
            return (this._isRendered = !0), t;
          }
          apply(t) {
            return (
              (this._revertData = { children: [], bindings: [], attributes: {} }),
              this._renderNode({ node: t, isApplying: !0, revertData: this._revertData }),
              t
            );
          }
          revert(t) {
            if (!this._revertData)
              throw new uo.b(
                'ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.',
                [this, t]
              );
            this._revertTemplateFromNode(t, this._revertData);
          }
          *getViews() {
            yield* (function* t(e) {
              if (e.children) for (const o of e.children) oc(o) ? yield o : ic(o) && (yield* t(o));
            })(this);
          }
          static bind(t, e) {
            return {
              to: (o, i) => new Wl({ eventNameOrFunction: o, attribute: o, observable: t, emitter: e, callback: i }),
              if: (o, i, n) => new Ul({ observable: t, emitter: e, attribute: o, valueIfTrue: i, callback: n }),
            };
          }
          static extend(t, e) {
            if (t._isRendered)
              throw new uo.b(
                'template-extend-render: Attempting to extend a template which has already been rendered.',
                [this, t]
              );
            !(function t(e, o) {
              o.attributes && (e.attributes || (e.attributes = {}), tc(e.attributes, o.attributes));
              o.eventListeners && (e.eventListeners || (e.eventListeners = {}), tc(e.eventListeners, o.eventListeners));
              o.text && e.text.push(...o.text);
              if (o.children && o.children.length) {
                if (e.children.length != o.children.length)
                  throw new uo.b(
                    'ui-template-extend-children-mismatch: The number of children in extended definition does not match.',
                    e
                  );
                let i = 0;
                for (const n of o.children) t(e.children[i++], n);
              }
            })(t, Jl(Kl(e)));
          }
          _renderNode(t) {
            let e;
            if (((e = t.node ? this.tag && this.text : this.tag ? this.text : !this.text), e))
              throw new uo.b(
                'ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering a new Node.',
                this
              );
            return this.text ? this._renderText(t) : this._renderElement(t);
          }
          _renderElement(t) {
            let e = t.node;
            return (
              e || (e = t.node = document.createElementNS(this.ns || 'http://www.w3.org/1999/xhtml', this.tag)),
              this._renderAttributes(t),
              this._renderElementChildren(t),
              this._setUpListeners(t),
              e
            );
          }
          _renderText(t) {
            let e = t.node;
            return (
              e ? (t.revertData.text = e.textContent) : (e = t.node = document.createTextNode('')),
              ql(this.text)
                ? this._bindToObservable({ schema: this.text, updater: Yl(e), data: t })
                : (e.textContent = this.text.join('')),
              e
            );
          }
          _renderAttributes(t) {
            let e, o, i, n;
            if (!this.attributes) return;
            const r = t.node,
              s = t.revertData;
            for (e in this.attributes)
              if (
                ((i = r.getAttribute(e)),
                (o = this.attributes[e]),
                s && (s.attributes[e] = i),
                (n = z(o[0]) && o[0].ns ? o[0].ns : null),
                ql(o))
              ) {
                const a = n ? o[0].value : o;
                s && rc(e) && a.unshift(i), this._bindToObservable({ schema: a, updater: $l(r, e, n), data: t });
              } else
                'style' == e && 'string' != typeof o[0]
                  ? this._renderStyleAttribute(o[0], t)
                  : (s && i && rc(e) && o.unshift(i),
                    (o = o
                      .map(t => (t && t.value) || t)
                      .reduce((t, e) => t.concat(e), [])
                      .reduce(Xl, '')),
                    ec(o) || r.setAttributeNS(n, e, o));
          }
          _renderStyleAttribute(t, e) {
            const o = e.node;
            for (const i in t) {
              const n = t[i];
              ql(n) ? this._bindToObservable({ schema: [n], updater: Ql(o, i), data: e }) : (o.style[i] = n);
            }
          }
          _renderElementChildren(t) {
            const e = t.node,
              o = t.intoFragment ? document.createDocumentFragment() : e,
              i = t.isApplying;
            let n = 0;
            for (const r of this.children)
              if (nc(r)) {
                if (!i) {
                  r.setParent(e);
                  for (const t of r) o.appendChild(t.element);
                }
              } else if (oc(r)) i || (r.isRendered || r.render(), o.appendChild(r.element));
              else if ($n(r)) o.appendChild(r);
              else if (i) {
                const e = { children: [], bindings: [], attributes: {} };
                t.revertData.children.push(e),
                  r._renderNode({ node: o.childNodes[n++], isApplying: !0, revertData: e });
              } else o.appendChild(r.render());
            t.intoFragment && e.appendChild(o);
          }
          _setUpListeners(t) {
            if (this.eventListeners)
              for (const e in this.eventListeners) {
                const o = this.eventListeners[e].map(o => {
                  const [i, n] = e.split('@');
                  return o.activateDomEventListener(i, n, t);
                });
                t.revertData && t.revertData.bindings.push(o);
              }
          }
          _bindToObservable({ schema: t, updater: e, data: o }) {
            const i = o.revertData;
            Gl(t, e, o);
            const n = t
              .filter(t => !ec(t))
              .filter(t => t.observable)
              .map(i => i.activateAttributeListener(t, e, o));
            i && i.bindings.push(n);
          }
          _revertTemplateFromNode(t, e) {
            for (const t of e.bindings) for (const e of t) e();
            if (e.text) t.textContent = e.text;
            else {
              for (const o in e.attributes) {
                const i = e.attributes[o];
                null === i ? t.removeAttribute(o) : t.setAttribute(o, i);
              }
              for (let o = 0; o < e.children.length; ++o) this._revertTemplateFromNode(t.childNodes[o], e.children[o]);
            }
          }
        }
        xo(Fl, fo);
        class Hl {
          constructor(t) {
            Object.assign(this, t);
          }
          getValue(t) {
            const e = this.observable[this.attribute];
            return this.callback ? this.callback(e, t) : e;
          }
          activateAttributeListener(t, e, o) {
            const i = () => Gl(t, e, o);
            return (
              this.emitter.listenTo(this.observable, 'change:' + this.attribute, i),
              () => {
                this.emitter.stopListening(this.observable, 'change:' + this.attribute, i);
              }
            );
          }
        }
        class Wl extends Hl {
          activateDomEventListener(t, e, o) {
            const i = (t, o) => {
              (e && !o.target.matches(e)) ||
                ('function' == typeof this.eventNameOrFunction
                  ? this.eventNameOrFunction(o)
                  : this.observable.fire(this.eventNameOrFunction, o));
            };
            return (
              this.emitter.listenTo(o.node, t, i),
              () => {
                this.emitter.stopListening(o.node, t, i);
              }
            );
          }
        }
        class Ul extends Hl {
          getValue(t) {
            return !ec(super.getValue(t)) && (this.valueIfTrue || !0);
          }
        }
        function ql(t) {
          return !!t && (t.value && (t = t.value), Array.isArray(t) ? t.some(ql) : t instanceof Hl);
        }
        function Gl(t, e, { node: o }) {
          let i = (function (t, e) {
            return t.map(t => (t instanceof Hl ? t.getValue(e) : t));
          })(t, o);
          (i = 1 == t.length && t[0] instanceof Ul ? i[0] : i.reduce(Xl, '')), ec(i) ? e.remove() : e.set(i);
        }
        function Yl(t) {
          return {
            set(e) {
              t.textContent = e;
            },
            remove() {
              t.textContent = '';
            },
          };
        }
        function $l(t, e, o) {
          return {
            set(i) {
              t.setAttributeNS(o, e, i);
            },
            remove() {
              t.removeAttributeNS(o, e);
            },
          };
        }
        function Ql(t, e) {
          return {
            set(o) {
              t.style[e] = o;
            },
            remove() {
              t.style[e] = null;
            },
          };
        }
        function Kl(t) {
          return eo(t, t => {
            if (t && (t instanceof Hl || ic(t) || oc(t) || nc(t))) return t;
          });
        }
        function Jl(t) {
          if (
            ('string' == typeof t
              ? (t = (function (t) {
                  return { text: [t] };
                })(t))
              : t.text &&
                (function (t) {
                  Array.isArray(t.text) || (t.text = [t.text]);
                })(t),
            t.on &&
              ((t.eventListeners = (function (t) {
                for (const e in t) Zl(t, e);
                return t;
              })(t.on)),
              delete t.on),
            !t.text)
          ) {
            t.attributes &&
              (function (t) {
                for (const e in t) t[e].value && (t[e].value = [].concat(t[e].value)), Zl(t, e);
              })(t.attributes);
            const e = [];
            if (t.children)
              if (nc(t.children)) e.push(t.children);
              else for (const o of t.children) ic(o) || oc(o) || $n(o) ? e.push(o) : e.push(new Fl(o));
            t.children = e;
          }
          return t;
        }
        function Zl(t, e) {
          Array.isArray(t[e]) || (t[e] = [t[e]]);
        }
        function Xl(t, e) {
          return ec(e) ? t : ec(t) ? e : `${t} ${e}`;
        }
        function tc(t, e) {
          for (const o in e) t[o] ? t[o].push(...e[o]) : (t[o] = e[o]);
        }
        function ec(t) {
          return !t && 0 !== t;
        }
        function oc(t) {
          return t instanceof sc;
        }
        function ic(t) {
          return t instanceof Fl;
        }
        function nc(t) {
          return t instanceof Bl;
        }
        function rc(t) {
          return 'class' == t || 'style' == t;
        }
        o(17);
        class sc {
          constructor(t) {
            (this.element = null),
              (this.isRendered = !1),
              (this.locale = t),
              (this.t = t && t.t),
              (this._viewCollections = new Co()),
              (this._unboundChildren = this.createCollection()),
              this._viewCollections.on('add', (e, o) => {
                o.locale = t;
              }),
              this.decorate('render');
          }
          get bindTemplate() {
            return this._bindTemplate ? this._bindTemplate : (this._bindTemplate = Fl.bind(this, this));
          }
          createCollection(t) {
            const e = new Bl(t);
            return this._viewCollections.add(e), e;
          }
          registerChild(t) {
            yo(t) || (t = [t]);
            for (const e of t) this._unboundChildren.add(e);
          }
          deregisterChild(t) {
            yo(t) || (t = [t]);
            for (const e of t) this._unboundChildren.remove(e);
          }
          setTemplate(t) {
            this.template = new Fl(t);
          }
          extendTemplate(t) {
            Fl.extend(this.template, t);
          }
          render() {
            if (this.isRendered)
              throw new uo.b('ui-view-render-already-rendered: This View has already been rendered.', this);
            this.template && ((this.element = this.template.render()), this.registerChild(this.template.getViews())),
              (this.isRendered = !0);
          }
          destroy() {
            this.stopListening(),
              this._viewCollections.map(t => t.destroy()),
              this.template && this.template._revertData && this.template.revert(this.element);
          }
        }
        xo(sc, lr), xo(sc, Hi);
        var ac = function (t) {
          return 'string' == typeof t || (!Vt(t) && p(t) && '[object String]' == g(t));
        };
        class lc extends Bl {
          constructor(t, e = []) {
            super(e), (this.locale = t);
          }
          attachToDom() {
            this._bodyCollectionContainer = new Fl({
              tag: 'div',
              attributes: {
                class: ['ck', 'ck-reset_all', 'ck-body', 'ck-rounded-corners'],
                dir: this.locale.uiLanguageDirection,
              },
              children: this,
            }).render();
            let t = document.querySelector('.ck-body-wrapper');
            t ||
              ((t = (function (t, e, o = {}, i = []) {
                const n = o && o.xmlns,
                  r = n ? t.createElementNS(n, e) : t.createElement(e);
                for (const t in o) r.setAttribute(t, o[t]);
                (!ac(i) && yo(i)) || (i = [i]);
                for (let e of i) ac(e) && (e = t.createTextNode(e)), r.appendChild(e);
                return r;
              })(document, 'div', { class: 'ck-body-wrapper' })),
              document.body.appendChild(t)),
              t.appendChild(this._bodyCollectionContainer);
          }
          detachFromDom() {
            super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
            const t = document.querySelector('.ck-body-wrapper');
            t && 0 == t.childElementCount && t.remove();
          }
        }
        o(19);
        class cc extends sc {
          constructor(t) {
            super(t), (this.body = new lc(t));
          }
          render() {
            super.render(), this.body.attachToDom();
          }
          destroy() {
            return this.body.detachFromDom(), super.destroy();
          }
        }
        class dc extends sc {
          constructor(t, e, o) {
            super(t),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-content', 'ck-editor__editable', 'ck-rounded-corners'],
                  lang: t.contentLanguage,
                  dir: t.contentLanguageDirection,
                },
              }),
              (this.name = null),
              this.set('isFocused', !1),
              (this._editableElement = o),
              (this._hasExternalElement = !!this._editableElement),
              (this._editingView = e);
          }
          render() {
            super.render(),
              this._hasExternalElement
                ? this.template.apply((this.element = this._editableElement))
                : (this._editableElement = this.element),
              this.on('change:isFocused', () => this._updateIsFocusedClasses()),
              this._updateIsFocusedClasses();
          }
          destroy() {
            this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
          }
          _updateIsFocusedClasses() {
            const t = this._editingView;
            function e(e) {
              t.change(o => {
                const i = t.document.getRoot(e.name);
                o.addClass(e.isFocused ? 'ck-focused' : 'ck-blurred', i),
                  o.removeClass(e.isFocused ? 'ck-blurred' : 'ck-focused', i);
              });
            }
            t.isRenderingInProgress
              ? (function o(i) {
                  t.once('change:isRenderingInProgress', (t, n, r) => {
                    r ? o(i) : e(i);
                  });
                })(this)
              : e(this);
          }
        }
        class hc extends dc {
          constructor(t, e, o) {
            super(t, e, o),
              this.extendTemplate({ attributes: { role: 'textbox', class: 'ck-editor__editable_inline' } });
          }
          render() {
            super.render();
            const t = this._editingView,
              e = this.t;
            t.change(o => {
              const i = t.document.getRoot(this.name);
              o.setAttribute('aria-label', e('Rich Text Editor, %0', [this.name]), i);
            });
          }
        }
        class uc {
          constructor(t) {
            if ((Object.assign(this, t), t.actions && t.keystrokeHandler))
              for (const e in t.actions) {
                let o = t.actions[e];
                'string' == typeof o && (o = [o]);
                for (const i of o)
                  t.keystrokeHandler.set(i, (t, o) => {
                    this[e](), o();
                  });
              }
          }
          get first() {
            return this.focusables.find(gc) || null;
          }
          get last() {
            return this.focusables.filter(gc).slice(-1)[0] || null;
          }
          get next() {
            return this._getFocusableItem(1);
          }
          get previous() {
            return this._getFocusableItem(-1);
          }
          get current() {
            let t = null;
            return null === this.focusTracker.focusedElement
              ? null
              : (this.focusables.find((e, o) => {
                  const i = e.element === this.focusTracker.focusedElement;
                  return i && (t = o), i;
                }),
                t);
          }
          focusFirst() {
            this._focus(this.first);
          }
          focusLast() {
            this._focus(this.last);
          }
          focusNext() {
            this._focus(this.next);
          }
          focusPrevious() {
            this._focus(this.previous);
          }
          _focus(t) {
            t && t.focus();
          }
          _getFocusableItem(t) {
            const e = this.current,
              o = this.focusables.length;
            if (!o) return null;
            if (null === e) return this[1 === t ? 'first' : 'last'];
            let i = (e + o + t) % o;
            do {
              const e = this.focusables.get(i);
              if (gc(e)) return e;
              i = (i + o + t) % o;
            } while (i !== e);
            return null;
          }
        }
        function gc(t) {
          return !(!t.focus || 'none' == Xn.window.getComputedStyle(t.element).display);
        }
        class mc extends sc {
          constructor(t) {
            super(t), this.setTemplate({ tag: 'span', attributes: { class: ['ck', 'ck-toolbar__separator'] } });
          }
        }
        class fc {
          constructor(t, e) {
            fc._observerInstance || fc._createObserver(),
              (this._element = t),
              (this._callback = e),
              fc._addElementCallback(t, e),
              fc._observerInstance.observe(t);
          }
          destroy() {
            fc._deleteElementCallback(this._element, this._callback);
          }
          static _addElementCallback(t, e) {
            fc._elementCallbacks || (fc._elementCallbacks = new Map());
            let o = fc._elementCallbacks.get(t);
            o || ((o = new Set()), fc._elementCallbacks.set(t, o)), o.add(e);
          }
          static _deleteElementCallback(t, e) {
            const o = fc._getElementCallbacks(t);
            o && (o.delete(e), o.size || (fc._elementCallbacks.delete(t), fc._observerInstance.unobserve(t))),
              fc._elementCallbacks &&
                !fc._elementCallbacks.size &&
                ((fc._observerInstance = null), (fc._elementCallbacks = null));
          }
          static _getElementCallbacks(t) {
            return fc._elementCallbacks ? fc._elementCallbacks.get(t) : null;
          }
          static _createObserver() {
            let t;
            (t = 'function' == typeof Xn.window.ResizeObserver ? Xn.window.ResizeObserver : pc),
              (fc._observerInstance = new t(t => {
                for (const e of t) {
                  if (!e.target.offsetParent) continue;
                  const t = fc._getElementCallbacks(e.target);
                  if (t) for (const o of t) o(e);
                }
              }));
          }
        }
        (fc._observerInstance = null), (fc._elementCallbacks = null);
        class pc {
          constructor(t) {
            (this._callback = t),
              (this._elements = new Set()),
              (this._previousRects = new Map()),
              (this._periodicCheckTimeout = null);
          }
          observe(t) {
            this._elements.add(t),
              this._checkElementRectsAndExecuteCallback(),
              1 === this._elements.size && this._startPeriodicCheck();
          }
          unobserve(t) {
            this._elements.delete(t), this._previousRects.delete(t), this._elements.size || this._stopPeriodicCheck();
          }
          _startPeriodicCheck() {
            const t = () => {
              this._checkElementRectsAndExecuteCallback(), (this._periodicCheckTimeout = setTimeout(t, 100));
            };
            this.listenTo(Xn.window, 'resize', () => {
              this._checkElementRectsAndExecuteCallback();
            }),
              (this._periodicCheckTimeout = setTimeout(t, 100));
          }
          _stopPeriodicCheck() {
            clearTimeout(this._periodicCheckTimeout), this.stopListening(), this._previousRects.clear();
          }
          _checkElementRectsAndExecuteCallback() {
            const t = [];
            for (const e of this._elements)
              this._hasRectChanged(e) && t.push({ target: e, contentRect: this._previousRects.get(e) });
            t.length && this._callback(t);
          }
          _hasRectChanged(t) {
            if (!t.ownerDocument.body.contains(t)) return !1;
            const e = new Zr(t),
              o = this._previousRects.get(t),
              i = !o || !o.isEqual(e);
            return this._previousRects.set(t, e), i;
          }
        }
        xo(pc, lr);
        class bc extends sc {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('isVisible', !1),
              this.set('position', 'se'),
              (this.children = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-reset',
                    'ck-dropdown__panel',
                    e.to('position', t => 'ck-dropdown__panel_' + t),
                    e.if('isVisible', 'ck-dropdown__panel-visible'),
                  ],
                },
                children: this.children,
                on: { selectstart: e.to(t => t.preventDefault()) },
              });
          }
          focus() {
            this.children.length && this.children.first.focus();
          }
          focusLast() {
            if (this.children.length) {
              const t = this.children.last;
              'function' == typeof t.focusLast ? t.focusLast() : t.focus();
            }
          }
        }
        o(21);
        function wc({ element: t, target: e, positions: o, limiter: i, fitInViewport: n }) {
          j(e) && (e = e()), j(i) && (i = i());
          const r = (function (t) {
              return t && t.parentNode ? (t.offsetParent === Xn.document.body ? null : t.offsetParent) : null;
            })(t),
            s = new Zr(t),
            a = new Zr(e);
          let l, c;
          if (i || n) {
            const t = (function (t, e) {
              const { elementRect: o, viewportRect: i } = e,
                n = o.getArea(),
                r = (function (t, { targetRect: e, elementRect: o, limiterRect: i, viewportRect: n }) {
                  const r = [],
                    s = o.getArea();
                  for (const a of t) {
                    const t = kc(a, e, o);
                    if (!t) continue;
                    const [l, c] = t;
                    let d = 0,
                      h = 0;
                    if (i)
                      if (n) {
                        const t = i.getIntersection(n);
                        t && (d = t.getIntersectionArea(c));
                      } else d = i.getIntersectionArea(c);
                    n && (h = n.getIntersectionArea(c));
                    const u = { positionName: l, positionRect: c, limiterIntersectArea: d, viewportIntersectArea: h };
                    if (d === s) return [u];
                    r.push(u);
                  }
                  return r;
                })(t, e);
              if (i) {
                const t = _c(
                  r.filter(({ viewportIntersectArea: t }) => t === n),
                  n
                );
                if (t) return t;
              }
              return _c(r, n);
            })(o, {
              targetRect: a,
              elementRect: s,
              limiterRect: i && new Zr(i).getVisible(),
              viewportRect: n && new Zr(Xn.window),
            });
            [c, l] = t || kc(o[0], a, s);
          } else [c, l] = kc(o[0], a, s);
          let d = vc(l);
          return (
            r &&
              (d = (function ({ left: t, top: e }, o) {
                const i = vc(new Zr(o)),
                  n = Kr(o);
                return (
                  (t -= i.left),
                  (e -= i.top),
                  (t += o.scrollLeft),
                  (e += o.scrollTop),
                  (t -= n.left),
                  (e -= n.top),
                  { left: t, top: e }
                );
              })(d, r)),
            { left: d.left, top: d.top, name: c }
          );
        }
        function kc(t, e, o) {
          const i = t(e, o);
          if (!i) return null;
          const { left: n, top: r, name: s } = i;
          return [s, o.clone().moveTo(n, r)];
        }
        function _c(t, e) {
          let o,
            i,
            n = 0;
          for (const { positionName: r, positionRect: s, limiterIntersectArea: a, viewportIntersectArea: l } of t) {
            if (a === e) return [r, s];
            const t = l ** 2 + a ** 2;
            t > n && ((n = t), (o = s), (i = r));
          }
          return o ? [i, o] : null;
        }
        function vc({ left: t, top: e }) {
          const { scrollX: o, scrollY: i } = Xn.window;
          return { left: t + o, top: e + i };
        }
        class yc extends sc {
          constructor(t, e, o) {
            super(t);
            const i = this.bindTemplate;
            (this.buttonView = e),
              (this.panelView = o),
              this.set('isOpen', !1),
              this.set('isEnabled', !0),
              this.set('class'),
              this.set('id'),
              this.set('panelPosition', 'auto'),
              (this.keystrokes = new Cl()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-dropdown', i.to('class'), i.if('isEnabled', 'ck-disabled', t => !t)],
                  id: i.to('id'),
                  'aria-describedby': i.to('ariaDescribedById'),
                },
                children: [e, o],
              }),
              e.extendTemplate({ attributes: { class: ['ck-dropdown__button'] } });
          }
          render() {
            super.render(),
              this.listenTo(this.buttonView, 'open', () => {
                this.isOpen = !this.isOpen;
              }),
              this.panelView.bind('isVisible').to(this, 'isOpen'),
              this.on('change:isOpen', () => {
                this.isOpen &&
                  ('auto' === this.panelPosition
                    ? (this.panelView.position = yc._getOptimalPosition({
                        element: this.panelView.element,
                        target: this.buttonView.element,
                        fitInViewport: !0,
                        positions: this._panelPositions,
                      }).name)
                    : (this.panelView.position = this.panelPosition));
              }),
              this.keystrokes.listenTo(this.element);
            const t = (t, e) => {
              this.isOpen && (this.buttonView.focus(), (this.isOpen = !1), e());
            };
            this.keystrokes.set('arrowdown', (t, e) => {
              this.buttonView.isEnabled && !this.isOpen && ((this.isOpen = !0), e());
            }),
              this.keystrokes.set('arrowright', (t, e) => {
                this.isOpen && e();
              }),
              this.keystrokes.set('arrowleft', t),
              this.keystrokes.set('esc', t);
          }
          focus() {
            this.buttonView.focus();
          }
          get _panelPositions() {
            const { southEast: t, southWest: e, northEast: o, northWest: i } = yc.defaultPanelPositions;
            return 'ltr' === this.locale.uiLanguageDirection ? [t, e, o, i] : [e, t, i, o];
          }
        }
        (yc.defaultPanelPositions = {
          southEast: t => ({ top: t.bottom, left: t.left, name: 'se' }),
          southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: 'sw' }),
          northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: 'ne' }),
          northWest: (t, e) => ({ top: t.bottom - e.height, left: t.left - e.width + t.width, name: 'nw' }),
        }),
          (yc._getOptimalPosition = wc);
        o(23);
        class xc extends sc {
          constructor() {
            super();
            const t = this.bindTemplate;
            this.set('content', ''),
              this.set('viewBox', '0 0 20 20'),
              this.set('fillColor', ''),
              this.setTemplate({
                tag: 'svg',
                ns: 'http://www.w3.org/2000/svg',
                attributes: { class: ['ck', 'ck-icon'], viewBox: t.to('viewBox') },
              });
          }
          render() {
            super.render(),
              this._updateXMLContent(),
              this._colorFillPaths(),
              this.on('change:content', () => {
                this._updateXMLContent(), this._colorFillPaths();
              }),
              this.on('change:fillColor', () => {
                this._colorFillPaths();
              });
          }
          _updateXMLContent() {
            if (this.content) {
              const t = new DOMParser().parseFromString(this.content.trim(), 'image/svg+xml').querySelector('svg'),
                e = t.getAttribute('viewBox');
              for (e && (this.viewBox = e), this.element.innerHTML = ''; t.childNodes.length > 0; )
                this.element.appendChild(t.childNodes[0]);
            }
          }
          _colorFillPaths() {
            this.fillColor &&
              this.element.querySelectorAll('.ck-icon__fill').forEach(t => {
                t.style.fill = this.fillColor;
              });
          }
        }
        o(25);
        class Cc extends sc {
          constructor(t) {
            super(t), this.set('text', ''), this.set('position', 's');
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'span',
              attributes: {
                class: [
                  'ck',
                  'ck-tooltip',
                  e.to('position', t => 'ck-tooltip_' + t),
                  e.if('text', 'ck-hidden', t => !t.trim()),
                ],
              },
              children: [
                { tag: 'span', attributes: { class: ['ck', 'ck-tooltip__text'] }, children: [{ text: e.to('text') }] },
              ],
            });
          }
        }
        o(27);
        class Ac extends sc {
          constructor(t) {
            super(t);
            const e = this.bindTemplate,
              o = co();
            this.set('class'),
              this.set('labelStyle'),
              this.set('icon'),
              this.set('isEnabled', !0),
              this.set('isOn', !1),
              this.set('isVisible', !0),
              this.set('isToggleable', !1),
              this.set('keystroke'),
              this.set('label'),
              this.set('tabindex', -1),
              this.set('tooltip'),
              this.set('tooltipPosition', 's'),
              this.set('type', 'button'),
              this.set('withText', !1),
              this.set('withKeystroke', !1),
              (this.children = this.createCollection()),
              (this.tooltipView = this._createTooltipView()),
              (this.labelView = this._createLabelView(o)),
              (this.iconView = new xc()),
              this.iconView.extendTemplate({ attributes: { class: 'ck-button__icon' } }),
              (this.keystrokeView = this._createKeystrokeView()),
              this.bind('_tooltipString').to(
                this,
                'tooltip',
                this,
                'label',
                this,
                'keystroke',
                this._getTooltipString.bind(this)
              ),
              this.setTemplate({
                tag: 'button',
                attributes: {
                  class: [
                    'ck',
                    'ck-button',
                    e.to('class'),
                    e.if('isEnabled', 'ck-disabled', t => !t),
                    e.if('isVisible', 'ck-hidden', t => !t),
                    e.to('isOn', t => (t ? 'ck-on' : 'ck-off')),
                    e.if('withText', 'ck-button_with-text'),
                    e.if('withKeystroke', 'ck-button_with-keystroke'),
                  ],
                  type: e.to('type', t => t || 'button'),
                  tabindex: e.to('tabindex'),
                  'aria-labelledby': 'ck-editor__aria-label_' + o,
                  'aria-disabled': e.if('isEnabled', !0, t => !t),
                  'aria-pressed': e.to('isOn', t => !!this.isToggleable && String(t)),
                },
                children: this.children,
                on: {
                  mousedown: e.to(t => {
                    t.preventDefault();
                  }),
                  click: e.to(t => {
                    this.isEnabled ? this.fire('execute') : t.preventDefault();
                  }),
                },
              });
          }
          render() {
            super.render(),
              this.icon && (this.iconView.bind('content').to(this, 'icon'), this.children.add(this.iconView)),
              this.children.add(this.tooltipView),
              this.children.add(this.labelView),
              this.withKeystroke && this.children.add(this.keystrokeView);
          }
          focus() {
            this.element.focus();
          }
          _createTooltipView() {
            const t = new Cc();
            return t.bind('text').to(this, '_tooltipString'), t.bind('position').to(this, 'tooltipPosition'), t;
          }
          _createLabelView(t) {
            const e = new sc(),
              o = this.bindTemplate;
            return (
              e.setTemplate({
                tag: 'span',
                attributes: {
                  class: ['ck', 'ck-button__label'],
                  style: o.to('labelStyle'),
                  id: 'ck-editor__aria-label_' + t,
                },
                children: [{ text: this.bindTemplate.to('label') }],
              }),
              e
            );
          }
          _createKeystrokeView() {
            const t = new sc();
            return (
              t.setTemplate({
                tag: 'span',
                attributes: { class: ['ck', 'ck-button__keystroke'] },
                children: [{ text: this.bindTemplate.to('keystroke', t => wn(t)) }],
              }),
              t
            );
          }
          _getTooltipString(t, e, o) {
            return t
              ? 'string' == typeof t
                ? t
                : (o && (o = wn(o)), t instanceof Function ? t(e, o) : `${e}${o ? ` (${o})` : ''}`)
              : '';
          }
        }
        var Tc =
          '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class Sc extends Ac {
          constructor(t) {
            super(t),
              (this.arrowView = this._createArrowView()),
              this.extendTemplate({ attributes: { 'aria-haspopup': !0 } }),
              this.delegate('execute').to(this, 'open');
          }
          render() {
            super.render(), this.children.add(this.arrowView);
          }
          _createArrowView() {
            const t = new xc();
            return (t.content = Tc), t.extendTemplate({ attributes: { class: 'ck-dropdown__arrow' } }), t;
          }
        }
        o(29);
        class Pc extends sc {
          constructor() {
            super(),
              (this.items = this.createCollection()),
              (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this._focusCycler = new uc({
                focusables: this.items,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'arrowup', focusNext: 'arrowdown' },
              })),
              this.setTemplate({
                tag: 'ul',
                attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
                children: this.items,
              });
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.items.on('add', (t, e) => {
              this.focusTracker.add(e.element);
            }),
              this.items.on('remove', (t, e) => {
                this.focusTracker.remove(e.element);
              }),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
        }
        class Ec extends sc {
          constructor(t) {
            super(t),
              (this.children = this.createCollection()),
              this.setTemplate({ tag: 'li', attributes: { class: ['ck', 'ck-list__item'] }, children: this.children });
          }
          focus() {
            this.children.first.focus();
          }
        }
        class Mc extends sc {
          constructor(t) {
            super(t), this.setTemplate({ tag: 'li', attributes: { class: ['ck', 'ck-list__separator'] } });
          }
        }
        o(31);
        class Ic extends Ac {
          constructor(t) {
            super(t),
              (this.isToggleable = !0),
              (this.toggleSwitchView = this._createToggleView()),
              this.extendTemplate({ attributes: { class: 'ck-switchbutton' } });
          }
          render() {
            super.render(), this.children.add(this.toggleSwitchView);
          }
          _createToggleView() {
            const t = new sc();
            return (
              t.setTemplate({
                tag: 'span',
                attributes: { class: ['ck', 'ck-button__toggle'] },
                children: [{ tag: 'span', attributes: { class: ['ck', 'ck-button__toggle__inner'] } }],
              }),
              t
            );
          }
        }
        function Nc({ emitter: t, activator: e, callback: o, contextElements: i }) {
          t.listenTo(document, 'mousedown', (t, { target: n }) => {
            if (e()) {
              for (const t of i) if (t.contains(n)) return;
              o();
            }
          });
        }
        o(33), o(35);
        function Rc(t, e = Sc) {
          const o = new e(t),
            i = new bc(t),
            n = new yc(t, o, i);
          return (
            o.bind('isEnabled').to(n),
            o instanceof Sc ? o.bind('isOn').to(n, 'isOpen') : o.arrowView.bind('isOn').to(n, 'isOpen'),
            (function (t) {
              (function (t) {
                t.on('render', () => {
                  Nc({
                    emitter: t,
                    activator: () => t.isOpen,
                    callback: () => {
                      t.isOpen = !1;
                    },
                    contextElements: [t.element],
                  });
                });
              })(t),
                (function (t) {
                  t.on('execute', e => {
                    e.source instanceof Ic || (t.isOpen = !1);
                  });
                })(t),
                (function (t) {
                  t.keystrokes.set('arrowdown', (e, o) => {
                    t.isOpen && (t.panelView.focus(), o());
                  }),
                    t.keystrokes.set('arrowup', (e, o) => {
                      t.isOpen && (t.panelView.focusLast(), o());
                    });
                })(t);
            })(n),
            n
          );
        }
        function Oc(t, e) {
          const o = t.locale,
            i = o.t,
            n = (t.toolbarView = new Dc(o));
          n.set('ariaLabel', i('Dropdown toolbar')),
            t.extendTemplate({ attributes: { class: ['ck-toolbar-dropdown'] } }),
            e.map(t => n.items.add(t)),
            t.panelView.children.add(n),
            n.items.delegate('execute').to(t);
        }
        function Vc(t, e) {
          const o = t.locale,
            i = (t.listView = new Pc(o));
          i.items.bindTo(e).using(({ type: t, model: e }) => {
            if ('separator' === t) return new Mc(o);
            if ('button' === t || 'switchbutton' === t) {
              const i = new Ec(o);
              let n;
              return (
                (n = 'button' === t ? new Ac(o) : new Ic(o)),
                n.bind(...Object.keys(e)).to(e),
                n.delegate('execute').to(i),
                i.children.add(n),
                i
              );
            }
          }),
            t.panelView.children.add(i),
            i.items.delegate('execute').to(t);
        }
        o(37);
        class Dc extends sc {
          constructor(t, e) {
            super(t);
            const o = this.bindTemplate,
              i = this.t;
            var n;
            (this.options = e || {}),
              this.set('ariaLabel', i('Editor toolbar')),
              this.set('maxWidth', 'auto'),
              (this.items = this.createCollection()),
              (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              this.set('class'),
              this.set('isCompact', !1),
              (this.itemsView = new zc(t)),
              (this.children = this.createCollection()),
              this.children.add(this.itemsView),
              (this.focusables = this.createCollection()),
              (this._focusCycler = new uc({
                focusables: this.focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: ['arrowleft', 'arrowup'], focusNext: ['arrowright', 'arrowdown'] },
              })),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-toolbar', o.to('class'), o.if('isCompact', 'ck-toolbar_compact')],
                  role: 'toolbar',
                  'aria-label': o.to('ariaLabel'),
                  style: { maxWidth: o.to('maxWidth') },
                },
                children: this.children,
                on: {
                  mousedown:
                    ((n = this),
                    n.bindTemplate.to(t => {
                      t.target === n.element && t.preventDefault();
                    })),
                },
              }),
              (this._behavior = this.options.shouldGroupWhenFull ? new jc(this) : new Lc(this));
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.items.on('add', (t, e) => {
              this.focusTracker.add(e.element);
            }),
              this.items.on('remove', (t, e) => {
                this.focusTracker.remove(e.element);
              }),
              this.keystrokes.listenTo(this.element),
              this._behavior.render(this);
          }
          destroy() {
            return this._behavior.destroy(), super.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          fillFromConfig(t, e) {
            t.map(t => {
              '|' == t
                ? this.items.add(new mc())
                : e.has(t)
                ? this.items.add(e.create(t))
                : console.warn(
                    Object(uo.a)('toolbarview-item-unavailable: The requested toolbar item is unavailable.'),
                    { name: t }
                  );
            });
          }
        }
        class zc extends sc {
          constructor(t) {
            super(t),
              (this.children = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-toolbar__items'] },
                children: this.children,
              });
          }
        }
        class Lc {
          constructor(t) {
            const e = t.bindTemplate;
            t.set('isVertical', !1),
              t.itemsView.children.bindTo(t.items).using(t => t),
              t.focusables.bindTo(t.items).using(t => t),
              t.extendTemplate({ attributes: { class: [e.if('isVertical', 'ck-toolbar_vertical')] } });
          }
          render() {}
          destroy() {}
        }
        class jc {
          constructor(t) {
            (this.viewChildren = t.children),
              (this.viewFocusables = t.focusables),
              (this.viewItemsView = t.itemsView),
              (this.viewFocusTracker = t.focusTracker),
              (this.viewLocale = t.locale),
              (this.ungroupedItems = t.createCollection()),
              (this.groupedItems = t.createCollection()),
              (this.groupedItemsDropdown = this._createGroupedItemsDropdown()),
              (this.resizeObserver = null),
              (this.cachedPadding = null),
              (this.shouldUpdateGroupingOnNextResize = !1),
              t.itemsView.children.bindTo(this.ungroupedItems).using(t => t),
              this.ungroupedItems.on('add', this._updateFocusCycleableItems.bind(this)),
              this.ungroupedItems.on('remove', this._updateFocusCycleableItems.bind(this)),
              t.children.on('add', this._updateFocusCycleableItems.bind(this)),
              t.children.on('remove', this._updateFocusCycleableItems.bind(this)),
              t.items.on('add', (t, e, o) => {
                o > this.ungroupedItems.length
                  ? this.groupedItems.add(e, o - this.ungroupedItems.length)
                  : this.ungroupedItems.add(e, o),
                  this._updateGrouping();
              }),
              t.items.on('remove', (t, e, o) => {
                o > this.ungroupedItems.length ? this.groupedItems.remove(e) : this.ungroupedItems.remove(e),
                  this._updateGrouping();
              }),
              t.extendTemplate({ attributes: { class: ['ck-toolbar_grouping'] } });
          }
          render(t) {
            (this.viewElement = t.element), this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t);
          }
          destroy() {
            this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
          }
          _updateGrouping() {
            if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
            if (!this.viewElement.offsetParent) return void (this.shouldUpdateGroupingOnNextResize = !0);
            let t;
            for (; this._areItemsOverflowing; ) this._groupLastItem(), (t = !0);
            if (!t && this.groupedItems.length) {
              for (; this.groupedItems.length && !this._areItemsOverflowing; ) this._ungroupFirstItem();
              this._areItemsOverflowing && this._groupLastItem();
            }
          }
          get _areItemsOverflowing() {
            if (!this.ungroupedItems.length) return !1;
            const t = this.viewElement,
              e = this.viewLocale.uiLanguageDirection,
              o = new Zr(t.lastChild),
              i = new Zr(t);
            if (!this.cachedPadding) {
              const o = Xn.window.getComputedStyle(t),
                i = 'ltr' === e ? 'paddingRight' : 'paddingLeft';
              this.cachedPadding = Number.parseInt(o[i]);
            }
            return 'ltr' === e ? o.right > i.right - this.cachedPadding : o.left < i.left + this.cachedPadding;
          }
          _enableGroupingOnResize() {
            let t;
            (this.resizeObserver = new fc(this.viewElement, e => {
              (t && t === e.contentRect.width && !this.shouldUpdateGroupingOnNextResize) ||
                ((this.shouldUpdateGroupingOnNextResize = !1), this._updateGrouping(), (t = e.contentRect.width));
            })),
              this._updateGrouping();
          }
          _enableGroupingOnMaxWidthChange(t) {
            t.on('change:maxWidth', () => {
              this._updateGrouping();
            });
          }
          _groupLastItem() {
            this.groupedItems.length ||
              (this.viewChildren.add(new mc()),
              this.viewChildren.add(this.groupedItemsDropdown),
              this.viewFocusTracker.add(this.groupedItemsDropdown.element)),
              this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
          }
          _ungroupFirstItem() {
            this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)),
              this.groupedItems.length ||
                (this.viewChildren.remove(this.groupedItemsDropdown),
                this.viewChildren.remove(this.viewChildren.last),
                this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
          }
          _createGroupedItemsDropdown() {
            const t = this.viewLocale,
              e = t.t,
              o = Rc(t);
            return (
              (o.class = 'ck-toolbar__grouped-dropdown'),
              (o.panelPosition = 'ltr' === t.uiLanguageDirection ? 'sw' : 'se'),
              Oc(o, []),
              o.buttonView.set({
                label: e('Show more items'),
                tooltip: !0,
                icon:
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>',
              }),
              o.toolbarView.items.bindTo(this.groupedItems).using(t => t),
              o
            );
          }
          _updateFocusCycleableItems() {
            this.viewFocusables.clear(),
              this.ungroupedItems.map(t => {
                this.viewFocusables.add(t);
              }),
              this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
        class Bc extends cc {
          constructor(t, e, o = {}) {
            super(t),
              (this.toolbar = new Dc(t, { shouldGroupWhenFull: o.shouldToolbarGroupWhenFull })),
              (this.editable = new hc(t, e, o.editableElement)),
              this.toolbar.extendTemplate({
                attributes: { class: ['ck-reset_all', 'ck-rounded-corners'], dir: t.uiLanguageDirection },
              });
          }
          render() {
            super.render(), this.registerChild([this.toolbar, this.editable]);
          }
        }
        class Fc extends Tl {
          constructor(t, e) {
            super(e),
              oo(t) &&
                ((this.sourceElement = t),
                (function (t) {
                  const e = t.sourceElement;
                  if (e) {
                    if (e.ckeditorInstance)
                      throw new uo.b(
                        'editor-source-element-already-used: The DOM element cannot be used to create multiple editor instances.',
                        t
                      );
                    (e.ckeditorInstance = t),
                      t.once('destroy', () => {
                        delete e.ckeditorInstance;
                      });
                  }
                })(this)),
              (this.data.processor = new El(this.data.viewDocument)),
              this.model.document.createRoot();
            const o = !this.config.get('toolbar.shouldNotGroupWhenFull'),
              i = new Bc(this.locale, this.editing.view, {
                editableElement: this.sourceElement,
                shouldToolbarGroupWhenFull: o,
              });
            this.ui = new jl(this, i);
          }
          destroy() {
            const t = this.getData();
            return (
              this.ui.destroy(),
              super.destroy().then(() => {
                this.sourceElement &&
                  (function (t, e) {
                    t instanceof HTMLTextAreaElement && (t.value = e), (t.innerHTML = e);
                  })(this.sourceElement, t);
              })
            );
          }
          static create(t, e = {}) {
            return new Promise(o => {
              const i = oo(t);
              if (i && 'TEXTAREA' === t.tagName)
                throw new uo.b(
                  'editor-wrong-element: This type of editor cannot be initialized inside <textarea> element.',
                  null
                );
              const n = new this(t, e);
              o(
                n
                  .initPlugins()
                  .then(() => {
                    n.ui.init();
                  })
                  .then(() => {
                    if (!i && e.initialData)
                      throw new uo.b(
                        'editor-create-initial-data: The config.initialData option cannot be used together with initial data passed in Editor.create().',
                        null
                      );
                    const o =
                      e.initialData ||
                      (function (t) {
                        return oo(t) ? ((e = t), e instanceof HTMLTextAreaElement ? e.value : e.innerHTML) : t;
                        var e;
                      })(t);
                    return n.data.init(o);
                  })
                  .then(() => n.fire('ready'))
                  .then(() => n)
              );
            });
          }
        }
        xo(Fc, Sl);
        class Hc {
          constructor(t) {
            (this.editor = t), this.set('isEnabled', !0), (this._disableStack = new Set());
          }
          forceDisabled(t) {
            this._disableStack.add(t),
              1 == this._disableStack.size &&
                (this.on('set:isEnabled', Wc, { priority: 'highest' }), (this.isEnabled = !1));
          }
          clearForceDisabled(t) {
            this._disableStack.delete(t),
              0 == this._disableStack.size && (this.off('set:isEnabled', Wc), (this.isEnabled = !0));
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return !1;
          }
        }
        function Wc(t) {
          (t.return = !1), t.stop();
        }
        xo(Hc, Hi);
        class Uc {
          constructor(t) {
            (this.editor = t),
              this.set('value', void 0),
              this.set('isEnabled', !1),
              (this._disableStack = new Set()),
              this.decorate('execute'),
              this.listenTo(this.editor.model.document, 'change', () => {
                this.refresh();
              }),
              this.on(
                'execute',
                t => {
                  this.isEnabled || t.stop();
                },
                { priority: 'high' }
              ),
              this.listenTo(t, 'change:isReadOnly', (t, e, o) => {
                o ? this.forceDisabled('readOnlyMode') : this.clearForceDisabled('readOnlyMode');
              });
          }
          refresh() {
            this.isEnabled = !0;
          }
          forceDisabled(t) {
            this._disableStack.add(t),
              1 == this._disableStack.size &&
                (this.on('set:isEnabled', qc, { priority: 'highest' }), (this.isEnabled = !1));
          }
          clearForceDisabled(t) {
            this._disableStack.delete(t),
              0 == this._disableStack.size && (this.off('set:isEnabled', qc), this.refresh());
          }
          execute() {}
          destroy() {
            this.stopListening();
          }
        }
        function qc(t) {
          (t.return = !1), t.stop();
        }
        function Gc(t) {
          const e = t.next();
          return e.done ? null : e.value;
        }
        xo(Uc, Hi);
        const Yc = ['left', 'right', 'center', 'justify'];
        function $c(t) {
          return Yc.includes(t);
        }
        function Qc(t, e) {
          return 'rtl' == e.contentLanguageDirection ? 'right' === t : 'left' === t;
        }
        class Kc extends Uc {
          refresh() {
            const t = this.editor.locale,
              e = Gc(this.editor.model.document.selection.getSelectedBlocks());
            (this.isEnabled = !!e && this._canBeAligned(e)),
              this.isEnabled && e.hasAttribute('alignment')
                ? (this.value = e.getAttribute('alignment'))
                : (this.value = 'rtl' === t.contentLanguageDirection ? 'right' : 'left');
          }
          execute(t = {}) {
            const e = this.editor,
              o = e.locale,
              i = e.model,
              n = i.document,
              r = t.value;
            i.change(t => {
              const e = Array.from(n.selection.getSelectedBlocks()).filter(t => this._canBeAligned(t)),
                i = e[0].getAttribute('alignment');
              Qc(r, o) || i === r || !r
                ? (function (t, e) {
                    for (const o of t) e.removeAttribute('alignment', o);
                  })(e, t)
                : (function (t, e, o) {
                    for (const i of t) e.setAttribute('alignment', o, i);
                  })(e, t, r);
            });
          }
          _canBeAligned(t) {
            return this.editor.model.schema.checkAttribute(t, 'alignment');
          }
        }
        class Jc extends Hc {
          static get pluginName() {
            return 'AlignmentEditing';
          }
          constructor(t) {
            super(t), t.config.define('alignment', { options: [...Yc] });
          }
          init() {
            const t = this.editor,
              e = t.locale,
              o = t.model.schema,
              i = t.config.get('alignment.options').filter($c);
            o.extend('$block', { allowAttributes: 'alignment' }),
              t.model.schema.setAttributeProperties('alignment', { isFormatting: !0 });
            const n = (function (t) {
              const e = { model: { key: 'alignment', values: t.slice() }, view: {} };
              for (const o of t) e.view[o] = { key: 'style', value: { 'text-align': o } };
              return e;
            })(i.filter(t => !Qc(t, e)));
            t.conversion.attributeToAttribute(n), t.commands.add('alignment', new Kc(t));
          }
        }
        var Zc =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
          Xc =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
          td =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
          ed =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        const od = new Map([
          ['left', Zc],
          ['right', Xc],
          ['center', td],
          ['justify', ed],
        ]);
        class id extends Hc {
          get localizedOptionTitles() {
            const t = this.editor.t;
            return { left: t('Align left'), right: t('Align right'), center: t('Align center'), justify: t('Justify') };
          }
          static get pluginName() {
            return 'AlignmentUI';
          }
          init() {
            const t = this.editor,
              e = t.ui.componentFactory,
              o = t.t,
              i = t.config.get('alignment.options');
            i.filter($c).forEach(t => this._addButton(t)),
              e.add('alignment', t => {
                const n = Rc(t),
                  r = i.map(t => e.create('alignment:' + t));
                Oc(n, r),
                  n.buttonView.set({ label: o('Text alignment'), tooltip: !0 }),
                  (n.toolbarView.isVertical = !0),
                  (n.toolbarView.ariaLabel = o('Text alignment toolbar')),
                  n.extendTemplate({ attributes: { class: 'ck-alignment-dropdown' } });
                const s = 'rtl' === t.contentLanguageDirection ? Xc : Zc;
                return (
                  n.buttonView.bind('icon').toMany(r, 'isOn', (...t) => {
                    const e = t.findIndex(t => t);
                    return e < 0 ? s : r[e].icon;
                  }),
                  n.bind('isEnabled').toMany(r, 'isEnabled', (...t) => t.some(t => t)),
                  n
                );
              });
          }
          _addButton(t) {
            const e = this.editor;
            e.ui.componentFactory.add('alignment:' + t, o => {
              const i = e.commands.get('alignment'),
                n = new Ac(o);
              return (
                n.set({ label: this.localizedOptionTitles[t], icon: od.get(t), tooltip: !0, isToggleable: !0 }),
                n.bind('isEnabled').to(i),
                n.bind('isOn').to(i, 'value', e => e === t),
                this.listenTo(n, 'execute', () => {
                  e.execute('alignment', { value: t }), e.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        class nd {
          static get pluginName() {
            return 'BlockAutoformatEditing';
          }
          constructor(t, e, o) {
            let i,
              n = null;
            'function' == typeof o
              ? (i = o)
              : ((n = t.commands.get(o)),
                (i = () => {
                  t.execute(o);
                })),
              t.model.document.on('change', (o, r) => {
                if (n && !n.isEnabled) return;
                if ('transparent' == r.type) return;
                const s = Array.from(t.model.document.differ.getChanges()),
                  a = s[0];
                if (1 != s.length || 'insert' !== a.type || '$text' != a.name || 1 != a.length) return;
                const l = a.position.parent;
                if (!l.is('paragraph') || 1 !== l.childCount) return;
                const c = e.exec(l.getChild(0).data);
                c &&
                  t.model.enqueueChange(t => {
                    const e = t.createPositionAt(l, 0),
                      o = t.createPositionAt(l, c[0].length),
                      n = new Os(e, o);
                    !1 !== i({ match: c }) && t.remove(n), n.detach();
                  });
              });
          }
        }
        function rd(t, e) {
          let o = t.start;
          return {
            text: Array.from(t.getItems()).reduce(
              (t, i) => (i.is('text') || i.is('textProxy') ? t + i.data : ((o = e.createPositionAfter(i)), '')),
              ''
            ),
            range: e.createRange(o, t.end),
          };
        }
        class sd {
          static get pluginName() {
            return 'InlineAutoformatEditing';
          }
          constructor(t, e, o) {
            let i, n, r, s;
            e instanceof RegExp ? (i = e) : (r = e),
              'string' == typeof o ? (n = o) : (s = o),
              (r =
                r ||
                (t => {
                  let e;
                  const o = [],
                    n = [];
                  for (; null !== (e = i.exec(t)) && !(e && e.length < 4); ) {
                    let { index: t, 1: i, 2: r, 3: s } = e;
                    const a = i + r + s;
                    t += e[0].length - a.length;
                    const l = [t, t + i.length],
                      c = [t + i.length + r.length, t + i.length + r.length + s.length];
                    o.push(l), o.push(c), n.push([t + i.length, t + i.length + r.length]);
                  }
                  return { remove: o, format: n };
                })),
              (s =
                s ||
                ((e, o) => {
                  const i = t.model.schema.getValidRanges(o, n);
                  for (const t of i) e.setAttribute(n, !0, t);
                  e.removeSelectionAttribute(n);
                })),
              t.model.document.on('change', (e, o) => {
                if ('transparent' == o.type) return;
                const i = t.model,
                  n = i.document.selection;
                if (!n.isCollapsed) return;
                const a = Array.from(i.document.differ.getChanges()),
                  l = a[0];
                if (1 != a.length || 'insert' !== l.type || '$text' != l.name || 1 != l.length) return;
                const c = n.focus,
                  d = c.parent,
                  { text: h, range: u } = rd(i.createRange(i.createPositionAt(d, 0), c), i),
                  g = r(h),
                  m = ad(u.start, g.format, i),
                  f = ad(u.start, g.remove, i);
                m.length &&
                  f.length &&
                  i.enqueueChange(t => {
                    if (!1 !== s(t, m)) for (const e of f.reverse()) t.remove(e);
                  });
              });
          }
        }
        function ad(t, e, o) {
          return e
            .filter(t => void 0 !== t[0] && void 0 !== t[1])
            .map(e => o.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])));
        }
        function ld(t, e) {
          return (o, i) => {
            if (!t.commands.get(e).isEnabled) return !1;
            const n = t.model.schema.getValidRanges(i, e);
            for (const t of n) o.setAttribute(e, !0, t);
            o.removeSelectionAttribute(e);
          };
        }
        class cd extends Uc {
          refresh() {
            (this.value = this._getValue()), (this.isEnabled = this._checkEnabled());
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.schema,
              i = e.document.selection,
              n = Array.from(i.getSelectedBlocks()),
              r = void 0 === t.forceValue ? !this.value : t.forceValue;
            e.change(t => {
              if (r) {
                const e = n.filter(t => dd(t) || ud(o, t));
                this._applyQuote(t, e);
              } else this._removeQuote(t, n.filter(dd));
            });
          }
          _getValue() {
            const t = Gc(this.editor.model.document.selection.getSelectedBlocks());
            return !(!t || !dd(t));
          }
          _checkEnabled() {
            if (this.value) return !0;
            const t = this.editor.model.document.selection,
              e = this.editor.model.schema,
              o = Gc(t.getSelectedBlocks());
            return !!o && ud(e, o);
          }
          _removeQuote(t, e) {
            hd(t, e)
              .reverse()
              .forEach(e => {
                if (e.start.isAtStart && e.end.isAtEnd) return void t.unwrap(e.start.parent);
                if (e.start.isAtStart) {
                  const o = t.createPositionBefore(e.start.parent);
                  return void t.move(e, o);
                }
                e.end.isAtEnd || t.split(e.end);
                const o = t.createPositionAfter(e.end.parent);
                t.move(e, o);
              });
          }
          _applyQuote(t, e) {
            const o = [];
            hd(t, e)
              .reverse()
              .forEach(e => {
                let i = dd(e.start);
                i || ((i = t.createElement('blockQuote')), t.wrap(e, i)), o.push(i);
              }),
              o.reverse().reduce((e, o) => (e.nextSibling == o ? (t.merge(t.createPositionAfter(e)), e) : o));
          }
        }
        function dd(t) {
          return 'blockQuote' == t.parent.name ? t.parent : null;
        }
        function hd(t, e) {
          let o,
            i = 0;
          const n = [];
          for (; i < e.length; ) {
            const r = e[i],
              s = e[i + 1];
            o || (o = t.createPositionBefore(r)),
              (s && r.nextSibling == s) || (n.push(t.createRange(o, t.createPositionAfter(r))), (o = null)),
              i++;
          }
          return n;
        }
        function ud(t, e) {
          const o = t.checkChild(e.parent, 'blockQuote'),
            i = t.checkChild(['$root', 'blockQuote'], e);
          return o && i;
        }
        class gd extends Hc {
          static get pluginName() {
            return 'BlockQuoteEditing';
          }
          init() {
            const t = this.editor,
              e = t.model.schema;
            t.commands.add('blockQuote', new cd(t)),
              e.register('blockQuote', { allowWhere: '$block', allowContentOf: '$root' }),
              e.addChildCheck((t, e) => {
                if (t.endsWith('blockQuote') && 'blockQuote' == e.name) return !1;
              }),
              t.conversion.elementToElement({ model: 'blockQuote', view: 'blockquote' }),
              t.model.document.registerPostFixer(o => {
                const i = t.model.document.differ.getChanges();
                for (const t of i)
                  if ('insert' == t.type) {
                    const i = t.position.nodeAfter;
                    if (!i) continue;
                    if (i.is('blockQuote') && i.isEmpty) return o.remove(i), !0;
                    if (i.is('blockQuote') && !e.checkChild(t.position, i)) return o.unwrap(i), !0;
                    if (i.is('element')) {
                      const t = o.createRangeIn(i);
                      for (const i of t.getItems())
                        if (i.is('blockQuote') && !e.checkChild(o.createPositionBefore(i), i)) return o.unwrap(i), !0;
                    }
                  } else if ('remove' == t.type) {
                    const e = t.position.parent;
                    if (e.is('blockQuote') && e.isEmpty) return o.remove(e), !0;
                  }
                return !1;
              });
          }
          afterInit() {
            const t = this.editor.commands.get('blockQuote');
            this.listenTo(this.editor.editing.view.document, 'enter', (e, o) => {
              const i = this.editor.model.document,
                n = i.selection.getLastPosition().parent;
              i.selection.isCollapsed &&
                n.isEmpty &&
                t.value &&
                (this.editor.execute('blockQuote'),
                this.editor.editing.view.scrollToTheSelection(),
                o.preventDefault(),
                e.stop());
            });
          }
        }
        o(39);
        class md extends Hc {
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('blockQuote', o => {
              const i = t.commands.get('blockQuote'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Block quote'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                n.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  t.execute('blockQuote'), t.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        class fd extends Uc {
          constructor(t, e) {
            super(t), (this.attributeKey = e);
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            (this.value = this._getValueFromFirstAllowedNode()),
              (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey));
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document.selection,
              i = void 0 === t.forceValue ? !this.value : t.forceValue;
            e.change(t => {
              if (o.isCollapsed)
                i ? t.setSelectionAttribute(this.attributeKey, !0) : t.removeSelectionAttribute(this.attributeKey);
              else {
                const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey);
                for (const e of n)
                  i ? t.setAttribute(this.attributeKey, i, e) : t.removeAttribute(this.attributeKey, e);
              }
            });
          }
          _getValueFromFirstAllowedNode() {
            const t = this.editor.model,
              e = t.schema,
              o = t.document.selection;
            if (o.isCollapsed) return o.hasAttribute(this.attributeKey);
            for (const t of o.getRanges())
              for (const o of t.getItems())
                if (e.checkAttribute(o, this.attributeKey)) return o.hasAttribute(this.attributeKey);
            return !1;
          }
        }
        class pd extends Hc {
          static get pluginName() {
            return 'BoldEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'bold' }),
              t.model.schema.setAttributeProperties('bold', { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: 'bold',
                view: 'strong',
                upcastAlso: [
                  'b',
                  t => {
                    const e = t.getStyle('font-weight');
                    return e
                      ? 'bold' == e || Number(e) >= 600
                        ? { name: !0, styles: ['font-weight'] }
                        : void 0
                      : null;
                  },
                ],
              }),
              t.commands.add('bold', new fd(t, 'bold')),
              t.keystrokes.set('CTRL+B', 'bold');
          }
        }
        class bd extends Hc {
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('bold', o => {
              const i = t.commands.get('bold'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Bold'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
                  keystroke: 'CTRL+B',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                n.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  t.execute('bold'), t.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        class wd {
          constructor(t) {
            (this.files = (function (t) {
              const e = t.files ? Array.from(t.files) : [],
                o = t.items ? Array.from(t.items) : [];
              if (e.length) return e;
              return o.filter(t => 'file' === t.kind).map(t => t.getAsFile());
            })(t)),
              (this._native = t);
          }
          get types() {
            return this._native.types;
          }
          getData(t) {
            return this._native.getData(t);
          }
          setData(t, e) {
            this._native.setData(t, e);
          }
        }
        class kd extends Nr {
          constructor(t) {
            super(t);
            const e = this.document;
            function o(t, o) {
              o.preventDefault();
              const i = o.dropRange ? [o.dropRange] : Array.from(e.selection.getRanges()),
                n = new ao(e, 'clipboardInput');
              e.fire(n, { dataTransfer: o.dataTransfer, targetRanges: i }), n.stop.called && o.stopPropagation();
            }
            (this.domEventType = ['paste', 'copy', 'cut', 'drop', 'dragover']),
              this.listenTo(e, 'paste', o, { priority: 'low' }),
              this.listenTo(e, 'drop', o, { priority: 'low' });
          }
          onDomEvent(t) {
            const e = { dataTransfer: new wd(t.clipboardData ? t.clipboardData : t.dataTransfer) };
            'drop' == t.type &&
              (e.dropRange = (function (t, e) {
                const o = e.target.ownerDocument,
                  i = e.clientX,
                  n = e.clientY;
                let r;
                o.caretRangeFromPoint && o.caretRangeFromPoint(i, n)
                  ? (r = o.caretRangeFromPoint(i, n))
                  : e.rangeParent && ((r = o.createRange()), r.setStart(e.rangeParent, e.rangeOffset), r.collapse(!0));
                return r ? t.domConverter.domRangeToView(r) : t.document.selection.getFirstRange();
              })(this.view, t)),
              this.fire(t.type, t, e);
          }
        }
        const _d = ['figcaption', 'li'];
        class vd extends Hc {
          static get pluginName() {
            return 'Clipboard';
          }
          init() {
            const t = this.editor,
              e = t.model.document,
              o = t.editing.view,
              i = o.document;
            function n(o, n) {
              const r = n.dataTransfer;
              n.preventDefault();
              const s = t.data.toView(t.model.getSelectedContent(e.selection));
              i.fire('clipboardOutput', { dataTransfer: r, content: s, method: o.name });
            }
            (this._htmlDataProcessor = new El(i)),
              o.addObserver(kd),
              this.listenTo(
                i,
                'clipboardInput',
                e => {
                  t.isReadOnly && e.stop();
                },
                { priority: 'highest' }
              ),
              this.listenTo(
                i,
                'clipboardInput',
                (t, e) => {
                  const i = e.dataTransfer;
                  let n = '';
                  var r;
                  i.getData('text/html')
                    ? (n = (function (t) {
                        return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) =>
                          1 == e.length ? ' ' : e
                        );
                      })(i.getData('text/html')))
                    : i.getData('text/plain') &&
                      ((r = (r = i.getData('text/plain'))
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '</p><p>')
                        .replace(/^\s/, '&nbsp;')
                        .replace(/\s$/, '&nbsp;')
                        .replace(/\s\s/g, ' &nbsp;')).indexOf('</p><p>') > -1 && (r = `<p>${r}</p>`),
                      (n = r)),
                    (n = this._htmlDataProcessor.toView(n));
                  const s = new ao(this, 'inputTransformation');
                  this.fire(s, { content: n, dataTransfer: i }), s.stop.called && t.stop(), o.scrollToTheSelection();
                },
                { priority: 'low' }
              ),
              this.listenTo(
                this,
                'inputTransformation',
                (t, e) => {
                  if (!e.content.isEmpty) {
                    const o = this.editor.data,
                      i = this.editor.model,
                      n = o.toModel(e.content, '$clipboardHolder');
                    if (0 == n.childCount) return;
                    i.insertContent(n), t.stop();
                  }
                },
                { priority: 'low' }
              ),
              this.listenTo(i, 'copy', n, { priority: 'low' }),
              this.listenTo(
                i,
                'cut',
                (e, o) => {
                  t.isReadOnly ? o.preventDefault() : n(e, o);
                },
                { priority: 'low' }
              ),
              this.listenTo(
                i,
                'clipboardOutput',
                (o, i) => {
                  i.content.isEmpty ||
                    (i.dataTransfer.setData('text/html', this._htmlDataProcessor.toData(i.content)),
                    i.dataTransfer.setData(
                      'text/plain',
                      (function t(e) {
                        let o = '';
                        if (e.is('text') || e.is('textProxy')) o = e.data;
                        else if (e.is('img') && e.hasAttribute('alt')) o = e.getAttribute('alt');
                        else {
                          let i = null;
                          for (const n of e.getChildren()) {
                            const e = t(n);
                            i &&
                              (i.is('containerElement') || n.is('containerElement')) &&
                              (_d.includes(i.name) || _d.includes(n.name) ? (o += '\n') : (o += '\n\n')),
                              (o += e),
                              (i = n);
                          }
                        }
                        return o;
                      })(i.content)
                    )),
                    'cut' == i.method && t.model.deleteContent(e.selection);
                },
                { priority: 'low' }
              );
          }
        }
        function* yd(t, e) {
          for (const o of e) o && t.getAttributeProperties(o[0]).copyOnEnter && (yield o);
        }
        class xd extends Uc {
          execute() {
            const t = this.editor.model,
              e = t.document;
            t.change(o => {
              !(function (t, e, o, i) {
                const n = o.isCollapsed,
                  r = o.getFirstRange(),
                  s = r.start.parent,
                  a = r.end.parent;
                if (i.isLimit(s) || i.isLimit(a)) return void (n || s != a || t.deleteContent(o));
                if (n) {
                  const t = yd(e.model.schema, o.getAttributes());
                  Cd(e, r.start), e.setSelectionAttribute(t);
                } else {
                  const i = !(r.start.isAtStart && r.end.isAtEnd),
                    n = s == a;
                  t.deleteContent(o, { leaveUnmerged: i }), i && (n ? Cd(e, o.focus) : e.setSelection(a, 0));
                }
              })(this.editor.model, o, e.selection, t.schema),
                this.fire('afterExecute', { writer: o });
            });
          }
        }
        function Cd(t, e) {
          t.split(e), t.setSelection(e.parent.nextSibling, 0);
        }
        class Ad extends hr {
          constructor(t) {
            super(t);
            const e = this.document;
            e.on('keydown', (t, o) => {
              if (this.isEnabled && o.keyCode == fn.enter) {
                let i;
                e.once('enter', t => (i = t), { priority: 'highest' }),
                  e.fire('enter', new Ir(e, o.domEvent, { isSoft: o.shiftKey })),
                  i && i.stop.called && t.stop();
              }
            });
          }
          observe() {}
        }
        class Td extends Hc {
          static get pluginName() {
            return 'Enter';
          }
          init() {
            const t = this.editor,
              e = t.editing.view,
              o = e.document;
            e.addObserver(Ad),
              t.commands.add('enter', new xd(t)),
              this.listenTo(
                o,
                'enter',
                (o, i) => {
                  i.preventDefault(), i.isSoft || (t.execute('enter'), e.scrollToTheSelection());
                },
                { priority: 'low' }
              );
          }
        }
        class Sd extends Uc {
          execute() {
            const t = this.editor.model,
              e = t.document;
            t.change(o => {
              !(function (t, e, o) {
                const i = o.isCollapsed,
                  n = o.getFirstRange(),
                  r = n.start.parent,
                  s = n.end.parent,
                  a = r == s;
                if (i) {
                  const i = yd(t.schema, o.getAttributes());
                  Pd(t, e, n.end), e.removeSelectionAttribute(o.getAttributeKeys()), e.setSelectionAttribute(i);
                } else {
                  const i = !(n.start.isAtStart && n.end.isAtEnd);
                  t.deleteContent(o, { leaveUnmerged: i }), a ? Pd(t, e, o.focus) : i && e.setSelection(s, 0);
                }
              })(t, o, e.selection),
                this.fire('afterExecute', { writer: o });
            });
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            this.isEnabled = (function (t, e) {
              if (e.rangeCount > 1) return !1;
              const o = e.anchor;
              if (!o || !t.checkChild(o, 'softBreak')) return !1;
              const i = e.getFirstRange(),
                n = i.start.parent,
                r = i.end.parent;
              if ((Ed(n, t) || Ed(r, t)) && n !== r) return !1;
              return !0;
            })(t.schema, e.selection);
          }
        }
        function Pd(t, e, o) {
          const i = e.createElement('softBreak');
          t.insertContent(i, o), e.setSelection(i, 'after');
        }
        function Ed(t, e) {
          return !t.is('rootElement') && (e.isLimit(t) || Ed(t.parent, e));
        }
        class Md extends Hc {
          static get pluginName() {
            return 'ShiftEnter';
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              o = t.conversion,
              i = t.editing.view,
              n = i.document;
            e.register('softBreak', { allowWhere: '$text', isInline: !0 }),
              o.for('upcast').elementToElement({ model: 'softBreak', view: 'br' }),
              o.for('downcast').elementToElement({ model: 'softBreak', view: (t, e) => e.createEmptyElement('br') }),
              i.addObserver(Ad),
              t.commands.add('shiftEnter', new Sd(t)),
              this.listenTo(
                n,
                'enter',
                (e, o) => {
                  o.preventDefault(), o.isSoft && (t.execute('shiftEnter'), i.scrollToTheSelection());
                },
                { priority: 'low' }
              );
          }
        }
        class Id extends Uc {
          execute() {
            const t = this.editor.model,
              e = t.schema.getLimitElement(t.document.selection);
            t.change(t => {
              t.setSelection(e, 'in');
            });
          }
        }
        const Nd = bn('Ctrl+A');
        class Rd extends Hc {
          static get pluginName() {
            return 'SelectAllEditing';
          }
          init() {
            const t = this.editor,
              e = t.editing.view.document;
            t.commands.add('selectAll', new Id(t)),
              this.listenTo(e, 'keydown', (e, o) => {
                pn(o) === Nd && (t.execute('selectAll'), o.preventDefault());
              });
          }
        }
        class Od extends Hc {
          static get pluginName() {
            return 'SelectAllUI';
          }
          init() {
            const t = this.editor;
            t.ui.componentFactory.add('selectAll', e => {
              const o = t.commands.get('selectAll'),
                i = new Ac(e),
                n = e.t;
              return (
                i.set({
                  label: n('Select all'),
                  icon:
                    '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                  keystroke: 'Ctrl+A',
                  tooltip: !0,
                }),
                i.bind('isOn', 'isEnabled').to(o, 'value', 'isEnabled'),
                this.listenTo(i, 'execute', () => {
                  t.execute('selectAll'), t.editing.view.focus();
                }),
                i
              );
            });
          }
        }
        class Vd extends Hc {
          static get requires() {
            return [Rd, Od];
          }
          static get pluginName() {
            return 'SelectAll';
          }
        }
        class Dd {
          constructor(t, e = 20) {
            (this.model = t),
              (this.size = 0),
              (this.limit = e),
              (this.isLocked = !1),
              (this._changeCallback = (t, e) => {
                'transparent' != e.type && e !== this._batch && this._reset(!0);
              }),
              (this._selectionChangeCallback = () => {
                this._reset();
              }),
              this.model.document.on('change', this._changeCallback),
              this.model.document.selection.on('change:range', this._selectionChangeCallback),
              this.model.document.selection.on('change:attribute', this._selectionChangeCallback);
          }
          get batch() {
            return this._batch || (this._batch = this.model.createBatch()), this._batch;
          }
          input(t) {
            (this.size += t), this.size >= this.limit && this._reset(!0);
          }
          lock() {
            this.isLocked = !0;
          }
          unlock() {
            this.isLocked = !1;
          }
          destroy() {
            this.model.document.off('change', this._changeCallback),
              this.model.document.selection.off('change:range', this._selectionChangeCallback),
              this.model.document.selection.off('change:attribute', this._selectionChangeCallback);
          }
          _reset(t) {
            (this.isLocked && !t) || ((this._batch = null), (this.size = 0));
          }
        }
        class zd extends Uc {
          constructor(t, e) {
            super(t), (this._buffer = new Dd(t.model, e)), (this._batches = new WeakSet());
          }
          get buffer() {
            return this._buffer;
          }
          destroy() {
            super.destroy(), this._buffer.destroy();
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document,
              i = t.text || '',
              n = i.length,
              r = t.range ? e.createSelection(t.range) : o.selection,
              s = t.resultRange;
            e.enqueueChange(this._buffer.batch, t => {
              this._buffer.lock(),
                e.deleteContent(r),
                i && e.insertContent(t.createText(i, o.selection.getAttributes()), r),
                s ? t.setSelection(s) : r.is('documentSelection') || t.setSelection(r),
                this._buffer.unlock(),
                this._buffer.input(n),
                this._batches.add(this._buffer.batch);
            });
          }
        }
        function Ld(t) {
          let e = null;
          const o = t.model,
            i = t.editing.view,
            n = t.commands.get('input');
          function r(t) {
            const r = o.document,
              a = i.document.isComposing,
              l = e && e.isEqual(r.selection);
            (e = null),
              n.isEnabled &&
                ((function (t) {
                  if (t.ctrlKey) return !0;
                  return jd.includes(t.keyCode);
                })(t) ||
                  r.selection.isCollapsed ||
                  (a && 229 === t.keyCode) ||
                  (!a && 229 === t.keyCode && l) ||
                  s());
          }
          function s() {
            const t = n.buffer;
            t.lock(),
              o.enqueueChange(t.batch, () => {
                o.deleteContent(o.document.selection);
              }),
              t.unlock();
          }
          un.isAndroid
            ? i.document.on('beforeinput', (t, e) => r(e), { priority: 'lowest' })
            : i.document.on('keydown', (t, e) => r(e), { priority: 'lowest' }),
            i.document.on(
              'compositionstart',
              function () {
                const t = o.document,
                  e = 1 !== t.selection.rangeCount || t.selection.getFirstRange().isFlat;
                if (t.selection.isCollapsed || e) return;
                s();
              },
              { priority: 'lowest' }
            ),
            i.document.on(
              'compositionend',
              () => {
                e = o.createSelection(o.document.selection);
              },
              { priority: 'lowest' }
            );
        }
        const jd = [
          pn('arrowUp'),
          pn('arrowRight'),
          pn('arrowDown'),
          pn('arrowLeft'),
          9,
          16,
          17,
          18,
          19,
          20,
          27,
          33,
          34,
          35,
          36,
          45,
          91,
          93,
          144,
          145,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          255,
        ];
        for (let t = 112; t <= 135; t++) jd.push(t);
        function Bd(t) {
          if (t.newChildren.length - t.oldChildren.length != 1) return;
          const e = (function (t, e) {
            const o = [];
            let i,
              n = 0;
            return (
              t.forEach(t => {
                'equal' == t
                  ? (r(), n++)
                  : 'insert' == t
                  ? (s('insert') ? i.values.push(e[n]) : (r(), (i = { type: 'insert', index: n, values: [e[n]] })), n++)
                  : s('delete')
                  ? i.howMany++
                  : (r(), (i = { type: 'delete', index: n, howMany: 1 }));
              }),
              r(),
              o
            );
            function r() {
              i && (o.push(i), (i = null));
            }
            function s(t) {
              return i && i.type == t;
            }
          })(qn(t.oldChildren, t.newChildren, Fd), t.newChildren);
          if (e.length > 1) return;
          const o = e[0];
          return o.values[0] && o.values[0].is('text') ? o : void 0;
        }
        function Fd(t, e) {
          return t && t.is('text') && e && e.is('text') ? t.data === e.data : t === e;
        }
        class Hd {
          constructor(t) {
            (this.editor = t), (this.editing = this.editor.editing);
          }
          handle(t, e) {
            if (
              (function (t) {
                if (0 == t.length) return !1;
                for (const e of t) if ('children' === e.type && !Bd(e)) return !0;
                return !1;
              })(t)
            )
              this._handleContainerChildrenMutations(t, e);
            else for (const o of t) this._handleTextMutation(o, e), this._handleTextNodeInsertion(o);
          }
          _handleContainerChildrenMutations(t, e) {
            const o = (function (t) {
              const e = t.map(t => t.node).reduce((t, e) => t.getCommonAncestor(e, { includeSelf: !0 }));
              if (!e) return;
              return e
                .getAncestors({ includeSelf: !0, parentFirst: !0 })
                .find(t => t.is('containerElement') || t.is('rootElement'));
            })(t);
            if (!o) return;
            const i = this.editor.editing.view.domConverter.mapViewToDom(o),
              n = new ir(this.editor.editing.view.document),
              r = this.editor.data.toModel(n.domToView(i)).getChild(0),
              s = this.editor.editing.mapper.toModelElement(o);
            if (!s) return;
            const a = Array.from(r.getChildren()),
              l = Array.from(s.getChildren()),
              c = a[a.length - 1],
              d = l[l.length - 1];
            c && c.is('softBreak') && d && !d.is('softBreak') && a.pop();
            const h = this.editor.model.schema;
            if (!Wd(a, h) || !Wd(l, h)) return;
            const u = a
                .map(t => (t.is('text') ? t.data : '@'))
                .join('')
                .replace(/\u00A0/g, ' '),
              g = l
                .map(t => (t.is('text') ? t.data : '@'))
                .join('')
                .replace(/\u00A0/g, ' ');
            if (g === u) return;
            const m = qn(g, u),
              { firstChangeAt: f, insertions: p, deletions: b } = Ud(m);
            let w = null;
            e && (w = this.editing.mapper.toModelRange(e.getFirstRange()));
            const k = u.substr(f, p),
              _ = this.editor.model.createRange(
                this.editor.model.createPositionAt(s, f),
                this.editor.model.createPositionAt(s, f + b)
              );
            this.editor.execute('input', { text: k, range: _, resultRange: w });
          }
          _handleTextMutation(t, e) {
            if ('text' != t.type) return;
            const o = t.newText.replace(/\u00A0/g, ' '),
              i = t.oldText.replace(/\u00A0/g, ' ');
            if (i === o) return;
            const n = qn(i, o),
              { firstChangeAt: r, insertions: s, deletions: a } = Ud(n);
            let l = null;
            e && (l = this.editing.mapper.toModelRange(e.getFirstRange()));
            const c = this.editing.view.createPositionAt(t.node, r),
              d = this.editing.mapper.toModelPosition(c),
              h = this.editor.model.createRange(d, d.getShiftedBy(a)),
              u = o.substr(r, s);
            this.editor.execute('input', { text: u, range: h, resultRange: l });
          }
          _handleTextNodeInsertion(t) {
            if ('children' != t.type) return;
            const e = Bd(t),
              o = this.editing.view.createPositionAt(t.node, e.index),
              i = this.editing.mapper.toModelPosition(o),
              n = e.values[0].data;
            this.editor.execute('input', { text: n.replace(/\u00A0/g, ' '), range: this.editor.model.createRange(i) });
          }
        }
        function Wd(t, e) {
          return t.every(t => e.isInline(t));
        }
        function Ud(t) {
          let e = null,
            o = null;
          for (let i = 0; i < t.length; i++) {
            'equal' != t[i] && ((e = null === e ? i : e), (o = i));
          }
          let i = 0,
            n = 0;
          for (let r = e; r <= o; r++) 'insert' != t[r] && i++, 'delete' != t[r] && n++;
          return { insertions: n, deletions: i, firstChangeAt: e };
        }
        class qd extends Hc {
          static get pluginName() {
            return 'Input';
          }
          init() {
            const t = this.editor,
              e = new zd(t, t.config.get('typing.undoStep') || 20);
            t.commands.add('input', e),
              Ld(t),
              (function (t) {
                t.editing.view.document.on('mutations', (e, o, i) => {
                  new Hd(t).handle(o, i);
                });
              })(t);
          }
          isInput(t) {
            return this.editor.commands.get('input')._batches.has(t);
          }
        }
        class Gd extends Uc {
          constructor(t, e) {
            super(t), (this.direction = e), (this._buffer = new Dd(t.model, t.config.get('typing.undoStep')));
          }
          get buffer() {
            return this._buffer;
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document;
            e.enqueueChange(this._buffer.batch, i => {
              this._buffer.lock();
              const n = i.createSelection(t.selection || o.selection),
                r = n.isCollapsed;
              if (
                (n.isCollapsed && e.modifySelection(n, { direction: this.direction, unit: t.unit }),
                this._shouldEntireContentBeReplacedWithParagraph(t.sequence || 1))
              )
                return void this._replaceEntireContentWithParagraph(i);
              if (n.isCollapsed) return;
              let s = 0;
              n
                .getFirstRange()
                .getMinimalFlatRanges()
                .forEach(t => {
                  s += en(t.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
                }),
                e.deleteContent(n, { doNotResetEntireContent: r, direction: this.direction }),
                this._buffer.input(s),
                i.setSelection(n),
                this._buffer.unlock();
            });
          }
          _shouldEntireContentBeReplacedWithParagraph(t) {
            if (t > 1) return !1;
            const e = this.editor.model,
              o = e.document.selection,
              i = e.schema.getLimitElement(o);
            if (!(o.isCollapsed && o.containsEntireContent(i))) return !1;
            if (!e.schema.checkChild(i, 'paragraph')) return !1;
            const n = i.getChild(0);
            return !n || 'paragraph' !== n.name;
          }
          _replaceEntireContentWithParagraph(t) {
            const e = this.editor.model,
              o = e.document.selection,
              i = e.schema.getLimitElement(o),
              n = t.createElement('paragraph');
            t.remove(t.createRangeIn(i)), t.insert(n, i), t.setSelection(n, 0);
          }
        }
        class Yd extends hr {
          constructor(t) {
            super(t);
            const e = t.document;
            let o = 0;
            function i(t, o, i) {
              let n;
              e.once('delete', t => (n = t), { priority: Number.POSITIVE_INFINITY }),
                e.fire('delete', new Ir(e, o, i)),
                n && n.stop.called && t.stop();
            }
            e.on('keyup', (t, e) => {
              (e.keyCode != fn.delete && e.keyCode != fn.backspace) || (o = 0);
            }),
              e.on('keydown', (t, e) => {
                const n = {};
                if (e.keyCode == fn.delete) (n.direction = 'forward'), (n.unit = 'character');
                else {
                  if (e.keyCode != fn.backspace) return;
                  (n.direction = 'backward'), (n.unit = 'codePoint');
                }
                const r = un.isMac ? e.altKey : e.ctrlKey;
                (n.unit = r ? 'word' : n.unit), (n.sequence = ++o), i(t, e.domEvent, n);
              }),
              un.isAndroid &&
                e.on('beforeinput', (e, o) => {
                  if ('deleteContentBackward' != o.domEvent.inputType) return;
                  const n = { unit: 'codepoint', direction: 'backward', sequence: 1 },
                    r = o.domTarget.ownerDocument.defaultView.getSelection();
                  r.anchorNode == r.focusNode &&
                    r.anchorOffset + 1 != r.focusOffset &&
                    (n.selectionToRemove = t.domConverter.domSelectionToView(r)),
                    i(e, o.domEvent, n);
                });
          }
          observe() {}
        }
        class $d extends Hc {
          static get pluginName() {
            return 'Delete';
          }
          init() {
            const t = this.editor,
              e = t.editing.view,
              o = e.document;
            if (
              (e.addObserver(Yd),
              t.commands.add('forwardDelete', new Gd(t, 'forward')),
              t.commands.add('delete', new Gd(t, 'backward')),
              this.listenTo(o, 'delete', (o, i) => {
                const n = { unit: i.unit, sequence: i.sequence };
                if (i.selectionToRemove) {
                  const e = t.model.createSelection(),
                    o = [];
                  for (const e of i.selectionToRemove.getRanges()) o.push(t.editing.mapper.toModelRange(e));
                  e.setTo(o), (n.selection = e);
                }
                t.execute('forward' == i.direction ? 'forwardDelete' : 'delete', n),
                  i.preventDefault(),
                  e.scrollToTheSelection();
              }),
              un.isAndroid)
            ) {
              let t = null;
              this.listenTo(
                o,
                'delete',
                (e, o) => {
                  const i = o.domTarget.ownerDocument.defaultView.getSelection();
                  t = {
                    anchorNode: i.anchorNode,
                    anchorOffset: i.anchorOffset,
                    focusNode: i.focusNode,
                    focusOffset: i.focusOffset,
                  };
                },
                { priority: 'lowest' }
              ),
                this.listenTo(o, 'keyup', (e, o) => {
                  if (t) {
                    const e = o.domTarget.ownerDocument.defaultView.getSelection();
                    e.collapse(t.anchorNode, t.anchorOffset), e.extend(t.focusNode, t.focusOffset), (t = null);
                  }
                });
            }
          }
        }
        class Qd extends Hc {
          static get requires() {
            return [qd, $d];
          }
          static get pluginName() {
            return 'Typing';
          }
        }
        const Kd = new Map();
        function Jd(t, e, o) {
          let i = Kd.get(t);
          i || ((i = new Map()), Kd.set(t, i)), i.set(e, o);
        }
        function Zd(t) {
          return [t];
        }
        function Xd(t, e, o = {}) {
          const i = (function (t, e) {
            const o = Kd.get(t);
            return o && o.has(e) ? o.get(e) : Zd;
          })(t.constructor, e.constructor);
          try {
            return i((t = t.clone()), e, o);
          } catch (t) {
            throw t;
          }
        }
        function th(t, e, o) {
          (t = t.slice()), (e = e.slice());
          const i = new eh(o.document, o.useRelations, o.forceWeakRemove);
          i.setOriginalOperations(t), i.setOriginalOperations(e);
          const n = i.originalOperations;
          if (0 == t.length || 0 == e.length) return { operationsA: t, operationsB: e, originalOperations: n };
          const r = new WeakMap();
          for (const e of t) r.set(e, 0);
          const s = {
            nextBaseVersionA: t[t.length - 1].baseVersion + 1,
            nextBaseVersionB: e[e.length - 1].baseVersion + 1,
            originalOperationsACount: t.length,
            originalOperationsBCount: e.length,
          };
          let a = 0;
          for (; a < t.length; ) {
            const o = t[a],
              n = r.get(o);
            if (n == e.length) {
              a++;
              continue;
            }
            const s = e[n],
              l = Xd(o, s, i.getContext(o, s, !0)),
              c = Xd(s, o, i.getContext(s, o, !1));
            i.updateRelation(o, s), i.setOriginalOperations(l, o), i.setOriginalOperations(c, s);
            for (const t of l) r.set(t, n + c.length);
            t.splice(a, 1, ...l), e.splice(n, 1, ...c);
          }
          if (o.padWithNoOps) {
            const o = t.length - s.originalOperationsACount,
              i = e.length - s.originalOperationsBCount;
            ih(t, i - o), ih(e, o - i);
          }
          return (
            oh(t, s.nextBaseVersionB),
            oh(e, s.nextBaseVersionA),
            { operationsA: t, operationsB: e, originalOperations: n }
          );
        }
        class eh {
          constructor(t, e, o = !1) {
            (this.originalOperations = new Map()),
              (this._history = t.history),
              (this._useRelations = e),
              (this._forceWeakRemove = !!o),
              (this._relations = new Map());
          }
          setOriginalOperations(t, e = null) {
            const o = e ? this.originalOperations.get(e) : null;
            for (const e of t) this.originalOperations.set(e, o || e);
          }
          updateRelation(t, e) {
            switch (t.constructor) {
              case Oa:
                switch (e.constructor) {
                  case ja:
                    t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)
                      ? this._setRelation(t, e, 'insertAtSource')
                      : t.targetPosition.isEqual(e.deletionPosition)
                      ? this._setRelation(t, e, 'insertBetween')
                      : t.targetPosition.isAfter(e.sourcePosition) && this._setRelation(t, e, 'moveTargetAfter');
                    break;
                  case Oa:
                    t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)
                      ? this._setRelation(t, e, 'insertBefore')
                      : this._setRelation(t, e, 'insertAfter');
                }
                break;
              case Ba:
                switch (e.constructor) {
                  case ja:
                    t.splitPosition.isBefore(e.sourcePosition) && this._setRelation(t, e, 'splitBefore');
                    break;
                  case Oa:
                    (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) &&
                      this._setRelation(t, e, 'splitBefore');
                }
                break;
              case ja:
                switch (e.constructor) {
                  case ja:
                    t.targetPosition.isEqual(e.sourcePosition) || this._setRelation(t, e, 'mergeTargetNotMoved'),
                      t.sourcePosition.isEqual(e.targetPosition) && this._setRelation(t, e, 'mergeSourceNotMoved'),
                      t.sourcePosition.isEqual(e.sourcePosition) && this._setRelation(t, e, 'mergeSameElement');
                    break;
                  case Ba:
                    t.sourcePosition.isEqual(e.splitPosition) && this._setRelation(t, e, 'splitAtSource');
                }
                break;
              case Da: {
                const o = t.newRange;
                if (!o) return;
                switch (e.constructor) {
                  case Oa: {
                    const i = xs._createFromPositionAndShift(e.sourcePosition, e.howMany),
                      n = i.containsPosition(o.start) || i.start.isEqual(o.start),
                      r = i.containsPosition(o.end) || i.end.isEqual(o.end);
                    (!n && !r) ||
                      i.containsRange(o) ||
                      this._setRelation(t, e, {
                        side: n ? 'left' : 'right',
                        path: n ? o.start.path.slice() : o.end.path.slice(),
                      });
                    break;
                  }
                  case ja: {
                    const i = o.start.isEqual(e.targetPosition),
                      n = o.start.isEqual(e.deletionPosition),
                      r = o.end.isEqual(e.deletionPosition),
                      s = o.end.isEqual(e.sourcePosition);
                    (i || n || r || s) &&
                      this._setRelation(t, e, {
                        wasInLeftElement: i,
                        wasStartBeforeMergedElement: n,
                        wasEndBeforeMergedElement: r,
                        wasInRightElement: s,
                      });
                    break;
                  }
                }
                break;
              }
            }
          }
          getContext(t, e, o) {
            return {
              aIsStrong: o,
              aWasUndone: this._wasUndone(t),
              bWasUndone: this._wasUndone(e),
              abRelation: this._useRelations ? this._getRelation(t, e) : null,
              baRelation: this._useRelations ? this._getRelation(e, t) : null,
              forceWeakRemove: this._forceWeakRemove,
            };
          }
          _wasUndone(t) {
            const e = this.originalOperations.get(t);
            return e.wasUndone || this._history.isUndoneOperation(e);
          }
          _getRelation(t, e) {
            const o = this.originalOperations.get(e),
              i = this._history.getUndoneOperation(o);
            if (!i) return null;
            const n = this.originalOperations.get(t),
              r = this._relations.get(n);
            return (r && r.get(i)) || null;
          }
          _setRelation(t, e, o) {
            const i = this.originalOperations.get(t),
              n = this.originalOperations.get(e);
            let r = this._relations.get(i);
            r || ((r = new Map()), this._relations.set(i, r)), r.set(n, o);
          }
        }
        function oh(t, e) {
          for (const o of t) o.baseVersion = e++;
        }
        function ih(t, e) {
          for (let o = 0; o < e; o++) t.push(new rl(0));
        }
        function nh(t, e, o) {
          const i = t.nodes.getNode(0).getAttribute(e);
          if (i == o) return null;
          const n = new xs(t.position, t.position.getShiftedBy(t.howMany));
          return new Na(n, e, i, o, 0);
        }
        function rh(t, e) {
          return null === t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
        }
        function sh(t, e) {
          const o = [];
          for (let i = 0; i < t.length; i++) {
            const n = t[i],
              r = new Oa(n.start, n.end.offset - n.start.offset, e, 0);
            o.push(r);
            for (let e = i + 1; e < t.length; e++)
              t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
            e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
          }
          return o;
        }
        Jd(Na, Na, (t, e, o) => {
          if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
            const i = t.range.getDifference(e.range).map(e => new Na(e, t.key, t.oldValue, t.newValue, 0)),
              n = t.range.getIntersection(e.range);
            return (
              n && o.aIsStrong && i.push(new Na(n, e.key, e.newValue, t.newValue, 0)), 0 == i.length ? [new rl(0)] : i
            );
          }
          return [t];
        }),
          Jd(Na, Va, (t, e) => {
            if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
              const o = t.range
                ._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes)
                .map(e => new Na(e, t.key, t.oldValue, t.newValue, t.baseVersion));
              if (e.shouldReceiveAttributes) {
                const i = nh(e, t.key, t.oldValue);
                i && o.unshift(i);
              }
              return o;
            }
            return (t.range = t.range._getTransformedByInsertion(e.position, e.howMany, !1)[0]), [t];
          }),
          Jd(Na, ja, (t, e) => {
            const o = [];
            t.range.start.hasSameParentAs(e.deletionPosition) &&
              (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) &&
              o.push(xs._createFromPositionAndShift(e.graveyardPosition, 1));
            const i = t.range._getTransformedByMergeOperation(e);
            return i.isCollapsed || o.push(i), o.map(e => new Na(e, t.key, t.oldValue, t.newValue, t.baseVersion));
          }),
          Jd(Na, Oa, (t, e) =>
            (function (t, e) {
              const o = xs._createFromPositionAndShift(e.sourcePosition, e.howMany);
              let i = null,
                n = [];
              o.containsRange(t, !0)
                ? (i = t)
                : t.start.hasSameParentAs(o.start)
                ? ((n = t.getDifference(o)), (i = t.getIntersection(o)))
                : (n = [t]);
              const r = [];
              for (let t of n) {
                t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const o = e.getMovedRangeStart(),
                  i = t.start.hasSameParentAs(o);
                (t = t._getTransformedByInsertion(o, e.howMany, i)), r.push(...t);
              }
              i && r.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]);
              return r;
            })(t.range, e).map(e => new Na(e, t.key, t.oldValue, t.newValue, t.baseVersion))
          ),
          Jd(Na, Ba, (t, e) => {
            if (t.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || t.range.end.offset++, [t];
            if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
              const o = t.clone();
              return (
                (o.range = new xs(
                  e.moveTargetPosition.clone(),
                  t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)
                )),
                (t.range.end = e.splitPosition.clone()),
                (t.range.end.stickiness = 'toPrevious'),
                [t, o]
              );
            }
            return (t.range = t.range._getTransformedBySplitOperation(e)), [t];
          }),
          Jd(Va, Na, (t, e) => {
            const o = [t];
            if (
              t.shouldReceiveAttributes &&
              t.position.hasSameParentAs(e.range.start) &&
              e.range.containsPosition(t.position)
            ) {
              const i = nh(t, e.key, e.newValue);
              i && o.push(i);
            }
            return o;
          }),
          Jd(
            Va,
            Va,
            (t, e, o) => (
              (t.position.isEqual(e.position) && o.aIsStrong) ||
                (t.position = t.position._getTransformedByInsertOperation(e)),
              [t]
            )
          ),
          Jd(Va, Oa, (t, e) => ((t.position = t.position._getTransformedByMoveOperation(e)), [t])),
          Jd(Va, Ba, (t, e) => ((t.position = t.position._getTransformedBySplitOperation(e)), [t])),
          Jd(Va, ja, (t, e) => ((t.position = t.position._getTransformedByMergeOperation(e)), [t])),
          Jd(
            Da,
            Va,
            (t, e) => (
              t.oldRange && (t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]),
              t.newRange && (t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]),
              [t]
            )
          ),
          Jd(Da, Da, (t, e, o) => {
            if (t.name == e.name) {
              if (!o.aIsStrong) return [new rl(0)];
              t.oldRange = e.newRange ? e.newRange.clone() : null;
            }
            return [t];
          }),
          Jd(
            Da,
            ja,
            (t, e) => (
              t.oldRange && (t.oldRange = t.oldRange._getTransformedByMergeOperation(e)),
              t.newRange && (t.newRange = t.newRange._getTransformedByMergeOperation(e)),
              [t]
            )
          ),
          Jd(Da, Oa, (t, e, o) => {
            if (
              (t.oldRange && (t.oldRange = xs._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))),
              t.newRange)
            ) {
              if (o.abRelation) {
                const i = xs._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                if ('left' == o.abRelation.side && e.targetPosition.isEqual(t.newRange.start))
                  return (t.newRange.start.path = o.abRelation.path), (t.newRange.end = i.end), [t];
                if ('right' == o.abRelation.side && e.targetPosition.isEqual(t.newRange.end))
                  return (t.newRange.start = i.start), (t.newRange.end.path = o.abRelation.path), [t];
              }
              t.newRange = xs._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
            }
            return [t];
          }),
          Jd(Da, Ba, (t, e, o) => {
            if ((t.oldRange && (t.oldRange = t.oldRange._getTransformedBySplitOperation(e)), t.newRange)) {
              if (o.abRelation) {
                const i = t.newRange._getTransformedBySplitOperation(e);
                return (
                  t.newRange.start.isEqual(e.splitPosition) && o.abRelation.wasStartBeforeMergedElement
                    ? (t.newRange.start = ks._createAt(e.insertionPosition))
                    : t.newRange.start.isEqual(e.splitPosition) &&
                      !o.abRelation.wasInLeftElement &&
                      (t.newRange.start = ks._createAt(e.moveTargetPosition)),
                  t.newRange.end.isEqual(e.splitPosition) && o.abRelation.wasInRightElement
                    ? (t.newRange.end = ks._createAt(e.moveTargetPosition))
                    : t.newRange.end.isEqual(e.splitPosition) && o.abRelation.wasEndBeforeMergedElement
                    ? (t.newRange.end = ks._createAt(e.insertionPosition))
                    : (t.newRange.end = i.end),
                  [t]
                );
              }
              t.newRange = t.newRange._getTransformedBySplitOperation(e);
            }
            return [t];
          }),
          Jd(
            ja,
            Va,
            (t, e) => (
              t.sourcePosition.hasSameParentAs(e.position) && (t.howMany += e.howMany),
              (t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e)),
              (t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)),
              [t]
            )
          ),
          Jd(ja, ja, (t, e, o) => {
            if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
              if (o.bWasUndone) {
                const o = e.graveyardPosition.path.slice();
                return o.push(0), (t.sourcePosition = new ks(e.graveyardPosition.root, o)), (t.howMany = 0), [t];
              }
              return [new rl(0)];
            }
            if (
              t.sourcePosition.isEqual(e.sourcePosition) &&
              !t.targetPosition.isEqual(e.targetPosition) &&
              !o.bWasUndone &&
              'splitAtSource' != o.abRelation
            ) {
              const i = '$graveyard' == t.targetPosition.root.rootName,
                n = '$graveyard' == e.targetPosition.root.rootName,
                r = i && !n;
              if ((n && !i) || (!r && o.aIsStrong)) {
                const o = e.targetPosition._getTransformedByMergeOperation(e),
                  i = t.targetPosition._getTransformedByMergeOperation(e);
                return [new Oa(o, t.howMany, i, 0)];
              }
              return [new rl(0)];
            }
            return (
              t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany),
              (t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e)),
              (t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)),
              (t.graveyardPosition.isEqual(e.graveyardPosition) && o.aIsStrong) ||
                (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)),
              [t]
            );
          }),
          Jd(ja, Oa, (t, e, o) => {
            const i = xs._createFromPositionAndShift(e.sourcePosition, e.howMany);
            return 'remove' == e.type &&
              !o.bWasUndone &&
              !o.forceWeakRemove &&
              t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
              i.containsPosition(t.sourcePosition)
              ? [new rl(0)]
              : (t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany),
                t.sourcePosition.hasSameParentAs(e.sourcePosition) && (t.howMany -= e.howMany),
                (t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e)),
                (t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e)),
                t.graveyardPosition.isEqual(e.targetPosition) ||
                  (t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)),
                [t]);
          }),
          Jd(ja, Ba, (t, e, o) => {
            if (
              (e.graveyardPosition &&
                ((t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1)),
                t.deletionPosition.isEqual(e.graveyardPosition) && (t.howMany = e.howMany)),
              t.targetPosition.isEqual(e.splitPosition))
            ) {
              const i = 0 != e.howMany,
                n = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
              if (i || n || 'mergeTargetNotMoved' == o.abRelation)
                return (t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)), [t];
            }
            if (t.sourcePosition.isEqual(e.splitPosition)) {
              if ('mergeSourceNotMoved' == o.abRelation)
                return (t.howMany = 0), (t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)), [t];
              if ('mergeSameElement' == o.abRelation || t.sourcePosition.offset > 0)
                return (
                  (t.sourcePosition = e.moveTargetPosition.clone()),
                  (t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)),
                  [t]
                );
            }
            return (
              t.sourcePosition.hasSameParentAs(e.splitPosition) && (t.howMany = e.splitPosition.offset),
              (t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)),
              (t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)),
              [t]
            );
          }),
          Jd(Oa, Va, (t, e) => {
            const o = xs
              ._createFromPositionAndShift(t.sourcePosition, t.howMany)
              ._getTransformedByInsertOperation(e, !1)[0];
            return (
              (t.sourcePosition = o.start),
              (t.howMany = o.end.offset - o.start.offset),
              t.targetPosition.isEqual(e.position) ||
                (t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)),
              [t]
            );
          }),
          Jd(Oa, Oa, (t, e, o) => {
            const i = xs._createFromPositionAndShift(t.sourcePosition, t.howMany),
              n = xs._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let r,
              s = o.aIsStrong,
              a = !o.aIsStrong;
            if (
              ('insertBefore' == o.abRelation || 'insertAfter' == o.baRelation
                ? (a = !0)
                : ('insertAfter' != o.abRelation && 'insertBefore' != o.baRelation) || (a = !1),
              (r =
                t.targetPosition.isEqual(e.targetPosition) && a
                  ? t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
                  : t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
              rh(t, e) && rh(e, t))
            )
              return [e.getReversed()];
            if (i.containsPosition(e.targetPosition) && i.containsRange(n, !0))
              return (
                (i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                (i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                sh([i], r)
              );
            if (n.containsPosition(t.targetPosition) && n.containsRange(i, !0))
              return (
                (i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                (i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                sh([i], r)
              );
            const l = Io(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
            if ('prefix' == l || 'extension' == l)
              return (
                (i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                (i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)),
                sh([i], r)
              );
            'remove' != t.type || 'remove' == e.type || o.aWasUndone || o.forceWeakRemove
              ? 'remove' == t.type || 'remove' != e.type || o.bWasUndone || o.forceWeakRemove || (s = !1)
              : (s = !0);
            const c = [],
              d = i.getDifference(n);
            for (const t of d) {
              (t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany)),
                (t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany));
              const o = 'same' == Io(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()),
                i = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, o);
              c.push(...i);
            }
            const h = i.getIntersection(n);
            return (
              null !== h &&
                s &&
                ((h.start = h.start._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                (h.end = h.end._getCombined(e.sourcePosition, e.getMovedRangeStart())),
                0 === c.length
                  ? c.push(h)
                  : 1 == c.length
                  ? n.start.isBefore(i.start) || n.start.isEqual(i.start)
                    ? c.unshift(h)
                    : c.push(h)
                  : c.splice(1, 0, h)),
              0 === c.length ? [new rl(t.baseVersion)] : sh(c, r)
            );
          }),
          Jd(Oa, Ba, (t, e, o) => {
            let i = t.targetPosition.clone();
            (t.targetPosition.isEqual(e.insertionPosition) &&
              e.graveyardPosition &&
              'moveTargetAfter' != o.abRelation) ||
              (i = t.targetPosition._getTransformedBySplitOperation(e));
            const n = xs._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (n.end.isEqual(e.insertionPosition))
              return e.graveyardPosition || t.howMany++, (t.targetPosition = i), [t];
            if (n.start.hasSameParentAs(e.splitPosition) && n.containsPosition(e.splitPosition)) {
              let t = new xs(e.splitPosition, n.end);
              t = t._getTransformedBySplitOperation(e);
              return sh([new xs(n.start, e.splitPosition), t], i);
            }
            t.targetPosition.isEqual(e.splitPosition) && 'insertAtSource' == o.abRelation && (i = e.moveTargetPosition),
              t.targetPosition.isEqual(e.insertionPosition) &&
                'insertBetween' == o.abRelation &&
                (i = t.targetPosition);
            const r = [n._getTransformedBySplitOperation(e)];
            if (e.graveyardPosition) {
              const i = n.start.isEqual(e.graveyardPosition) || n.containsPosition(e.graveyardPosition);
              t.howMany > 1 && i && !o.aWasUndone && r.push(xs._createFromPositionAndShift(e.insertionPosition, 1));
            }
            return sh(r, i);
          }),
          Jd(Oa, ja, (t, e, o) => {
            const i = xs._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.sourcePosition))
              if ('remove' != t.type || o.forceWeakRemove) {
                if (1 == t.howMany)
                  return o.bWasUndone
                    ? ((t.sourcePosition = e.graveyardPosition.clone()),
                      (t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)),
                      [t])
                    : [new rl(0)];
              } else if (!o.aWasUndone) {
                const o = [];
                let i = e.graveyardPosition.clone(),
                  n = e.targetPosition._getTransformedByMergeOperation(e);
                t.howMany > 1 &&
                  (o.push(new Oa(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)),
                  (i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)),
                  (n = n._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)));
                const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition),
                  s = new Oa(i, 1, r, 0),
                  a = s.getMovedRangeStart().path.slice();
                a.push(0);
                const l = new ks(s.targetPosition.root, a);
                n = n._getTransformedByMove(i, r, 1);
                const c = new Oa(n, e.howMany, l, 0);
                return o.push(s), o.push(c), o;
              }
            const n = xs._createFromPositionAndShift(t.sourcePosition, t.howMany)._getTransformedByMergeOperation(e);
            return (
              (t.sourcePosition = n.start),
              (t.howMany = n.end.offset - n.start.offset),
              (t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)),
              [t]
            );
          }),
          Jd(za, Va, (t, e) => ((t.position = t.position._getTransformedByInsertOperation(e)), [t])),
          Jd(za, ja, (t, e) =>
            t.position.isEqual(e.deletionPosition)
              ? ((t.position = e.graveyardPosition.clone()), (t.position.stickiness = 'toNext'), [t])
              : ((t.position = t.position._getTransformedByMergeOperation(e)), [t])
          ),
          Jd(za, Oa, (t, e) => ((t.position = t.position._getTransformedByMoveOperation(e)), [t])),
          Jd(za, za, (t, e, o) => {
            if (t.position.isEqual(e.position)) {
              if (!o.aIsStrong) return [new rl(0)];
              t.oldName = e.newName;
            }
            return [t];
          }),
          Jd(za, Ba, (t, e) => {
            if ('same' == Io(t.position.path, e.splitPosition.getParentPath()) && !e.graveyardPosition) {
              const e = new za(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
              return [t, e];
            }
            return (t.position = t.position._getTransformedBySplitOperation(e)), [t];
          }),
          Jd(La, La, (t, e, o) => {
            if (t.root === e.root && t.key === e.key) {
              if (!o.aIsStrong || t.newValue === e.newValue) return [new rl(0)];
              t.oldValue = e.newValue;
            }
            return [t];
          }),
          Jd(
            Ba,
            Va,
            (t, e) => (
              t.splitPosition.hasSameParentAs(e.position) &&
                t.splitPosition.offset < e.position.offset &&
                (t.howMany += e.howMany),
              (t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e)),
              (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
              [t]
            )
          ),
          Jd(Ba, ja, (t, e, o) => {
            if (!t.graveyardPosition && !o.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
              const o = e.graveyardPosition.path.slice();
              o.push(0);
              const i = new ks(e.graveyardPosition.root, o),
                n = Ba.getInsertionPosition(new ks(e.graveyardPosition.root, o)),
                r = new Ba(i, 0, null, 0);
              return (
                (r.insertionPosition = n),
                (t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)),
                (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
                (t.graveyardPosition = r.insertionPosition.clone()),
                (t.graveyardPosition.stickiness = 'toNext'),
                [r, t]
              );
            }
            return (
              t.splitPosition.hasSameParentAs(e.deletionPosition) &&
                !t.splitPosition.isAfter(e.deletionPosition) &&
                t.howMany--,
              t.splitPosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany),
              (t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)),
              (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
              t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)),
              [t]
            );
          }),
          Jd(Ba, Oa, (t, e, o) => {
            const i = xs._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (t.graveyardPosition) {
              const n = i.start.isEqual(t.graveyardPosition) || i.containsPosition(t.graveyardPosition);
              if (!o.bWasUndone && n) {
                const o = t.splitPosition._getTransformedByMoveOperation(e),
                  i = t.graveyardPosition._getTransformedByMoveOperation(e),
                  n = i.path.slice();
                n.push(0);
                const r = new ks(i.root, n);
                return [new Oa(o, t.howMany, r, 0)];
              }
              t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e);
            }
            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.splitPosition)) {
              const o = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
              return (
                (t.howMany -= o),
                t.splitPosition.hasSameParentAs(e.targetPosition) &&
                  t.splitPosition.offset < e.targetPosition.offset &&
                  (t.howMany += e.howMany),
                (t.splitPosition = e.sourcePosition.clone()),
                (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
                [t]
              );
            }
            return !t.splitPosition.isEqual(e.targetPosition) ||
              ('insertAtSource' != o.baRelation && 'splitBefore' != o.abRelation)
              ? (e.sourcePosition.isEqual(e.targetPosition) ||
                  (t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                    t.splitPosition.offset <= e.sourcePosition.offset &&
                    (t.howMany -= e.howMany),
                  t.splitPosition.hasSameParentAs(e.targetPosition) &&
                    t.splitPosition.offset < e.targetPosition.offset &&
                    (t.howMany += e.howMany)),
                (t.splitPosition.stickiness = 'toNone'),
                (t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e)),
                (t.splitPosition.stickiness = 'toNext'),
                t.graveyardPosition
                  ? (t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e))
                  : (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
                [t])
              : ((t.howMany += e.howMany),
                (t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)),
                (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
                [t]);
          }),
          Jd(Ba, Ba, (t, e, o) => {
            if (t.splitPosition.isEqual(e.splitPosition)) {
              if (!t.graveyardPosition && !e.graveyardPosition) return [new rl(0)];
              if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition))
                return [new rl(0)];
              if ('splitBefore' == o.abRelation)
                return (
                  (t.howMany = 0), (t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)), [t]
                );
            }
            if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
              const i = '$graveyard' == t.splitPosition.root.rootName,
                n = '$graveyard' == e.splitPosition.root.rootName,
                r = i && !n;
              if ((n && !i) || (!r && o.aIsStrong)) {
                const o = [];
                return (
                  e.howMany && o.push(new Oa(e.moveTargetPosition, e.howMany, e.splitPosition, 0)),
                  t.howMany && o.push(new Oa(t.splitPosition, t.howMany, t.moveTargetPosition, 0)),
                  o
                );
              }
              return [new rl(0)];
            }
            if (
              (t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)),
              t.splitPosition.isEqual(e.insertionPosition) && 'splitBefore' == o.abRelation)
            )
              return t.howMany++, [t];
            if (e.splitPosition.isEqual(t.insertionPosition) && 'splitBefore' == o.baRelation) {
              const o = e.insertionPosition.path.slice();
              o.push(0);
              const i = new ks(e.insertionPosition.root, o);
              return [t, new Oa(t.insertionPosition, 1, i, 0)];
            }
            return (
              t.splitPosition.hasSameParentAs(e.splitPosition) &&
                t.splitPosition.offset < e.splitPosition.offset &&
                (t.howMany -= e.howMany),
              (t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e)),
              (t.insertionPosition = Ba.getInsertionPosition(t.splitPosition)),
              [t]
            );
          });
        class ah extends Uc {
          constructor(t) {
            super(t), (this._stack = []), (this._createdBatches = new WeakSet()), this.refresh();
          }
          refresh() {
            this.isEnabled = this._stack.length > 0;
          }
          addBatch(t) {
            const e = this.editor.model.document.selection,
              o = { ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward };
            this._stack.push({ batch: t, selection: o }), this.refresh();
          }
          clearStack() {
            (this._stack = []), this.refresh();
          }
          _restoreSelection(t, e, o) {
            const i = this.editor.model,
              n = i.document,
              r = [];
            for (const e of t) {
              const t = lh(e, o).find(t => t.start.root != n.graveyard);
              t && r.push(t);
            }
            r.length &&
              i.change(t => {
                t.setSelection(r, { backward: e });
              });
          }
          _undo(t, e) {
            const o = this.editor.model,
              i = o.document;
            this._createdBatches.add(e);
            const n = t.operations.slice().filter(t => t.isDocumentOperation);
            n.reverse();
            for (const t of n) {
              const n = t.baseVersion + 1,
                r = Array.from(i.history.getOperations(n)),
                s = th([t.getReversed()], r, {
                  useRelations: !0,
                  document: this.editor.model.document,
                  padWithNoOps: !1,
                  forceWeakRemove: !0,
                }).operationsA;
              for (const n of s) e.addOperation(n), o.applyOperation(n), i.history.setOperationAsUndone(t, n);
            }
          }
        }
        function lh(t, e) {
          const o = t.getTransformedByOperations(e);
          o.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
          for (let t = 1; t < o.length; t++) {
            const e = o[t - 1],
              i = o[t];
            e.end.isTouching(i.start) && ((e.end = i.end), o.splice(t, 1), t--);
          }
          return o;
        }
        class ch extends ah {
          execute(t = null) {
            const e = t ? this._stack.findIndex(e => e.batch == t) : this._stack.length - 1,
              o = this._stack.splice(e, 1)[0],
              i = this.editor.model.createBatch('transparent');
            this.editor.model.enqueueChange(i, () => {
              this._undo(o.batch, i);
              const t = this.editor.model.document.history.getOperations(o.batch.baseVersion);
              this._restoreSelection(o.selection.ranges, o.selection.isBackward, t), this.fire('revert', o.batch, i);
            }),
              this.refresh();
          }
        }
        class dh extends ah {
          execute() {
            const t = this._stack.pop(),
              e = this.editor.model.createBatch('transparent');
            this.editor.model.enqueueChange(e, () => {
              const o = t.batch.operations[t.batch.operations.length - 1].baseVersion + 1,
                i = this.editor.model.document.history.getOperations(o);
              this._restoreSelection(t.selection.ranges, t.selection.isBackward, i), this._undo(t.batch, e);
            }),
              this.refresh();
          }
        }
        class hh extends Hc {
          static get pluginName() {
            return 'UndoEditing';
          }
          constructor(t) {
            super(t), (this._batchRegistry = new WeakSet());
          }
          init() {
            const t = this.editor;
            (this._undoCommand = new ch(t)),
              (this._redoCommand = new dh(t)),
              t.commands.add('undo', this._undoCommand),
              t.commands.add('redo', this._redoCommand),
              this.listenTo(
                t.model,
                'applyOperation',
                (t, e) => {
                  const o = e[0];
                  if (!o.isDocumentOperation) return;
                  const i = o.batch,
                    n = this._redoCommand._createdBatches.has(i),
                    r = this._undoCommand._createdBatches.has(i);
                  this._batchRegistry.has(i) ||
                    ('transparent' == i.type && !n && !r) ||
                    (n
                      ? this._undoCommand.addBatch(i)
                      : r || (this._undoCommand.addBatch(i), this._redoCommand.clearStack()),
                    this._batchRegistry.add(i));
                },
                { priority: 'highest' }
              ),
              this.listenTo(this._undoCommand, 'revert', (t, e, o) => {
                this._redoCommand.addBatch(o);
              }),
              t.keystrokes.set('CTRL+Z', 'undo'),
              t.keystrokes.set('CTRL+Y', 'redo'),
              t.keystrokes.set('CTRL+SHIFT+Z', 'redo');
          }
        }
        var uh =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
          gh =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class mh extends Hc {
          init() {
            const t = this.editor,
              e = t.locale,
              o = t.t,
              i = 'ltr' == e.uiLanguageDirection ? uh : gh,
              n = 'ltr' == e.uiLanguageDirection ? gh : uh;
            this._addButton('undo', o('Undo'), 'CTRL+Z', i), this._addButton('redo', o('Redo'), 'CTRL+Y', n);
          }
          _addButton(t, e, o, i) {
            const n = this.editor;
            n.ui.componentFactory.add(t, r => {
              const s = n.commands.get(t),
                a = new Ac(r);
              return (
                a.set({ label: e, icon: i, keystroke: o, tooltip: !0 }),
                a.bind('isEnabled').to(s, 'isEnabled'),
                this.listenTo(a, 'execute', () => {
                  n.execute(t), n.editing.view.focus();
                }),
                a
              );
            });
          }
        }
        class fh extends Hc {
          static get requires() {
            return [hh, mh];
          }
          static get pluginName() {
            return 'Undo';
          }
        }
        class ph extends Uc {
          constructor(t, e) {
            super(t), (this.attributeKey = e);
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            (this.value = e.selection.getAttribute(this.attributeKey)),
              (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey));
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document.selection,
              i = t.value;
            e.change(t => {
              if (o.isCollapsed)
                i ? t.setSelectionAttribute(this.attributeKey, i) : t.removeSelectionAttribute(this.attributeKey);
              else {
                const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey);
                for (const e of n)
                  i ? t.setAttribute(this.attributeKey, i, e) : t.removeAttribute(this.attributeKey, e);
              }
            });
          }
        }
        class bh extends Ac {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('color'),
              this.set('hasBorder'),
              (this.icon =
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035L8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>'),
              this.extendTemplate({
                attributes: {
                  style: { backgroundColor: e.to('color') },
                  class: ['ck', 'ck-color-grid__tile', e.if('hasBorder', 'ck-color-table__color-tile_bordered')],
                },
              });
          }
          render() {
            super.render(), (this.iconView.fillColor = 'hsl(0, 0%, 100%)');
          }
        }
        o(41);
        class wh extends sc {
          constructor(t, e) {
            super(t);
            const o = (e && e.colorDefinitions) || [],
              i = {};
            e && e.columns && (i.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`),
              this.set('selectedColor'),
              (this.items = this.createCollection()),
              (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this._focusCycler = new uc({
                focusables: this.items,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'arrowleft', focusNext: 'arrowright' },
              })),
              this.items.on('add', (t, e) => {
                e.isOn = e.color === this.selectedColor;
              }),
              o.forEach(t => {
                const e = new bh();
                e.set({ color: t.color, label: t.label, tooltip: !0, hasBorder: t.options.hasBorder }),
                  e.on('execute', () => {
                    this.fire('execute', { value: t.color, hasBorder: t.options.hasBorder, label: t.label });
                  }),
                  this.items.add(e);
              }),
              this.setTemplate({
                tag: 'div',
                children: this.items,
                attributes: { class: ['ck', 'ck-color-grid'], style: i },
              }),
              this.on('change:selectedColor', (t, e, o) => {
                for (const t of this.items) t.isOn = t.color === o;
              });
          }
          focus() {
            this.items.length && this.items.first.focus();
          }
          focusLast() {
            this.items.length && this.items.last.focus();
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.items.on('add', (t, e) => {
              this.focusTracker.add(e.element);
            }),
              this.items.on('remove', (t, e) => {
                this.focusTracker.remove(e.element);
              }),
              this.keystrokes.listenTo(this.element);
          }
        }
        o(43);
        class kh extends sc {
          constructor(t) {
            super(t), this.set('text'), this.set('for'), (this.id = 'ck-editor__label_' + co());
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'label',
              attributes: { class: ['ck', 'ck-label'], id: this.id, for: e.to('for') },
              children: [{ text: e.to('text') }],
            });
          }
        }
        class _h extends Co {
          constructor(t) {
            super(t), this.set('isEmpty', !0);
          }
          add(t, e) {
            this.find(e => e.color === t.color) || (super.add(t, e), this.set('isEmpty', !1));
          }
          remove(t) {
            const e = super.remove(t);
            return 0 === this.length && this.set('isEmpty', !0), e;
          }
          hasColor(t) {
            return !!this.find(e => e.color === t);
          }
        }
        xo(_h, Hi);
        var vh =
          '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.636 9.531l-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
        o(45);
        class yh extends sc {
          constructor(
            t,
            { colors: e, columns: o, removeButtonLabel: i, documentColorsLabel: n, documentColorsCount: r }
          ) {
            super(t),
              (this.items = this.createCollection()),
              (this.colorDefinitions = e),
              (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              this.set('selectedColor'),
              (this.removeButtonLabel = i),
              (this.columns = o),
              (this.documentColors = new _h()),
              (this.documentColorsCount = r),
              (this._focusCycler = new uc({
                focusables: this.items,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'arrowup', focusNext: 'arrowdown' },
              })),
              (this._documentColorsLabel = n),
              this.setTemplate({ tag: 'div', attributes: { class: ['ck', 'ck-color-table'] }, children: this.items }),
              this.items.add(this._removeColorButton());
          }
          updateDocumentColors(t, e) {
            const o = t.document,
              i = this.documentColorsCount;
            this.documentColors.clear();
            for (const n of o.getRootNames()) {
              const r = o.getRoot(n),
                s = t.createRangeIn(r);
              for (const t of s.getItems())
                if (
                  t.is('textProxy') &&
                  t.hasAttribute(e) &&
                  (this._addColorToDocumentColors(t.getAttribute(e)), this.documentColors.length >= i)
                )
                  return;
            }
          }
          updateSelectedColors() {
            const t = this.documentColorsGrid,
              e = this.staticColorsGrid,
              o = this.selectedColor;
            (e.selectedColor = o), t && (t.selectedColor = o);
          }
          render() {
            super.render();
            for (const t of this.items) this.focusTracker.add(t.element);
            this.keystrokes.listenTo(this.element);
          }
          appendGrids() {
            if (
              !this.staticColorsGrid &&
              ((this.staticColorsGrid = this._createStaticColorsGrid()),
              this.items.add(this.staticColorsGrid),
              this.documentColorsCount)
            ) {
              const t = Fl.bind(this.documentColors, this.documentColors),
                e = new kh(this.locale);
              (e.text = this._documentColorsLabel),
                e.extendTemplate({
                  attributes: { class: ['ck', 'ck-color-grid__label', t.if('isEmpty', 'ck-hidden')] },
                }),
                this.items.add(e),
                (this.documentColorsGrid = this._createDocumentColorsGrid()),
                this.items.add(this.documentColorsGrid);
            }
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          _removeColorButton() {
            const t = new Ac();
            return (
              t.set({ withText: !0, icon: vh, tooltip: !0, label: this.removeButtonLabel }),
              (t.class = 'ck-color-table__remove-color'),
              t.on('execute', () => {
                this.fire('execute', { value: null });
              }),
              t
            );
          }
          _createStaticColorsGrid() {
            const t = new wh(this.locale, { colorDefinitions: this.colorDefinitions, columns: this.columns });
            return t.delegate('execute').to(this), t;
          }
          _createDocumentColorsGrid() {
            const t = Fl.bind(this.documentColors, this.documentColors),
              e = new wh(this.locale, { columns: this.columns });
            return (
              e.delegate('execute').to(this),
              e.extendTemplate({ attributes: { class: t.if('isEmpty', 'ck-hidden') } }),
              e.items.bindTo(this.documentColors).using(t => {
                const e = new bh();
                return (
                  e.set({ color: t.color, hasBorder: t.options && t.options.hasBorder }),
                  t.label && e.set({ label: t.label, tooltip: !0 }),
                  e.on('execute', () => {
                    this.fire('execute', { value: t.color });
                  }),
                  e
                );
              }),
              this.documentColors.on('change:isEmpty', (t, o, i) => {
                i && (e.selectedColor = null);
              }),
              e
            );
          }
          _addColorToDocumentColors(t) {
            const e = this.colorDefinitions.find(e => e.color === t);
            e
              ? this.documentColors.add(Object.assign({}, e))
              : this.documentColors.add({ color: t, label: t, options: { hasBorder: !1 } });
          }
        }
        function xh(t) {
          return e => e.getStyle(t).replace(/\s/g, '');
        }
        function Ch(t) {
          return (e, o) => o.createAttributeElement('span', { style: `${t}:${e}` }, { priority: 7 });
        }
        class Ah extends ph {
          constructor(t) {
            super(t, 'fontBackgroundColor');
          }
        }
        class Th extends Hc {
          static get pluginName() {
            return 'FontBackgroundColorEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('fontBackgroundColor', {
                colors: [
                  { color: 'hsl(0, 0%, 0%)', label: 'Black' },
                  { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
                  { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
                  { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
                  { color: 'hsl(0, 0%, 100%)', label: 'White', hasBorder: !0 },
                  { color: 'hsl(0, 75%, 60%)', label: 'Red' },
                  { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
                  { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
                  { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
                  { color: 'hsl(120, 75%, 60%)', label: 'Green' },
                  { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
                  { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
                  { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
                  { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
                  { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
                ],
                columns: 5,
              }),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'span', styles: { 'background-color': /[\s\S]+/ } },
                model: { key: 'fontBackgroundColor', value: xh('background-color') },
              }),
              t.conversion
                .for('downcast')
                .attributeToElement({ model: 'fontBackgroundColor', view: Ch('background-color') }),
              t.commands.add('fontBackgroundColor', new Ah(t)),
              t.model.schema.extend('$text', { allowAttributes: 'fontBackgroundColor' }),
              t.model.schema.setAttributeProperties('fontBackgroundColor', { isFormatting: !0, copyOnEnter: !0 });
          }
        }
        function Sh(t, e) {
          const o = t.t,
            i = {
              Black: o('Black'),
              'Dim grey': o('Dim grey'),
              Grey: o('Grey'),
              'Light grey': o('Light grey'),
              White: o('White'),
              Red: o('Red'),
              Orange: o('Orange'),
              Yellow: o('Yellow'),
              'Light green': o('Light green'),
              Green: o('Green'),
              Aquamarine: o('Aquamarine'),
              Turquoise: o('Turquoise'),
              'Light blue': o('Light blue'),
              Blue: o('Blue'),
              Purple: o('Purple'),
            };
          return e.map(t => {
            const e = i[t.label];
            return e && e != t.label && (t.label = e), t;
          });
        }
        function Ph(t) {
          return t.map(Eh).filter(t => !!t);
        }
        function Eh(t) {
          return 'string' == typeof t
            ? { model: t, label: t, hasBorder: !1, view: { name: 'span', styles: { color: t } } }
            : {
                model: t.color,
                label: t.label || t.color,
                hasBorder: void 0 !== t.hasBorder && t.hasBorder,
                view: { name: 'span', styles: { color: '' + t.color } },
              };
        }
        class Mh extends Hc {
          constructor(t, { commandName: e, icon: o, componentName: i, dropdownLabel: n }) {
            super(t),
              (this.commandName = e),
              (this.componentName = i),
              (this.icon = o),
              (this.dropdownLabel = n),
              (this.columns = t.config.get(this.componentName + '.columns')),
              this.colorTableView;
          }
          init() {
            const t = this.editor,
              e = t.locale,
              o = e.t,
              i = t.commands.get(this.commandName),
              n = Sh(e, Ph(t.config.get(this.componentName).colors)),
              r = t.config.get(this.componentName + '.documentColors');
            t.ui.componentFactory.add(this.componentName, e => {
              const s = Rc(e);
              return (
                (this.colorTableView = (function ({
                  dropdownView: t,
                  colors: e,
                  columns: o,
                  removeButtonLabel: i,
                  documentColorsLabel: n,
                  documentColorsCount: r,
                }) {
                  const s = t.locale,
                    a = new yh(s, {
                      colors: e,
                      columns: o,
                      removeButtonLabel: i,
                      documentColorsLabel: n,
                      documentColorsCount: r,
                    });
                  return (t.colorTableView = a), t.panelView.children.add(a), a.delegate('execute').to(t, 'execute'), a;
                })({
                  dropdownView: s,
                  colors: n.map(t => ({ label: t.label, color: t.model, options: { hasBorder: t.hasBorder } })),
                  columns: this.columns,
                  removeButtonLabel: o('Remove color'),
                  documentColorsLabel: 0 !== r ? o('Document colors') : void 0,
                  documentColorsCount: void 0 === r ? this.columns : r,
                })),
                this.colorTableView.bind('selectedColor').to(i, 'value'),
                s.buttonView.set({ label: this.dropdownLabel, icon: this.icon, tooltip: !0 }),
                s.extendTemplate({ attributes: { class: 'ck-color-ui-dropdown' } }),
                s.bind('isEnabled').to(i),
                s.on('execute', (e, o) => {
                  t.execute(this.commandName, o), t.editing.view.focus();
                }),
                s.on('change:isOpen', (e, o, i) => {
                  s.colorTableView.appendGrids(),
                    i &&
                      (0 !== r && this.colorTableView.updateDocumentColors(t.model, this.componentName),
                      this.colorTableView.updateSelectedColors());
                }),
                s
              );
            });
          }
        }
        class Ih extends Mh {
          constructor(t) {
            super(t, {
              commandName: 'fontBackgroundColor',
              componentName: 'fontBackgroundColor',
              icon:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>',
              dropdownLabel: (0, t.locale.t)('Font Background Color'),
            });
          }
          static get pluginName() {
            return 'FontBackgroundColorUI';
          }
        }
        class Nh extends ph {
          constructor(t) {
            super(t, 'fontColor');
          }
        }
        class Rh extends Hc {
          static get pluginName() {
            return 'FontColorEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('fontColor', {
                colors: [
                  { color: 'hsl(0, 0%, 0%)', label: 'Black' },
                  { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
                  { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
                  { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
                  { color: 'hsl(0, 0%, 100%)', label: 'White', hasBorder: !0 },
                  { color: 'hsl(0, 75%, 60%)', label: 'Red' },
                  { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
                  { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
                  { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
                  { color: 'hsl(120, 75%, 60%)', label: 'Green' },
                  { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
                  { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
                  { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
                  { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
                  { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
                ],
                columns: 5,
              }),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'span', styles: { color: /[\s\S]+/ } },
                model: { key: 'fontColor', value: xh('color') },
              }),
              t.conversion.for('downcast').attributeToElement({ model: 'fontColor', view: Ch('color') }),
              t.commands.add('fontColor', new Nh(t)),
              t.model.schema.extend('$text', { allowAttributes: 'fontColor' }),
              t.model.schema.setAttributeProperties('fontColor', { isFormatting: !0, copyOnEnter: !0 });
          }
        }
        class Oh extends Mh {
          constructor(t) {
            super(t, {
              commandName: 'fontColor',
              componentName: 'fontColor',
              icon:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3L10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>',
              dropdownLabel: (0, t.locale.t)('Font Color'),
            });
          }
          static get pluginName() {
            return 'FontColorUI';
          }
        }
        class Vh extends ph {
          constructor(t) {
            super(t, 'fontSize');
          }
        }
        function Dh(t) {
          return t
            .map(t =>
              (function (t) {
                if (((e = t), 'object' == typeof e && e.title && e.model && e.view)) return Lh(t);
                var e;
                const o = (function (t) {
                  return zh[t] || zh[t.model];
                })(t);
                if (o) return Lh(o);
                if ('default' === t) return { model: void 0, title: 'Default' };
                if (
                  (function (t) {
                    let e;
                    if ('object' == typeof t) {
                      if (!t.model)
                        throw new uo.b(
                          'font-size-invalid-definition: Provided font size definition is invalid.',
                          null,
                          t
                        );
                      e = parseFloat(t.model);
                    } else e = parseFloat(t);
                    return isNaN(e);
                  })(t)
                )
                  return;
                return (function (t) {
                  ('number' != typeof t && 'string' != typeof t) ||
                    (t = { title: String(t), model: parseFloat(t) + 'px' });
                  return (t.view = { name: 'span', styles: { 'font-size': t.model } }), Lh(t);
                })(t);
              })(t)
            )
            .filter(t => !!t);
        }
        const zh = {
          get tiny() {
            return { title: 'Tiny', model: 'tiny', view: { name: 'span', classes: 'text-tiny', priority: 7 } };
          },
          get small() {
            return { title: 'Small', model: 'small', view: { name: 'span', classes: 'text-small', priority: 7 } };
          },
          get big() {
            return { title: 'Big', model: 'big', view: { name: 'span', classes: 'text-big', priority: 7 } };
          },
          get huge() {
            return { title: 'Huge', model: 'huge', view: { name: 'span', classes: 'text-huge', priority: 7 } };
          },
        };
        function Lh(t) {
          return t.view.priority || (t.view.priority = 7), t;
        }
        class jh extends Hc {
          static get pluginName() {
            return 'FontSizeEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('fontSize', {
                options: ['tiny', 'small', 'default', 'big', 'huge'],
                supportAllValues: !1,
              });
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'fontSize' }),
              t.model.schema.setAttributeProperties('fontSize', { isFormatting: !0, copyOnEnter: !0 });
            const e = t.config.get('fontSize.supportAllValues'),
              o = (function (t, e) {
                const o = { model: { key: t, values: [] }, view: {}, upcastAlso: {} };
                for (const t of e)
                  o.model.values.push(t.model),
                    (o.view[t.model] = t.view),
                    t.upcastAlso && (o.upcastAlso[t.model] = t.upcastAlso);
                return o;
              })(
                'fontSize',
                Dh(this.editor.config.get('fontSize.options')).filter(t => t.model)
              );
            e ? this._prepareAnyValueConverters(o) : t.conversion.attributeToElement(o),
              t.commands.add('fontSize', new Vh(t));
          }
          _prepareAnyValueConverters(t) {
            const e = this.editor,
              o = t.model.values.filter(t => !String(t).match(/[\d.]+[\w%]+/));
            if (o.length)
              throw new uo.b(
                'font-size-invalid-use-of-named-presets: If config.fontSize.supportAllValues is set to true, you need to use numerical values as font size options.',
                null,
                { presets: o }
              );
            e.conversion.for('downcast').attributeToElement({
              model: 'fontSize',
              view: (t, e) => {
                if (t) return e.createAttributeElement('span', { style: 'font-size:' + t }, { priority: 7 });
              },
            }),
              e.conversion.for('upcast').attributeToAttribute({
                model: { key: 'fontSize', value: t => t.getStyle('font-size') },
                view: { name: 'span' },
              });
          }
        }
        class Bh {
          constructor(t, e) {
            e && zi(this, e), t && this.set(t);
          }
        }
        xo(Bh, Hi);
        o(47);
        class Fh extends Hc {
          init() {
            const t = this.editor,
              e = t.t,
              o = this._getLocalizedOptions(),
              i = t.commands.get('fontSize');
            t.ui.componentFactory.add('fontSize', n => {
              const r = Rc(n);
              return (
                Vc(
                  r,
                  (function (t, e) {
                    const o = new Co();
                    for (const i of t) {
                      const t = {
                        type: 'button',
                        model: new Bh({
                          commandName: 'fontSize',
                          commandParam: i.model,
                          label: i.title,
                          class: 'ck-fontsize-option',
                          withText: !0,
                        }),
                      };
                      i.view && i.view.styles && t.model.set('labelStyle', 'font-size:' + i.view.styles['font-size']),
                        i.view && i.view.classes && t.model.set('class', `${t.model.class} ${i.view.classes}`),
                        t.model.bind('isOn').to(e, 'value', t => t === i.model),
                        o.add(t);
                    }
                    return o;
                  })(o, i)
                ),
                r.buttonView.set({
                  label: e('Font Size'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5L7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279l.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>',
                  tooltip: !0,
                }),
                r.extendTemplate({ attributes: { class: ['ck-font-size-dropdown'] } }),
                r.bind('isEnabled').to(i),
                this.listenTo(r, 'execute', e => {
                  t.execute(e.source.commandName, { value: e.source.commandParam }), t.editing.view.focus();
                }),
                r
              );
            });
          }
          _getLocalizedOptions() {
            const t = this.editor,
              e = t.t,
              o = { Default: e('Default'), Tiny: e('Tiny'), Small: e('Small'), Big: e('Big'), Huge: e('Huge') };
            return Dh(t.config.get('fontSize').options).map(t => {
              const e = o[t.title];
              return e && e != t.title && (t = Object.assign({}, t, { title: e })), t;
            });
          }
        }
        class Hh extends Uc {
          refresh() {
            const t = this.editor.model,
              e = Gc(t.document.selection.getSelectedBlocks());
            (this.value = !!e && e.is('paragraph')), (this.isEnabled = !!e && Wh(e, t.schema));
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document;
            e.change(i => {
              const n = (t.selection || o.selection).getSelectedBlocks();
              for (const t of n) !t.is('paragraph') && Wh(t, e.schema) && i.rename(t, 'paragraph');
            });
          }
        }
        function Wh(t, e) {
          return e.checkChild(t.parent, 'paragraph') && !e.isObject(t);
        }
        class Uh extends Uc {
          execute(t) {
            const e = this.editor.model;
            e.schema.checkChild(t.position, 'paragraph') &&
              e.change(o => {
                const i = o.createElement('paragraph');
                e.insertContent(i, t.position), o.setSelection(i, 'in');
              });
          }
        }
        class qh extends Hc {
          static get pluginName() {
            return 'Paragraph';
          }
          init() {
            const t = this.editor,
              e = t.model,
              o = t.data;
            t.commands.add('paragraph', new Hh(t)),
              t.commands.add('insertParagraph', new Uh(t)),
              e.schema.register('paragraph', { inheritAllFrom: '$block' }),
              t.conversion.elementToElement({ model: 'paragraph', view: 'p' }),
              t.conversion.for('upcast').elementToElement({
                model: (t, e) =>
                  qh.paragraphLikeElements.has(t.name) ? (t.isEmpty ? null : e.createElement('paragraph')) : null,
                converterPriority: 'low',
              }),
              o.upcastDispatcher.on(
                'element',
                (t, e, o) => {
                  o.consumable.test(e.viewItem, { name: e.viewItem.name }) &&
                    Yh(e.viewItem, e.modelCursor, o.schema) &&
                    Object.assign(e, Gh(e.viewItem, e.modelCursor, o));
                },
                { priority: 'low' }
              ),
              o.upcastDispatcher.on(
                'text',
                (t, e, o) => {
                  e.modelRange ||
                    (Yh(e.viewItem, e.modelCursor, o.schema) && Object.assign(e, Gh(e.viewItem, e.modelCursor, o)));
                },
                { priority: 'lowest' }
              ),
              e.document.registerPostFixer(t => this._autoparagraphEmptyRoots(t)),
              t.data.on(
                'ready',
                () => {
                  e.enqueueChange('transparent', t => this._autoparagraphEmptyRoots(t));
                },
                { priority: 'lowest' }
              );
          }
          _autoparagraphEmptyRoots(t) {
            const e = this.editor.model;
            for (const o of e.document.getRootNames()) {
              const i = e.document.getRoot(o);
              if (i.isEmpty && '$graveyard' != i.rootName && e.schema.checkChild(i, 'paragraph'))
                return t.insertElement('paragraph', i), !0;
            }
          }
        }
        function Gh(t, e, o) {
          const i = o.writer.createElement('paragraph');
          return o.writer.insert(i, e), o.convertItem(t, o.writer.createPositionAt(i, 0));
        }
        function Yh(t, e, o) {
          const i = o.createContext(e);
          return !!o.checkChild(i, 'paragraph') && !!o.checkChild(i.push('paragraph'), t);
        }
        qh.paragraphLikeElements = new Set([
          'blockquote',
          'dd',
          'div',
          'dt',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'li',
          'p',
          'td',
        ]);
        class $h extends Uc {
          constructor(t, e) {
            super(t), (this.modelElements = e);
          }
          refresh() {
            const t = Gc(this.editor.model.document.selection.getSelectedBlocks());
            (this.value = !!t && this.modelElements.includes(t.name) && t.name),
              (this.isEnabled = !!t && this.modelElements.some(e => Qh(t, e, this.editor.model.schema)));
          }
          execute(t) {
            const e = this.editor.model,
              o = e.document,
              i = t.value;
            e.change(t => {
              const n = Array.from(o.selection.getSelectedBlocks()).filter(t => Qh(t, i, e.schema));
              for (const e of n) e.is(i) || t.rename(e, i);
            });
          }
        }
        function Qh(t, e, o) {
          return o.checkChild(t.parent, e) && !o.isObject(t);
        }
        class Kh extends Hc {
          static get pluginName() {
            return 'HeadingEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('heading', {
                options: [
                  { model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
                  { model: 'heading1', view: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },
                  { model: 'heading2', view: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },
                  { model: 'heading3', view: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' },
                ],
              });
          }
          static get requires() {
            return [qh];
          }
          init() {
            const t = this.editor,
              e = t.config.get('heading.options'),
              o = [];
            for (const i of e)
              'paragraph' !== i.model &&
                (t.model.schema.register(i.model, { inheritAllFrom: '$block' }),
                t.conversion.elementToElement(i),
                o.push(i.model));
            this._addDefaultH1Conversion(t), t.commands.add('heading', new $h(t, o));
          }
          afterInit() {
            const t = this.editor,
              e = t.commands.get('enter'),
              o = t.config.get('heading.options');
            e &&
              this.listenTo(e, 'afterExecute', (e, i) => {
                const n = t.model.document.selection.getFirstPosition().parent;
                o.some(t => n.is(t.model)) &&
                  !n.is('paragraph') &&
                  0 === n.childCount &&
                  i.writer.rename(n, 'paragraph');
              });
          }
          _addDefaultH1Conversion(t) {
            t.conversion
              .for('upcast')
              .elementToElement({ model: 'heading1', view: 'h1', converterPriority: ho.get('low') + 1 });
          }
        }
        o(11);
        class Jh extends Hc {
          init() {
            const t = this.editor,
              e = t.t,
              o = (function (t) {
                const e = t.t,
                  o = {
                    Paragraph: e('Paragraph'),
                    'Heading 1': e('Heading 1'),
                    'Heading 2': e('Heading 2'),
                    'Heading 3': e('Heading 3'),
                    'Heading 4': e('Heading 4'),
                    'Heading 5': e('Heading 5'),
                    'Heading 6': e('Heading 6'),
                  };
                return t.config.get('heading.options').map(t => {
                  const e = o[t.title];
                  return e && e != t.title && (t.title = e), t;
                });
              })(t),
              i = e('Choose heading'),
              n = e('Heading');
            t.ui.componentFactory.add('heading', e => {
              const r = {},
                s = new Co(),
                a = t.commands.get('heading'),
                l = t.commands.get('paragraph'),
                c = [a];
              for (const t of o) {
                const e = { type: 'button', model: new Bh({ label: t.title, class: t.class, withText: !0 }) };
                'paragraph' === t.model
                  ? (e.model.bind('isOn').to(l, 'value'), e.model.set('commandName', 'paragraph'), c.push(l))
                  : (e.model.bind('isOn').to(a, 'value', e => e === t.model),
                    e.model.set({ commandName: 'heading', commandValue: t.model })),
                  s.add(e),
                  (r[t.model] = t.title);
              }
              const d = Rc(e);
              return (
                Vc(d, s),
                d.buttonView.set({ isOn: !1, withText: !0, tooltip: n }),
                d.extendTemplate({ attributes: { class: ['ck-heading-dropdown'] } }),
                d.bind('isEnabled').toMany(c, 'isEnabled', (...t) => t.some(t => t)),
                d.buttonView.bind('label').to(a, 'value', l, 'value', (t, e) => {
                  const o = t || (e && 'paragraph');
                  return r[o] ? r[o] : i;
                }),
                this.listenTo(d, 'execute', e => {
                  t.execute(e.source.commandName, e.source.commandValue ? { value: e.source.commandValue } : void 0),
                    t.editing.view.focus();
                }),
                d
              );
            });
          }
        }
        class Zh extends Uc {
          refresh() {
            const t = this.editor.model,
              e = t.document;
            (this.value = e.selection.getAttribute('highlight')),
              (this.isEnabled = t.schema.checkAttributeInSelection(e.selection, 'highlight'));
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document.selection,
              i = t.value;
            e.change(t => {
              const n = e.schema.getValidRanges(o.getRanges(), 'highlight');
              if (o.isCollapsed) {
                const e = o.getFirstPosition();
                if (o.hasAttribute('highlight')) {
                  const o = t => t.item.hasAttribute('highlight') && t.item.getAttribute('highlight') === this.value,
                    n = e.getLastMatchingPosition(o, { direction: 'backward' }),
                    r = e.getLastMatchingPosition(o),
                    s = t.createRange(n, r);
                  i && this.value !== i
                    ? (t.setAttribute('highlight', i, s), t.setSelectionAttribute('highlight', i))
                    : (t.removeAttribute('highlight', s), t.removeSelectionAttribute('highlight'));
                } else i && t.setSelectionAttribute('highlight', i);
              } else for (const e of n) i ? t.setAttribute('highlight', i, e) : t.removeAttribute('highlight', e);
            });
          }
        }
        class Xh extends Hc {
          static get pluginName() {
            return 'HighlightEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('highlight', {
                options: [
                  {
                    model: 'yellowMarker',
                    class: 'marker-yellow',
                    title: 'Yellow marker',
                    color: 'var(--ck-highlight-marker-yellow)',
                    type: 'marker',
                  },
                  {
                    model: 'greenMarker',
                    class: 'marker-green',
                    title: 'Green marker',
                    color: 'var(--ck-highlight-marker-green)',
                    type: 'marker',
                  },
                  {
                    model: 'pinkMarker',
                    class: 'marker-pink',
                    title: 'Pink marker',
                    color: 'var(--ck-highlight-marker-pink)',
                    type: 'marker',
                  },
                  {
                    model: 'blueMarker',
                    class: 'marker-blue',
                    title: 'Blue marker',
                    color: 'var(--ck-highlight-marker-blue)',
                    type: 'marker',
                  },
                  {
                    model: 'redPen',
                    class: 'pen-red',
                    title: 'Red pen',
                    color: 'var(--ck-highlight-pen-red)',
                    type: 'pen',
                  },
                  {
                    model: 'greenPen',
                    class: 'pen-green',
                    title: 'Green pen',
                    color: 'var(--ck-highlight-pen-green)',
                    type: 'pen',
                  },
                ],
              });
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'highlight' });
            const e = t.config.get('highlight.options');
            t.conversion.attributeToElement(
              (function (t) {
                const e = { model: { key: 'highlight', values: [] }, view: {} };
                for (const o of t) e.model.values.push(o.model), (e.view[o.model] = { name: 'mark', classes: o.class });
                return e;
              })(e)
            ),
              t.commands.add('highlight', new Zh(t));
          }
        }
        o(50);
        class tu extends sc {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('icon'),
              this.set('isEnabled', !0),
              this.set('isOn', !1),
              this.set('isToggleable', !1),
              this.set('isVisible', !0),
              this.set('keystroke'),
              this.set('label'),
              this.set('tabindex', -1),
              this.set('tooltip'),
              this.set('tooltipPosition', 's'),
              this.set('type', 'button'),
              this.set('withText', !1),
              (this.children = this.createCollection()),
              (this.actionView = this._createActionView()),
              (this.arrowView = this._createArrowView()),
              (this.keystrokes = new Cl()),
              (this.focusTracker = new Nl()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-splitbutton',
                    e.if('isVisible', 'ck-hidden', t => !t),
                    this.arrowView.bindTemplate.if('isOn', 'ck-splitbutton_open'),
                  ],
                },
                children: this.children,
              });
          }
          render() {
            super.render(),
              this.children.add(this.actionView),
              this.children.add(this.arrowView),
              this.focusTracker.add(this.actionView.element),
              this.focusTracker.add(this.arrowView.element),
              this.keystrokes.listenTo(this.element),
              this.keystrokes.set('arrowright', (t, e) => {
                this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e());
              }),
              this.keystrokes.set('arrowleft', (t, e) => {
                this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e());
              });
          }
          focus() {
            this.actionView.focus();
          }
          _createActionView() {
            const t = new Ac();
            return (
              t
                .bind(
                  'icon',
                  'isEnabled',
                  'isOn',
                  'isToggleable',
                  'keystroke',
                  'label',
                  'tabindex',
                  'tooltip',
                  'tooltipPosition',
                  'type',
                  'withText'
                )
                .to(this),
              t.extendTemplate({ attributes: { class: 'ck-splitbutton__action' } }),
              t.delegate('execute').to(this),
              t
            );
          }
          _createArrowView() {
            const t = new Ac(),
              e = t.bindTemplate;
            return (
              (t.icon = Tc),
              t.extendTemplate({
                attributes: {
                  class: 'ck-splitbutton__arrow',
                  'aria-haspopup': !0,
                  'aria-expanded': e.to('isOn', t => String(t)),
                },
              }),
              t.bind('isEnabled').to(this),
              t.delegate('execute').to(this, 'open'),
              t
            );
          }
        }
        o(52);
        class eu extends Hc {
          get localizedOptionTitles() {
            const t = this.editor.t;
            return {
              'Yellow marker': t('Yellow marker'),
              'Green marker': t('Green marker'),
              'Pink marker': t('Pink marker'),
              'Blue marker': t('Blue marker'),
              'Red pen': t('Red pen'),
              'Green pen': t('Green pen'),
            };
          }
          static get pluginName() {
            return 'HighlightUI';
          }
          init() {
            const t = this.editor.config.get('highlight.options');
            for (const e of t) this._addHighlighterButton(e);
            this._addRemoveHighlightButton(), this._addDropdown(t);
          }
          _addRemoveHighlightButton() {
            const t = this.editor.t;
            this._addButton('removeHighlight', t('Remove highlight'), vh);
          }
          _addHighlighterButton(t) {
            const e = this.editor.commands.get('highlight');
            this._addButton('highlight:' + t.model, t.title, ou(t.type), t.model, function (o) {
              o.bind('isEnabled').to(e, 'isEnabled'),
                o.bind('isOn').to(e, 'value', e => e === t.model),
                (o.iconView.fillColor = t.color),
                (o.isToggleable = !0);
            });
          }
          _addButton(t, e, o, i, n = () => {}) {
            const r = this.editor;
            r.ui.componentFactory.add(t, t => {
              const s = new Ac(t),
                a = this.localizedOptionTitles[e] ? this.localizedOptionTitles[e] : e;
              return (
                s.set({ label: a, icon: o, tooltip: !0 }),
                s.on('execute', () => {
                  r.execute('highlight', { value: i }), r.editing.view.focus();
                }),
                n(s),
                s
              );
            });
          }
          _addDropdown(t) {
            const e = this.editor,
              o = e.t,
              i = e.ui.componentFactory,
              n = t[0],
              r = t.reduce((t, e) => ((t[e.model] = e), t), {});
            i.add('highlight', s => {
              const a = e.commands.get('highlight'),
                l = Rc(s, tu),
                c = l.buttonView;
              c.set({ tooltip: o('Highlight'), lastExecuted: n.model, commandValue: n.model, isToggleable: !0 }),
                c.bind('icon').to(a, 'value', t => ou(h(t, 'type'))),
                c.bind('color').to(a, 'value', t => h(t, 'color')),
                c.bind('commandValue').to(a, 'value', t => h(t, 'model')),
                c.bind('isOn').to(a, 'value', t => !!t),
                c.delegate('execute').to(l);
              const d = t.map(t => {
                const e = i.create('highlight:' + t.model);
                return this.listenTo(e, 'execute', () => l.buttonView.set({ lastExecuted: t.model })), e;
              });
              function h(t, e) {
                const o = t && t !== c.lastExecuted ? t : c.lastExecuted;
                return r[o][e];
              }
              return (
                l.bind('isEnabled').toMany(d, 'isEnabled', (...t) => t.some(t => t)),
                d.push(new mc()),
                d.push(i.create('removeHighlight')),
                Oc(l, d),
                (function (t) {
                  t.buttonView.actionView.iconView.bind('fillColor').to(t.buttonView, 'color');
                })(l),
                (l.toolbarView.ariaLabel = o('Text highlight toolbar')),
                c.on('execute', () => {
                  e.execute('highlight', { value: c.commandValue }), e.editing.view.focus();
                }),
                l
              );
            });
          }
        }
        function ou(t) {
          return 'marker' === t
            ? '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59L3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="M2.556 16.727l.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415l1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656l-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5L9.59 17h9.406v1.5H8.245z"/></svg>'
            : '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268L2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="M4.5 18.088l-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166l-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5L9.59 17h9.406v1.5H8.245z"/></svg>';
        }
        class iu extends hr {
          observe(t) {
            this.listenTo(
              t,
              'load',
              (t, e) => {
                'IMG' == e.target.tagName && this._fireEvents(e);
              },
              { useCapture: !0 }
            );
          }
          _fireEvents(t) {
            this.isEnabled && (this.document.fire('layoutChanged'), this.document.fire('imageLoaded', t));
          }
        }
        class nu {
          constructor() {
            this._stack = [];
          }
          add(t, e) {
            const o = this._stack,
              i = o[0];
            this._insertDescriptor(t);
            const n = o[0];
            i === n || ru(i, n) || this.fire('change:top', { oldDescriptor: i, newDescriptor: n, writer: e });
          }
          remove(t, e) {
            const o = this._stack,
              i = o[0];
            this._removeDescriptor(t);
            const n = o[0];
            i === n || ru(i, n) || this.fire('change:top', { oldDescriptor: i, newDescriptor: n, writer: e });
          }
          _insertDescriptor(t) {
            const e = this._stack,
              o = e.findIndex(e => e.id === t.id);
            if (ru(t, e[o])) return;
            o > -1 && e.splice(o, 1);
            let i = 0;
            for (; e[i] && su(e[i], t); ) i++;
            e.splice(i, 0, t);
          }
          _removeDescriptor(t) {
            const e = this._stack,
              o = e.findIndex(e => e.id === t);
            o > -1 && e.splice(o, 1);
          }
        }
        function ru(t, e) {
          return t && e && t.priority == e.priority && au(t.classes) == au(e.classes);
        }
        function su(t, e) {
          return t.priority > e.priority || (!(t.priority < e.priority) && au(t.classes) > au(e.classes));
        }
        function au(t) {
          return Array.isArray(t) ? t.sort().join(',') : t;
        }
        function lu(t) {
          return e => e + t;
        }
        xo(nu, fo);
        o(54);
        const cu = lu('px'),
          du = Xn.document.body;
        class hu extends sc {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            this.set('top', 0),
              this.set('left', 0),
              this.set('position', 'arrow_nw'),
              this.set('isVisible', !1),
              this.set('withArrow', !0),
              this.set('class'),
              (this.content = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-balloon-panel',
                    e.to('position', t => 'ck-balloon-panel_' + t),
                    e.if('isVisible', 'ck-balloon-panel_visible'),
                    e.if('withArrow', 'ck-balloon-panel_with-arrow'),
                    e.to('class'),
                  ],
                  style: { top: e.to('top', cu), left: e.to('left', cu) },
                },
                children: this.content,
              });
          }
          show() {
            this.isVisible = !0;
          }
          hide() {
            this.isVisible = !1;
          }
          attachTo(t) {
            this.show();
            const e = hu.defaultPositions,
              o = Object.assign(
                {},
                {
                  element: this.element,
                  positions: [
                    e.southArrowNorth,
                    e.southArrowNorthMiddleWest,
                    e.southArrowNorthMiddleEast,
                    e.southArrowNorthWest,
                    e.southArrowNorthEast,
                    e.northArrowSouth,
                    e.northArrowSouthMiddleWest,
                    e.northArrowSouthMiddleEast,
                    e.northArrowSouthWest,
                    e.northArrowSouthEast,
                  ],
                  limiter: du,
                  fitInViewport: !0,
                },
                t
              ),
              i = hu._getOptimalPosition(o),
              n = parseInt(i.left),
              r = parseInt(i.top),
              s = i.name;
            Object.assign(this, { top: r, left: n, position: s });
          }
          pin(t) {
            this.unpin(),
              (this._pinWhenIsVisibleCallback = () => {
                this.isVisible ? this._startPinning(t) : this._stopPinning();
              }),
              this._startPinning(t),
              this.listenTo(this, 'change:isVisible', this._pinWhenIsVisibleCallback);
          }
          unpin() {
            this._pinWhenIsVisibleCallback &&
              (this._stopPinning(),
              this.stopListening(this, 'change:isVisible', this._pinWhenIsVisibleCallback),
              (this._pinWhenIsVisibleCallback = null),
              this.hide());
          }
          _startPinning(t) {
            this.attachTo(t);
            const e = uu(t.target),
              o = t.limiter ? uu(t.limiter) : du;
            this.listenTo(
              Xn.document,
              'scroll',
              (i, n) => {
                const r = n.target,
                  s = e && r.contains(e),
                  a = o && r.contains(o);
                (!s && !a && e && o) || this.attachTo(t);
              },
              { useCapture: !0 }
            ),
              this.listenTo(Xn.window, 'resize', () => {
                this.attachTo(t);
              });
          }
          _stopPinning() {
            this.stopListening(Xn.document, 'scroll'), this.stopListening(Xn.window, 'resize');
          }
        }
        function uu(t) {
          return oo(t) ? t : Qr(t) ? t.commonAncestorContainer : 'function' == typeof t ? uu(t()) : null;
        }
        function gu(t, e) {
          return t.top - e.height - hu.arrowVerticalOffset;
        }
        function mu(t) {
          return t.bottom + hu.arrowVerticalOffset;
        }
        (hu.arrowHorizontalOffset = 25),
          (hu.arrowVerticalOffset = 10),
          (hu._getOptimalPosition = wc),
          (hu.defaultPositions = {
            northWestArrowSouthWest: (t, e) => ({
              top: gu(t, e),
              left: t.left - hu.arrowHorizontalOffset,
              name: 'arrow_sw',
            }),
            northWestArrowSouthMiddleWest: (t, e) => ({
              top: gu(t, e),
              left: t.left - 0.25 * e.width - hu.arrowHorizontalOffset,
              name: 'arrow_smw',
            }),
            northWestArrowSouth: (t, e) => ({ top: gu(t, e), left: t.left - e.width / 2, name: 'arrow_s' }),
            northWestArrowSouthMiddleEast: (t, e) => ({
              top: gu(t, e),
              left: t.left - 0.75 * e.width + hu.arrowHorizontalOffset,
              name: 'arrow_sme',
            }),
            northWestArrowSouthEast: (t, e) => ({
              top: gu(t, e),
              left: t.left - e.width + hu.arrowHorizontalOffset,
              name: 'arrow_se',
            }),
            northArrowSouthWest: (t, e) => ({
              top: gu(t, e),
              left: t.left + t.width / 2 - hu.arrowHorizontalOffset,
              name: 'arrow_sw',
            }),
            northArrowSouthMiddleWest: (t, e) => ({
              top: gu(t, e),
              left: t.left + t.width / 2 - 0.25 * e.width - hu.arrowHorizontalOffset,
              name: 'arrow_smw',
            }),
            northArrowSouth: (t, e) => ({ top: gu(t, e), left: t.left + t.width / 2 - e.width / 2, name: 'arrow_s' }),
            northArrowSouthMiddleEast: (t, e) => ({
              top: gu(t, e),
              left: t.left + t.width / 2 - 0.75 * e.width + hu.arrowHorizontalOffset,
              name: 'arrow_sme',
            }),
            northArrowSouthEast: (t, e) => ({
              top: gu(t, e),
              left: t.left + t.width / 2 - e.width + hu.arrowHorizontalOffset,
              name: 'arrow_se',
            }),
            northEastArrowSouthWest: (t, e) => ({
              top: gu(t, e),
              left: t.right - hu.arrowHorizontalOffset,
              name: 'arrow_sw',
            }),
            northEastArrowSouthMiddleWest: (t, e) => ({
              top: gu(t, e),
              left: t.right - 0.25 * e.width - hu.arrowHorizontalOffset,
              name: 'arrow_smw',
            }),
            northEastArrowSouth: (t, e) => ({ top: gu(t, e), left: t.right - e.width / 2, name: 'arrow_s' }),
            northEastArrowSouthMiddleEast: (t, e) => ({
              top: gu(t, e),
              left: t.right - 0.75 * e.width + hu.arrowHorizontalOffset,
              name: 'arrow_sme',
            }),
            northEastArrowSouthEast: (t, e) => ({
              top: gu(t, e),
              left: t.right - e.width + hu.arrowHorizontalOffset,
              name: 'arrow_se',
            }),
            southWestArrowNorthWest: (t, e) => ({
              top: mu(t),
              left: t.left - hu.arrowHorizontalOffset,
              name: 'arrow_nw',
            }),
            southWestArrowNorthMiddleWest: (t, e) => ({
              top: mu(t),
              left: t.left - 0.25 * e.width - hu.arrowHorizontalOffset,
              name: 'arrow_nmw',
            }),
            southWestArrowNorth: (t, e) => ({ top: mu(t), left: t.left - e.width / 2, name: 'arrow_n' }),
            southWestArrowNorthMiddleEast: (t, e) => ({
              top: mu(t),
              left: t.left - 0.75 * e.width + hu.arrowHorizontalOffset,
              name: 'arrow_nme',
            }),
            southWestArrowNorthEast: (t, e) => ({
              top: mu(t),
              left: t.left - e.width + hu.arrowHorizontalOffset,
              name: 'arrow_ne',
            }),
            southArrowNorthWest: (t, e) => ({
              top: mu(t),
              left: t.left + t.width / 2 - hu.arrowHorizontalOffset,
              name: 'arrow_nw',
            }),
            southArrowNorthMiddleWest: (t, e) => ({
              top: mu(t),
              left: t.left + t.width / 2 - 0.25 * e.width - hu.arrowHorizontalOffset,
              name: 'arrow_nmw',
            }),
            southArrowNorth: (t, e) => ({ top: mu(t), left: t.left + t.width / 2 - e.width / 2, name: 'arrow_n' }),
            southArrowNorthMiddleEast: (t, e) => ({
              top: mu(t),
              left: t.left + t.width / 2 - 0.75 * e.width + hu.arrowHorizontalOffset,
              name: 'arrow_nme',
            }),
            southArrowNorthEast: (t, e) => ({
              top: mu(t),
              left: t.left + t.width / 2 - e.width + hu.arrowHorizontalOffset,
              name: 'arrow_ne',
            }),
            southEastArrowNorthWest: (t, e) => ({
              top: mu(t),
              left: t.right - hu.arrowHorizontalOffset,
              name: 'arrow_nw',
            }),
            southEastArrowNorthMiddleWest: (t, e) => ({
              top: mu(t),
              left: t.right - 0.25 * e.width - hu.arrowHorizontalOffset,
              name: 'arrow_nmw',
            }),
            southEastArrowNorth: (t, e) => ({ top: mu(t), left: t.right - e.width / 2, name: 'arrow_n' }),
            southEastArrowNorthMiddleEast: (t, e) => ({
              top: mu(t),
              left: t.right - 0.75 * e.width + hu.arrowHorizontalOffset,
              name: 'arrow_nme',
            }),
            southEastArrowNorthEast: (t, e) => ({
              top: mu(t),
              left: t.right - e.width + hu.arrowHorizontalOffset,
              name: 'arrow_ne',
            }),
          });
        function fu(t) {
          return !!t.is('element') && !!t.getCustomProperty('widget');
        }
        function pu(t, e, o = {}) {
          return (
            e.setAttribute('contenteditable', 'false', t),
            e.addClass('ck-widget', t),
            e.setCustomProperty('widget', !0, t),
            (t.getFillerOffset = vu),
            o.label &&
              (function (t, e, o) {
                o.setCustomProperty('widgetLabel', e, t);
              })(t, o.label, e),
            o.hasSelectionHandle &&
              (function (t, e) {
                const o = e.createUIElement('div', { class: 'ck ck-widget__selection-handle' }, function (t) {
                  const e = this.toDomElement(t),
                    o = new xc();
                  return (
                    o.set(
                      'content',
                      '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'
                    ),
                    o.render(),
                    e.appendChild(o.element),
                    e
                  );
                });
                e.insert(e.createPositionAt(t, 0), o), e.addClass(['ck-widget_with-selection-handle'], t);
              })(t, e),
            (function (t, e, o, i) {
              const n = new nu();
              n.on('change:top', (e, n) => {
                n.oldDescriptor && i(t, n.oldDescriptor, n.writer), n.newDescriptor && o(t, n.newDescriptor, n.writer);
              }),
                e.setCustomProperty('addHighlight', (t, e, o) => n.add(e, o), t),
                e.setCustomProperty('removeHighlight', (t, e, o) => n.remove(e, o), t);
            })(
              t,
              e,
              (t, e, o) => o.addClass(i(e.classes), t),
              (t, e, o) => o.removeClass(i(e.classes), t)
            ),
            t
          );
          function i(t) {
            return Array.isArray(t) ? t : [t];
          }
        }
        function bu(t) {
          const e = t.getCustomProperty('widgetLabel');
          return e ? ('function' == typeof e ? e() : e) : '';
        }
        function wu(t, e) {
          return (
            e.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], t),
            e.setAttribute('contenteditable', t.isReadOnly ? 'false' : 'true', t),
            t.on('change:isReadOnly', (o, i, n) => {
              e.setAttribute('contenteditable', n ? 'false' : 'true', t);
            }),
            t.on('change:isFocused', (o, i, n) => {
              n
                ? e.addClass('ck-editor__nested-editable_focused', t)
                : e.removeClass('ck-editor__nested-editable_focused', t);
            }),
            t
          );
        }
        function ku(t, e) {
          const o = t.getSelectedElement();
          if (o && e.schema.isBlock(o)) return e.createPositionAfter(o);
          const i = t.getSelectedBlocks().next().value;
          if (i) {
            if (i.isEmpty) return e.createPositionAt(i, 0);
            const o = e.createPositionAfter(i);
            return t.focus.isTouching(o) ? o : e.createPositionBefore(i);
          }
          return t.focus;
        }
        function _u(t, e) {
          const o = new Zr(Xn.window),
            i = o.getIntersection(t),
            n = e.height + hu.arrowVerticalOffset;
          if (t.top - n > o.top || t.bottom + n < o.bottom) return null;
          const r = i || t,
            s = r.left + r.width / 2 - e.width / 2;
          return { top: Math.max(t.top, 0) + hu.arrowVerticalOffset, left: s, name: 'arrow_n' };
        }
        function vu() {
          return null;
        }
        function yu(t) {
          const e = t.getSelectedElement();
          return e &&
            (function (t) {
              return !!t.getCustomProperty('image') && fu(t);
            })(e)
            ? e
            : null;
        }
        function xu(t) {
          return !!t && t.is('image');
        }
        function Cu(t, e, o = {}) {
          const i = t.createElement('image', o),
            n = ku(e.document.selection, e);
          e.insertContent(i, n), i.parent && t.setSelection(i, 'on');
        }
        function Au(t) {
          const e = t.schema,
            o = t.document.selection;
          return (
            (function (t, e, o) {
              const i = (function (t, e) {
                const o = ku(t, e).parent;
                if (o.isEmpty && !o.is('$root')) return o.parent;
                return o;
              })(t, o);
              return e.checkChild(i, 'image');
            })(o, e, t) &&
            !(function (t, e) {
              const o = t.getSelectedElement();
              return o && e.isObject(o);
            })(o, e) &&
            (function (t) {
              return [...t.focus.getAncestors()].every(t => !t.is('image'));
            })(o)
          );
        }
        function Tu(t) {
          return Array.from(t.getChildren()).find(t => t.is('img'));
        }
        function Su(t) {
          return o => {
            o.on(`attribute:${t}:image`, e);
          };
          function e(t, e, o) {
            if (!o.consumable.consume(e.item, t.name)) return;
            const i = o.writer,
              n = Tu(o.mapper.toViewElement(e.item));
            null !== e.attributeNewValue
              ? i.setAttribute(e.attributeKey, e.attributeNewValue, n)
              : i.removeAttribute(e.attributeKey, n);
          }
        }
        class Pu extends Uc {
          refresh() {
            this.isEnabled = Au(this.editor.model);
          }
          execute(t) {
            const e = this.editor.model;
            e.change(o => {
              const i = Array.isArray(t.source) ? t.source : [t.source];
              for (const t of i) Cu(o, e, { src: t });
            });
          }
        }
        class Eu extends Hc {
          static get pluginName() {
            return 'ImageEditing';
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              o = t.t,
              i = t.conversion;
            t.editing.view.addObserver(iu),
              e.register('image', {
                isObject: !0,
                isBlock: !0,
                allowWhere: '$block',
                allowAttributes: ['alt', 'src', 'srcset'],
              }),
              i.for('dataDowncast').elementToElement({ model: 'image', view: (t, e) => Mu(e) }),
              i.for('editingDowncast').elementToElement({
                model: 'image',
                view: (t, e) => {
                  return (
                    (i = Mu(e)),
                    (n = e),
                    (r = o('image widget')),
                    n.setCustomProperty('image', !0, i),
                    pu(i, n, {
                      label: function () {
                        const t = Tu(i).getAttribute('alt');
                        return t ? `${t} ${r}` : r;
                      },
                    })
                  );
                  var i, n, r;
                },
              }),
              i
                .for('downcast')
                .add(Su('src'))
                .add(Su('alt'))
                .add(
                  (function () {
                    return e => {
                      e.on('attribute:srcset:image', t);
                    };
                    function t(t, e, o) {
                      if (!o.consumable.consume(e.item, t.name)) return;
                      const i = o.writer,
                        n = Tu(o.mapper.toViewElement(e.item));
                      if (null === e.attributeNewValue) {
                        const t = e.attributeOldValue;
                        t.data &&
                          (i.removeAttribute('srcset', n),
                          i.removeAttribute('sizes', n),
                          t.width && i.removeAttribute('width', n));
                      } else {
                        const t = e.attributeNewValue;
                        t.data &&
                          (i.setAttribute('srcset', t.data, n),
                          i.setAttribute('sizes', '100vw', n),
                          t.width && i.setAttribute('width', t.width, n));
                      }
                    }
                  })()
                ),
              i
                .for('upcast')
                .elementToElement({
                  view: { name: 'img', attributes: { src: !0 } },
                  model: (t, e) => e.createElement('image', { src: t.getAttribute('src') }),
                })
                .attributeToAttribute({ view: { name: 'img', key: 'alt' }, model: 'alt' })
                .attributeToAttribute({
                  view: { name: 'img', key: 'srcset' },
                  model: {
                    key: 'srcset',
                    value: t => {
                      const e = { data: t.getAttribute('srcset') };
                      return t.hasAttribute('width') && (e.width = t.getAttribute('width')), e;
                    },
                  },
                })
                .add(
                  (function () {
                    return e => {
                      e.on('element:figure', t);
                    };
                    function t(t, e, o) {
                      if (!o.consumable.test(e.viewItem, { name: !0, classes: 'image' })) return;
                      const i = Tu(e.viewItem);
                      if (!i || !i.hasAttribute('src') || !o.consumable.test(i, { name: !0 })) return;
                      const n = o.convertItem(i, e.modelCursor),
                        r = Gc(n.modelRange.getItems());
                      r &&
                        (o.convertChildren(e.viewItem, o.writer.createPositionAt(r, 0)),
                        (e.modelRange = n.modelRange),
                        (e.modelCursor = n.modelCursor));
                    }
                  })()
                ),
              t.commands.add('imageInsert', new Pu(t));
          }
        }
        function Mu(t) {
          const e = t.createEmptyElement('img'),
            o = t.createContainerElement('figure', { class: 'image' });
          return t.insert(t.createPositionAt(o, 0), e), o;
        }
        class Iu extends Nr {
          constructor(t) {
            super(t), (this.domEventType = 'mousedown');
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        function Nu(t) {
          const e = [];
          return (
            (!t.previousSibling ||
              (function (t) {
                return t.previousSibling && fu(t.previousSibling);
              })(t)) &&
              e.push('before'),
            ((function (t) {
              return !t.nextSibling;
            })(t) ||
              (function (t) {
                return t.nextSibling && fu(t.nextSibling);
              })(t)) &&
              e.push('after'),
            e
          );
        }
        o(56);
        const Ru = ['before', 'after'],
          Ou = new DOMParser().parseFromString(
            '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><polyline points="8.05541992 0.263427734 8.05541992 4.23461914 1.28417969 4.23461914" transform="translate(1,0)"></polyline><line x1="0" y1="4.21581031" x2="2" y2="2.17810059" transform="translate(1, 0)"></line><line x1="0" y1="6.21581031" x2="2" y2="4.17810059" transform="translate(2, 5.196955) scale(1, -1) translate(-1, -5.196955)"></line></svg>\n',
            'image/svg+xml'
          ).firstChild;
        class Vu extends Hc {
          static get requires() {
            return [qh];
          }
          static get pluginName() {
            return 'WidgetTypeAround';
          }
          constructor(t) {
            super(t), (this._widgetsWithTypeAroundUI = new Set());
          }
          destroy() {
            this._widgetsWithTypeAroundUI.clear();
          }
          init() {
            this._enableTypeAroundUIInjection(),
              this._enableDetectionOfTypeAroundWidgets(),
              this._enableInsertingParagraphsOnButtonClick();
          }
          _insertParagraph(t, e) {
            const o = this.editor,
              i = o.editing.view,
              n = o.editing.mapper.toModelElement(t);
            let r;
            (r = 'before' === e ? o.model.createPositionBefore(n) : o.model.createPositionAfter(n)),
              o.execute('insertParagraph', { position: r }),
              i.focus(),
              i.scrollToTheSelection();
          }
          _enableTypeAroundUIInjection() {
            const t = this.editor,
              e = t.model.schema,
              o = t.locale.t,
              i = { before: o('Insert paragraph before block'), after: o('Insert paragraph after block') };
            t.editing.downcastDispatcher.on(
              'insert',
              (t, o, n) => {
                const r = n.mapper.toViewElement(o.item);
                (function (t, e, o) {
                  return t && fu(t) && !o.isInline(e);
                })(r, o.item, e) &&
                  (!(function (t, e, o) {
                    const i = t.createUIElement('div', { class: 'ck ck-reset_all ck-widget__type-around' }, function (
                      t
                    ) {
                      const o = this.toDomElement(t);
                      return (
                        (function (t, e) {
                          for (const o of Ru) {
                            const i = new Fl({
                              tag: 'div',
                              attributes: {
                                class: ['ck', 'ck-widget__type-around__button', 'ck-widget__type-around__button_' + o],
                                title: e[o],
                              },
                              children: [t.ownerDocument.importNode(Ou, !0)],
                            });
                            t.appendChild(i.render());
                          }
                        })(o, e),
                        o
                      );
                    });
                    t.insert(t.createPositionAt(o, 'end'), i);
                  })(n.writer, i, r),
                  this._widgetsWithTypeAroundUI.add(r));
              },
              { priority: 'low' }
            );
          }
          _enableDetectionOfTypeAroundWidgets() {
            function t(t) {
              return 'ck-widget_can-type-around_' + t;
            }
            this.editor.editing.view.document.registerPostFixer(e => {
              for (const o of this._widgetsWithTypeAroundUI)
                if (o.isAttached()) {
                  const i = Nu(o);
                  e.removeClass(Ru.map(t), o), e.addClass(i.map(t), o);
                } else this._widgetsWithTypeAroundUI.delete(o);
            });
          }
          _enableInsertingParagraphsOnButtonClick() {
            const t = this.editor.editing.view;
            t.document.on('mousedown', (e, o) => {
              const i = o.domTarget.closest('.ck-widget__type-around__button');
              if (!i) return;
              const n = (function (t) {
                  return t.classList.contains('ck-widget__type-around__button_before') ? 'before' : 'after';
                })(i),
                r = (function (t, e) {
                  const o = t.closest('.ck-widget');
                  return e.mapDomToView(o);
                })(i, t.domConverter);
              this._insertParagraph(r, n), o.preventDefault(), e.stop();
            });
          }
        }
        o(58);
        class Du extends Hc {
          static get pluginName() {
            return 'Widget';
          }
          static get requires() {
            return [Vu];
          }
          init() {
            const t = this.editor.editing.view,
              e = t.document;
            (this._previouslySelected = new Set()),
              this.editor.editing.downcastDispatcher.on(
                'selection',
                (t, e, o) => {
                  this._clearPreviouslySelectedWidgets(o.writer);
                  const i = o.writer,
                    n = i.document.selection,
                    r = n.getSelectedElement();
                  let s = null;
                  for (const t of n.getRanges())
                    for (const e of t) {
                      const t = e.item;
                      fu(t) &&
                        !zu(t, s) &&
                        (i.addClass('ck-widget_selected', t),
                        this._previouslySelected.add(t),
                        (s = t),
                        t == r && i.setSelection(n.getRanges(), { fake: !0, label: bu(r) }));
                    }
                },
                { priority: 'low' }
              ),
              t.addObserver(Iu),
              this.listenTo(e, 'mousedown', (...t) => this._onMousedown(...t)),
              this.listenTo(e, 'keydown', (...t) => this._onKeydown(...t), { priority: 'high' }),
              this.listenTo(
                e,
                'delete',
                (t, e) => {
                  this._handleDelete('forward' == e.direction) && (e.preventDefault(), t.stop());
                },
                { priority: 'high' }
              );
          }
          _onMousedown(t, e) {
            const o = this.editor,
              i = o.editing.view,
              n = i.document;
            let r = e.target;
            if (
              (function (t) {
                for (; t; ) {
                  if (t.is('editableElement') && !t.is('rootElement')) return !0;
                  if (fu(t)) return !1;
                  t = t.parent;
                }
                return !1;
              })(r)
            ) {
              if (un.isSafari && e.domEvent.detail >= 3) {
                const t = o.editing.mapper.toModelElement(r);
                this.editor.model.change(o => {
                  e.preventDefault(), o.setSelection(t, 'in');
                });
              }
              return;
            }
            if (!fu(r) && ((r = r.findAncestor(fu)), !r)) return;
            e.preventDefault(), n.isFocused || i.focus();
            const s = o.editing.mapper.toModelElement(r);
            this._setSelectionOverElement(s);
          }
          _onKeydown(t, e) {
            const o = e.keyCode,
              i = 'ltr' === this.editor.locale.contentLanguageDirection,
              n = o == fn.arrowdown || o == fn[i ? 'arrowright' : 'arrowleft'];
            let r = !1;
            !(function (t) {
              return t == fn.arrowright || t == fn.arrowleft || t == fn.arrowup || t == fn.arrowdown;
            })(o)
              ? o === fn.enter && (r = this._handleEnterKey(e.shiftKey))
              : (r = this._handleArrowKeys(n)),
              r && (e.preventDefault(), t.stop());
          }
          _handleDelete(t) {
            if (this.editor.isReadOnly) return;
            const e = this.editor.model.document.selection;
            if (!e.isCollapsed) return;
            const o = this._getObjectElementNextToSelection(t);
            return o
              ? (this.editor.model.change(t => {
                  let i = e.anchor.parent;
                  for (; i.isEmpty; ) {
                    const e = i;
                    (i = e.parent), t.remove(e);
                  }
                  this._setSelectionOverElement(o);
                }),
                !0)
              : void 0;
          }
          _handleArrowKeys(t) {
            const e = this.editor.model,
              o = e.schema,
              i = e.document.selection,
              n = i.getSelectedElement();
            if (n && o.isObject(n)) {
              const n = t ? i.getLastPosition() : i.getFirstPosition(),
                r = o.getNearestSelectionRange(n, t ? 'forward' : 'backward');
              return (
                r &&
                  e.change(t => {
                    t.setSelection(r);
                  }),
                !0
              );
            }
            if (!i.isCollapsed) return;
            const r = this._getObjectElementNextToSelection(t);
            return r && o.isObject(r) ? (this._setSelectionOverElement(r), !0) : void 0;
          }
          _handleEnterKey(t) {
            const e = this.editor.model,
              o = e.document.selection.getSelectedElement();
            if (((i = o), (n = e.schema), i && n.isObject(i) && !n.isInline(i)))
              return (
                e.change(i => {
                  let n = i.createPositionAt(o, t ? 'before' : 'after');
                  const r = i.createElement('paragraph');
                  if (e.schema.isBlock(o.parent)) {
                    const t = e.schema.findAllowedParent(n, r);
                    n = i.split(n, t).position;
                  }
                  i.insert(r, n), i.setSelection(r, 'in');
                }),
                !0
              );
            var i, n;
          }
          _setSelectionOverElement(t) {
            this.editor.model.change(e => {
              e.setSelection(e.createRangeOn(t));
            });
          }
          _getObjectElementNextToSelection(t) {
            const e = this.editor.model,
              o = e.schema,
              i = e.document.selection,
              n = e.createSelection(i);
            e.modifySelection(n, { direction: t ? 'forward' : 'backward' });
            const r = t ? n.focus.nodeBefore : n.focus.nodeAfter;
            return r && o.isObject(r) ? r : null;
          }
          _clearPreviouslySelectedWidgets(t) {
            for (const e of this._previouslySelected) t.removeClass('ck-widget_selected', e);
            this._previouslySelected.clear();
          }
        }
        function zu(t, e) {
          return !!e && Array.from(t.getAncestors()).includes(e);
        }
        class Lu extends Uc {
          refresh() {
            const t = this.editor.model.document.selection.getSelectedElement();
            (this.isEnabled = xu(t)),
              xu(t) && t.hasAttribute('alt') ? (this.value = t.getAttribute('alt')) : (this.value = !1);
          }
          execute(t) {
            const e = this.editor.model,
              o = e.document.selection.getSelectedElement();
            e.change(e => {
              e.setAttribute('alt', t.newValue, o);
            });
          }
        }
        class ju extends Hc {
          static get pluginName() {
            return 'ImageTextAlternativeEditing';
          }
          init() {
            this.editor.commands.add('imageTextAlternative', new Lu(this.editor));
          }
        }
        o(60);
        class Bu extends sc {
          constructor(t, e) {
            super(t);
            const o = 'ck-labeled-field-view-' + co(),
              i = 'ck-labeled-field-view-status-' + co();
            (this.fieldView = e(this, o, i)),
              this.set('label'),
              this.set('isEnabled', !0),
              this.set('errorText', null),
              this.set('infoText', null),
              this.set('class'),
              (this.labelView = this._createLabelView(o)),
              (this.statusView = this._createStatusView(i)),
              this.bind('_statusText').to(this, 'errorText', this, 'infoText', (t, e) => t || e);
            const n = this.bindTemplate;
            this.setTemplate({
              tag: 'div',
              attributes: {
                class: ['ck', 'ck-labeled-field-view', n.to('class'), n.if('isEnabled', 'ck-disabled', t => !t)],
              },
              children: [this.labelView, this.fieldView, this.statusView],
            });
          }
          _createLabelView(t) {
            const e = new kh(this.locale);
            return (e.for = t), e.bind('text').to(this, 'label'), e;
          }
          _createStatusView(t) {
            const e = new sc(this.locale),
              o = this.bindTemplate;
            return (
              e.setTemplate({
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-labeled-field-view__status',
                    o.if('errorText', 'ck-labeled-field-view__status_error'),
                    o.if('_statusText', 'ck-hidden', t => !t),
                  ],
                  id: t,
                  role: o.if('errorText', 'alert'),
                },
                children: [{ text: o.to('_statusText') }],
              }),
              e
            );
          }
          focus() {
            this.fieldView.focus();
          }
        }
        o(62);
        class Fu extends sc {
          constructor(t) {
            super(t),
              this.set('value'),
              this.set('id'),
              this.set('placeholder'),
              this.set('isReadOnly', !1),
              this.set('hasError', !1),
              this.set('ariaDescribedById');
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'input',
              attributes: {
                type: 'text',
                class: ['ck', 'ck-input', 'ck-input-text', e.if('hasError', 'ck-error')],
                id: e.to('id'),
                placeholder: e.to('placeholder'),
                readonly: e.to('isReadOnly'),
                'aria-invalid': e.if('hasError', !0),
                'aria-describedby': e.to('ariaDescribedById'),
              },
              on: { input: e.to('input') },
            });
          }
          render() {
            super.render();
            const t = t => {
              this.element.value = t || 0 === t ? t : '';
            };
            t(this.value),
              this.on('change:value', (e, o, i) => {
                t(i);
              });
          }
          select() {
            this.element.select();
          }
          focus() {
            this.element.focus();
          }
        }
        function Hu(t, e, o) {
          const i = new Fu(t.locale);
          return (
            i.set({ id: e, ariaDescribedById: o }),
            i.bind('isReadOnly').to(t, 'isEnabled', t => !t),
            i.bind('hasError').to(t, 'errorText', t => !!t),
            i.on('input', () => {
              t.errorText = null;
            }),
            i
          );
        }
        function Wu(t, e, o) {
          const i = Rc(t.locale);
          return i.set({ id: e, ariaDescribedById: o }), i.bind('isEnabled').to(t), i;
        }
        function Uu({ view: t }) {
          t.listenTo(
            t.element,
            'submit',
            (e, o) => {
              o.preventDefault(), t.fire('submit');
            },
            { useCapture: !0 }
          );
        }
        var qu =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
          Gu =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
        o(64);
        class Yu extends sc {
          constructor(t) {
            super(t);
            const e = this.locale.t;
            (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this.labeledInput = this._createLabeledInputView()),
              (this.saveButtonView = this._createButton(e('Save'), qu, 'ck-button-save')),
              (this.saveButtonView.type = 'submit'),
              (this.cancelButtonView = this._createButton(e('Cancel'), Gu, 'ck-button-cancel', 'cancel')),
              (this._focusables = new Bl()),
              (this._focusCycler = new uc({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              this.setTemplate({
                tag: 'form',
                attributes: { class: ['ck', 'ck-text-alternative-form'], tabindex: '-1' },
                children: [this.labeledInput, this.saveButtonView, this.cancelButtonView],
              });
          }
          render() {
            super.render(),
              this.keystrokes.listenTo(this.element),
              Uu({ view: this }),
              [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach(t => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              });
          }
          _createButton(t, e, o, i) {
            const n = new Ac(this.locale);
            return (
              n.set({ label: t, icon: e, tooltip: !0 }),
              n.extendTemplate({ attributes: { class: o } }),
              i && n.delegate('execute').to(this, i),
              n
            );
          }
          _createLabeledInputView() {
            const t = this.locale.t,
              e = new Bu(this.locale, Hu);
            return (e.label = t('Text alternative')), (e.fieldView.placeholder = t('Text alternative')), e;
          }
        }
        o(66), o(68);
        const $u = lu('px');
        class Qu extends Hc {
          static get pluginName() {
            return 'ContextualBalloon';
          }
          constructor(t) {
            super(t),
              (this.positionLimiter = () => {
                const t = this.editor.editing.view,
                  e = t.document.selection.editableElement;
                return e ? t.domConverter.mapViewToDom(e.root) : null;
              }),
              this.set('visibleView', null),
              (this.view = new hu(t.locale)),
              t.ui.view.body.add(this.view),
              t.ui.focusTracker.add(this.view.element),
              (this._viewToStack = new Map()),
              (this._idToStack = new Map()),
              this.set('_numberOfStacks', 0),
              this.set('_singleViewMode', !1),
              (this._rotatorView = this._createRotatorView()),
              (this._fakePanelsView = this._createFakePanelsView());
          }
          hasView(t) {
            return Array.from(this._viewToStack.keys()).includes(t);
          }
          add(t) {
            if (this.hasView(t.view))
              throw new uo.b('contextualballoon-add-view-exist: Cannot add configuration of the same view twice.', [
                this,
                t,
              ]);
            const e = t.stackId || 'main';
            if (!this._idToStack.has(e))
              return (
                this._idToStack.set(e, new Map([[t.view, t]])),
                this._viewToStack.set(t.view, this._idToStack.get(e)),
                (this._numberOfStacks = this._idToStack.size),
                void ((this._visibleStack && !t.singleViewMode) || this.showStack(e))
              );
            const o = this._idToStack.get(e);
            t.singleViewMode && this.showStack(e),
              o.set(t.view, t),
              this._viewToStack.set(t.view, o),
              o === this._visibleStack && this._showView(t);
          }
          remove(t) {
            if (!this.hasView(t))
              throw new uo.b(
                'contextualballoon-remove-view-not-exist: Cannot remove the configuration of a non-existent view.',
                [this, t]
              );
            const e = this._viewToStack.get(t);
            this._singleViewMode && this.visibleView === t && (this._singleViewMode = !1),
              this.visibleView === t &&
                (1 === e.size
                  ? this._idToStack.size > 1
                    ? this._showNextStack()
                    : (this.view.hide(), (this.visibleView = null), this._rotatorView.hideView())
                  : this._showView(Array.from(e.values())[e.size - 2])),
              1 === e.size
                ? (this._idToStack.delete(this._getStackId(e)), (this._numberOfStacks = this._idToStack.size))
                : e.delete(t),
              this._viewToStack.delete(t);
          }
          updatePosition(t) {
            t && (this._visibleStack.get(this.visibleView).position = t),
              this.view.pin(this._getBalloonPosition()),
              this._fakePanelsView.updatePosition();
          }
          showStack(t) {
            this.visibleStack = t;
            const e = this._idToStack.get(t);
            if (!e)
              throw new uo.b(
                'contextualballoon-showstack-stack-not-exist: Cannot show a stack that does not exist.',
                this
              );
            this._visibleStack !== e && this._showView(Array.from(e.values()).pop());
          }
          get _visibleStack() {
            return this._viewToStack.get(this.visibleView);
          }
          _getStackId(t) {
            return Array.from(this._idToStack.entries()).find(e => e[1] === t)[0];
          }
          _showNextStack() {
            const t = Array.from(this._idToStack.values());
            let e = t.indexOf(this._visibleStack) + 1;
            t[e] || (e = 0), this.showStack(this._getStackId(t[e]));
          }
          _showPrevStack() {
            const t = Array.from(this._idToStack.values());
            let e = t.indexOf(this._visibleStack) - 1;
            t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]));
          }
          _createRotatorView() {
            const t = new Ku(this.editor.locale),
              e = this.editor.locale.t;
            return (
              this.view.content.add(t),
              t.bind('isNavigationVisible').to(this, '_numberOfStacks', this, '_singleViewMode', (t, e) => !e && t > 1),
              t.on('change:isNavigationVisible', () => this.updatePosition(), { priority: 'low' }),
              t.bind('counter').to(this, 'visibleView', this, '_numberOfStacks', (t, o) => {
                if (o < 2) return '';
                const i = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                return e('%0 of %1', [i, o]);
              }),
              t.buttonNextView.on('execute', () => {
                t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
              }),
              t.buttonPrevView.on('execute', () => {
                t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
              }),
              t
            );
          }
          _createFakePanelsView() {
            const t = new Ju(this.editor.locale, this.view);
            return (
              t
                .bind('numberOfPanels')
                .to(this, '_numberOfStacks', this, '_singleViewMode', (t, e) =>
                  !e && t >= 2 ? Math.min(t - 1, 2) : 0
                ),
              t.listenTo(this.view, 'change:top', () => t.updatePosition()),
              t.listenTo(this.view, 'change:left', () => t.updatePosition()),
              this.editor.ui.view.body.add(t),
              t
            );
          }
          _showView({ view: t, balloonClassName: e = '', withArrow: o = !0, singleViewMode: i = !1 }) {
            (this.view.class = e),
              (this.view.withArrow = o),
              this._rotatorView.showView(t),
              (this.visibleView = t),
              this.view.pin(this._getBalloonPosition()),
              this._fakePanelsView.updatePosition(),
              i && (this._singleViewMode = !0);
          }
          _getBalloonPosition() {
            let t = Array.from(this._visibleStack.values()).pop().position;
            return t && !t.limiter && (t = Object.assign({}, t, { limiter: this.positionLimiter })), t;
          }
        }
        class Ku extends sc {
          constructor(t) {
            super(t);
            const e = t.t,
              o = this.bindTemplate;
            this.set('isNavigationVisible', !0),
              (this.focusTracker = new Nl()),
              (this.buttonPrevView = this._createButtonView(
                e('Previous'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'
              )),
              (this.buttonNextView = this._createButtonView(
                e('Next'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'
              )),
              (this.content = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-balloon-rotator'], 'z-index': '-1' },
                children: [
                  {
                    tag: 'div',
                    attributes: {
                      class: [
                        'ck-balloon-rotator__navigation',
                        o.to('isNavigationVisible', t => (t ? '' : 'ck-hidden')),
                      ],
                    },
                    children: [
                      this.buttonPrevView,
                      {
                        tag: 'span',
                        attributes: { class: ['ck-balloon-rotator__counter'] },
                        children: [{ text: o.to('counter') }],
                      },
                      this.buttonNextView,
                    ],
                  },
                  { tag: 'div', attributes: { class: 'ck-balloon-rotator__content' }, children: this.content },
                ],
              });
          }
          render() {
            super.render(), this.focusTracker.add(this.element);
          }
          showView(t) {
            this.hideView(), this.content.add(t);
          }
          hideView() {
            this.content.clear();
          }
          _createButtonView(t, e) {
            const o = new Ac(this.locale);
            return o.set({ label: t, icon: e, tooltip: !0 }), o;
          }
        }
        class Ju extends sc {
          constructor(t, e) {
            super(t);
            const o = this.bindTemplate;
            this.set('top', 0),
              this.set('left', 0),
              this.set('height', 0),
              this.set('width', 0),
              this.set('numberOfPanels', 0),
              (this.content = this.createCollection()),
              (this._balloonPanelView = e),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck-fake-panel', o.to('numberOfPanels', t => (t ? '' : 'ck-hidden'))],
                  style: {
                    top: o.to('top', $u),
                    left: o.to('left', $u),
                    width: o.to('width', $u),
                    height: o.to('height', $u),
                  },
                },
                children: this.content,
              }),
              this.on('change:numberOfPanels', (t, e, o, i) => {
                o > i ? this._addPanels(o - i) : this._removePanels(i - o), this.updatePosition();
              });
          }
          _addPanels(t) {
            for (; t--; ) {
              const t = new sc();
              t.setTemplate({ tag: 'div' }), this.content.add(t), this.registerChild(t);
            }
          }
          _removePanels(t) {
            for (; t--; ) {
              const t = this.content.last;
              this.content.remove(t), this.deregisterChild(t), t.destroy();
            }
          }
          updatePosition() {
            if (this.numberOfPanels) {
              const { top: t, left: e } = this._balloonPanelView,
                { width: o, height: i } = new Zr(this._balloonPanelView.element);
              Object.assign(this, { top: t, left: e, width: o, height: i });
            }
          }
        }
        function Zu(t) {
          const e = t.editing.view,
            o = hu.defaultPositions;
          return {
            target: e.domConverter.viewToDom(e.document.selection.getSelectedElement()),
            positions: [
              o.northArrowSouth,
              o.northArrowSouthWest,
              o.northArrowSouthEast,
              o.southArrowNorth,
              o.southArrowNorthWest,
              o.southArrowNorthEast,
            ],
          };
        }
        class Xu extends Hc {
          static get requires() {
            return [Qu];
          }
          static get pluginName() {
            return 'ImageTextAlternativeUI';
          }
          init() {
            this._createButton(), this._createForm();
          }
          destroy() {
            super.destroy(), this._form.destroy();
          }
          _createButton() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('imageTextAlternative', o => {
              const i = t.commands.get('imageTextAlternative'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Change image text alternative'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
                  tooltip: !0,
                }),
                n.bind('isEnabled').to(i, 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  this._showForm();
                }),
                n
              );
            });
          }
          _createForm() {
            const t = this.editor,
              e = t.editing.view.document;
            (this._balloon = this.editor.plugins.get('ContextualBalloon')),
              (this._form = new Yu(t.locale)),
              this._form.render(),
              this.listenTo(this._form, 'submit', () => {
                t.execute('imageTextAlternative', { newValue: this._form.labeledInput.fieldView.element.value }),
                  this._hideForm(!0);
              }),
              this.listenTo(this._form, 'cancel', () => {
                this._hideForm(!0);
              }),
              this._form.keystrokes.set('Esc', (t, e) => {
                this._hideForm(!0), e();
              }),
              this.listenTo(t.ui, 'update', () => {
                yu(e.selection)
                  ? this._isVisible &&
                    (function (t) {
                      const e = t.plugins.get('ContextualBalloon');
                      if (yu(t.editing.view.document.selection)) {
                        const o = Zu(t);
                        e.updatePosition(o);
                      }
                    })(t)
                  : this._hideForm(!0);
              }),
              Nc({
                emitter: this._form,
                activator: () => this._isVisible,
                contextElements: [this._balloon.view.element],
                callback: () => this._hideForm(),
              });
          }
          _showForm() {
            if (this._isVisible) return;
            const t = this.editor,
              e = t.commands.get('imageTextAlternative'),
              o = this._form.labeledInput;
            this._isInBalloon || this._balloon.add({ view: this._form, position: Zu(t) }),
              (o.fieldView.value = o.fieldView.element.value = e.value || ''),
              this._form.labeledInput.fieldView.select();
          }
          _hideForm(t) {
            this._isInBalloon &&
              (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(),
              this._balloon.remove(this._form),
              t && this.editor.editing.view.focus());
          }
          get _isVisible() {
            return this._balloon.visibleView === this._form;
          }
          get _isInBalloon() {
            return this._balloon.hasView(this._form);
          }
        }
        class tg extends Hc {
          static get requires() {
            return [ju, Xu];
          }
          static get pluginName() {
            return 'ImageTextAlternative';
          }
        }
        o(70);
        function eg(t) {
          for (const e of t.getChildren()) if (e && e.is('caption')) return e;
          return null;
        }
        function og(t) {
          const e = t.parent;
          return 'figcaption' == t.name && e && 'figure' == e.name && e.hasClass('image') ? { name: !0 } : null;
        }
        class ig extends Hc {
          static get pluginName() {
            return 'ImageCaptionEditing';
          }
          init() {
            const t = this.editor,
              e = t.editing.view,
              o = t.model.schema,
              i = t.data,
              n = t.editing,
              r = t.t;
            o.register('caption', { allowIn: 'image', allowContentOf: '$block', isLimit: !0 }),
              t.model.document.registerPostFixer(t => this._insertMissingModelCaptionElement(t)),
              t.conversion.for('upcast').elementToElement({ view: og, model: 'caption' });
            i.downcastDispatcher.on(
              'insert:caption',
              ng(t => t.createContainerElement('figcaption'), !1)
            );
            const s = (function (t, e) {
              return o => {
                const i = o.createEditableElement('figcaption');
                return o.setCustomProperty('imageCaption', !0, i), Vl({ view: t, element: i, text: e }), wu(i, o);
              };
            })(e, r('Enter image caption'));
            n.downcastDispatcher.on('insert:caption', ng(s)),
              n.downcastDispatcher.on(
                'insert',
                this._fixCaptionVisibility(t => t.item),
                { priority: 'high' }
              ),
              n.downcastDispatcher.on(
                'remove',
                this._fixCaptionVisibility(t => t.position.parent),
                { priority: 'high' }
              ),
              e.document.registerPostFixer(t => this._updateCaptionVisibility(t));
          }
          _updateCaptionVisibility(t) {
            const e = this.editor.editing.mapper,
              o = this._lastSelectedCaption;
            let i;
            const n = this.editor.model.document.selection,
              r = n.getSelectedElement();
            if (r && r.is('image')) {
              const t = eg(r);
              i = e.toViewElement(t);
            }
            const s = rg(n.getFirstPosition().parent);
            if ((s && (i = e.toViewElement(s)), i))
              return o
                ? (o === i || (sg(o, t), (this._lastSelectedCaption = i)), ag(i, t))
                : ((this._lastSelectedCaption = i), ag(i, t));
            if (o) {
              const e = sg(o, t);
              return (this._lastSelectedCaption = null), e;
            }
            return !1;
          }
          _fixCaptionVisibility(t) {
            return (e, o, i) => {
              const n = rg(t(o)),
                r = this.editor.editing.mapper,
                s = i.writer;
              if (n) {
                const t = r.toViewElement(n);
                t && (n.childCount ? s.removeClass('ck-hidden', t) : s.addClass('ck-hidden', t));
              }
            };
          }
          _insertMissingModelCaptionElement(t) {
            const e = this.editor.model,
              o = e.document.differ.getChanges(),
              i = [];
            for (const t of o)
              if ('insert' == t.type && '$text' != t.name) {
                const o = t.position.nodeAfter;
                if ((o.is('image') && !eg(o) && i.push(o), !o.is('image') && o.childCount))
                  for (const t of e.createRangeIn(o).getItems()) t.is('image') && !eg(t) && i.push(t);
              }
            for (const e of i) t.appendElement('caption', e);
            return !!i.length;
          }
        }
        function ng(t, e = !0) {
          return (o, i, n) => {
            const r = i.item;
            if ((r.childCount || e) && xu(r.parent)) {
              if (!n.consumable.consume(i.item, 'insert')) return;
              const e = n.mapper.toViewElement(i.range.start.parent),
                o = t(n.writer),
                s = n.writer;
              r.childCount || s.addClass('ck-hidden', o),
                (function (t, e, o, i) {
                  const n = i.writer.createPositionAt(o, 'end');
                  i.writer.insert(n, t), i.mapper.bindElements(e, t);
                })(o, i.item, e, n);
            }
          };
        }
        function rg(t) {
          const e = t.getAncestors({ includeSelf: !0 }).find(t => 'caption' == t.name);
          return e && e.parent && 'image' == e.parent.name ? e : null;
        }
        function sg(t, e) {
          return !t.childCount && !t.hasClass('ck-hidden') && (e.addClass('ck-hidden', t), !0);
        }
        function ag(t, e) {
          return !!t.hasClass('ck-hidden') && (e.removeClass('ck-hidden', t), !0);
        }
        o(72);
        class lg {
          constructor(t) {
            this.set('activeHandlePosition', null),
              this.set('proposedWidthPercents', null),
              this.set('proposedWidth', null),
              this.set('proposedHeight', null),
              this.set('proposedHandleHostWidth', null),
              this.set('proposedHandleHostHeight', null),
              (this._options = t),
              (this._referenceCoordinates = null);
          }
          begin(t, e, o) {
            const i = new Zr(e);
            (this.activeHandlePosition = (function (t) {
              const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
              for (const o of e) if (t.classList.contains('ck-widget__resizer__handle-' + o)) return o;
            })(t)),
              (this._referenceCoordinates = (function (t, e) {
                const o = new Zr(t),
                  i = e.split('-'),
                  n = { x: 'right' == i[1] ? o.right : o.left, y: 'bottom' == i[0] ? o.bottom : o.top };
                return (n.x += t.ownerDocument.defaultView.scrollX), (n.y += t.ownerDocument.defaultView.scrollY), n;
              })(
                e,
                (function (t) {
                  const e = t.split('-'),
                    o = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };
                  return `${o[e[0]]}-${o[e[1]]}`;
                })(this.activeHandlePosition)
              )),
              (this.originalWidth = i.width),
              (this.originalHeight = i.height),
              (this.aspectRatio = i.width / i.height);
            const n = o.style.width;
            n && n.match(/^\d+\.?\d*%$/)
              ? (this.originalWidthPercents = parseFloat(n))
              : (this.originalWidthPercents = (function (t, e) {
                  const o = t.parentElement,
                    i = parseFloat(o.ownerDocument.defaultView.getComputedStyle(o).width);
                  return (e.width / i) * 100;
                })(o, i));
          }
          update(t) {
            (this.proposedWidth = t.width),
              (this.proposedHeight = t.height),
              (this.proposedWidthPercents = t.widthPercents),
              (this.proposedHandleHostWidth = t.handleHostWidth),
              (this.proposedHandleHostHeight = t.handleHostHeight);
          }
        }
        xo(lg, Hi);
        class cg {
          constructor(t) {
            (this._options = t),
              (this._domResizerWrapper = null),
              (this._viewResizerWrapper = null),
              this.set('isEnabled', !0),
              this.decorate('begin'),
              this.decorate('cancel'),
              this.decorate('commit'),
              this.decorate('updateSize'),
              this.on(
                'commit',
                t => {
                  this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), t.stop());
                },
                { priority: 'high' }
              );
          }
          attach() {
            const t = this,
              e = this._options.viewElement;
            this._options.editor.editing.view.change(o => {
              const i = o.createUIElement('div', { class: 'ck ck-reset_all ck-widget__resizer' }, function (e) {
                const o = this.toDomElement(e);
                return (
                  t._appendHandles(o),
                  t._appendSizeUI(o),
                  (t._domResizerWrapper = o),
                  t.on('change:isEnabled', (t, e, i) => {
                    o.style.display = i ? '' : 'none';
                  }),
                  (o.style.display = t.isEnabled ? '' : 'none'),
                  o
                );
              });
              o.insert(o.createPositionAt(e, 'end'), i),
                o.addClass('ck-widget_with-resizer', e),
                (this._viewResizerWrapper = i);
            });
          }
          begin(t) {
            (this.state = new lg(this._options)),
              this._sizeUI.bindToState(this._options, this.state),
              (this._initialViewWidth = this._options.viewElement.getStyle('width')),
              this.state.begin(t, this._getHandleHost(), this._getResizeHost());
          }
          updateSize(t) {
            const e = this._proposeNewSize(t);
            this._options.editor.editing.view.change(t => {
              const o = this._options.unit || '%',
                i = ('%' === o ? e.widthPercents : e.width) + o;
              t.setStyle('width', i, this._options.viewElement);
            });
            const o = this._getHandleHost(),
              i = new Zr(o);
            (e.handleHostWidth = Math.round(i.width)), (e.handleHostHeight = Math.round(i.height));
            const n = new Zr(o);
            (e.width = Math.round(n.width)), (e.height = Math.round(n.height)), this.redraw(i), this.state.update(e);
          }
          commit() {
            const t = this._options.unit || '%',
              e = ('%' === t ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
            this._options.editor.editing.view.change(() => {
              this._cleanup(), this._options.onCommit(e);
            });
          }
          cancel() {
            this._cleanup();
          }
          destroy() {
            this.cancel();
          }
          redraw(t) {
            const e = this._domResizerWrapper;
            var o;
            (o = e) &&
              o.ownerDocument &&
              o.ownerDocument.contains(o) &&
              this._options.editor.editing.view.change(o => {
                const i = e.parentElement,
                  n = this._getHandleHost(),
                  r = t || new Zr(n);
                o.setStyle('width', r.width + 'px', this._viewResizerWrapper),
                  o.setStyle('height', r.height + 'px', this._viewResizerWrapper);
                const s = n.offsetLeft,
                  a = n.offsetTop,
                  l = n.offsetHeight,
                  c = n.offsetWidth;
                i.isSameNode(n) ||
                  (o.setStyle('left', s + 'px', this._viewResizerWrapper),
                  o.setStyle('top', a + 'px', this._viewResizerWrapper),
                  o.setStyle('height', l + 'px', this._viewResizerWrapper),
                  o.setStyle('width', c + 'px', this._viewResizerWrapper));
              });
          }
          containsHandle(t) {
            return this._domResizerWrapper.contains(t);
          }
          static isResizeHandle(t) {
            return t.classList.contains('ck-widget__resizer__handle');
          }
          _cleanup() {
            this._sizeUI.dismiss(), (this._sizeUI.isVisible = !1);
            this._options.editor.editing.view.change(t => {
              t.setStyle('width', this._initialViewWidth, this._options.viewElement);
            });
          }
          _proposeNewSize(t) {
            const e = this.state,
              o = { x: (i = t).pageX, y: i.pageY };
            var i;
            const n = !this._options.isCentered || this._options.isCentered(this),
              r = {
                x: e._referenceCoordinates.x - (o.x + e.originalWidth),
                y: o.y - e.originalHeight - e._referenceCoordinates.y,
              };
            n &&
              e.activeHandlePosition.endsWith('-right') &&
              (r.x = o.x - (e._referenceCoordinates.x + e.originalWidth)),
              n && (r.x *= 2);
            const s = { width: Math.abs(e.originalWidth + r.x), height: Math.abs(e.originalHeight + r.y) };
            (s.dominant = s.width / e.aspectRatio > s.height ? 'width' : 'height'), (s.max = s[s.dominant]);
            const a = { width: s.width, height: s.height };
            return (
              'width' == s.dominant ? (a.height = a.width / e.aspectRatio) : (a.width = a.height * e.aspectRatio),
              {
                width: Math.round(a.width),
                height: Math.round(a.height),
                widthPercents: Math.min(
                  Math.round((e.originalWidthPercents / e.originalWidth) * a.width * 100) / 100,
                  100
                ),
              }
            );
          }
          _getResizeHost() {
            const t = this._domResizerWrapper.parentElement;
            return this._options.getResizeHost(t);
          }
          _getHandleHost() {
            const t = this._domResizerWrapper.parentElement;
            return this._options.getHandleHost(t);
          }
          _appendHandles(t) {
            const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
            for (const i of e)
              t.appendChild(
                new Fl({
                  tag: 'div',
                  attributes: { class: 'ck-widget__resizer__handle ' + ((o = i), 'ck-widget__resizer__handle-' + o) },
                }).render()
              );
            var o;
          }
          _appendSizeUI(t) {
            const e = new dg();
            e.render(), (this._sizeUI = e), t.appendChild(e.element);
          }
        }
        xo(cg, Hi);
        class dg extends sc {
          constructor() {
            super();
            const t = this.bindTemplate;
            this.setTemplate({
              tag: 'div',
              attributes: {
                class: ['ck', 'ck-size-view', t.to('activeHandlePosition', t => (t ? 'ck-orientation-' + t : ''))],
                style: { display: t.if('isVisible', 'none', t => !t) },
              },
              children: [{ text: t.to('label') }],
            });
          }
          bindToState(t, e) {
            this.bind('isVisible').to(e, 'proposedWidth', e, 'proposedHeight', (t, e) => null !== t && null !== e),
              this.bind('label').to(
                e,
                'proposedHandleHostWidth',
                e,
                'proposedHandleHostHeight',
                e,
                'proposedWidthPercents',
                (e, o, i) => ('px' === t.unit ? `${e}×${o}` : i + '%')
              ),
              this.bind('activeHandlePosition').to(e);
          }
          dismiss() {
            this.unbind(), (this.isVisible = !1);
          }
        }
        var hg = function (t, e, o) {
          var i = !0,
            n = !0;
          if ('function' != typeof t) throw new TypeError('Expected a function');
          return (
            z(o) && ((i = 'leading' in o ? !!o.leading : i), (n = 'trailing' in o ? !!o.trailing : n)),
            Wr(t, e, { leading: i, maxWait: e, trailing: n })
          );
        };
        o(74);
        class ug extends Hc {
          static get pluginName() {
            return 'WidgetResize';
          }
          init() {
            this.set('_visibleResizer', null), this.set('_activeResizer', null), (this._resizers = new Map());
            const t = Xn.window.document;
            this.editor.model.schema.setAttributeProperties('width', { isFormatting: !0 }),
              (this._observer = Object.create(lr)),
              this._observer.listenTo(t, 'mousedown', this._mouseDownListener.bind(this)),
              this._observer.listenTo(t, 'mousemove', this._mouseMoveListener.bind(this)),
              this._observer.listenTo(t, 'mouseup', this._mouseUpListener.bind(this));
            const e = () => {
                this._visibleResizer && this._visibleResizer.redraw();
              },
              o = hg(e, 200);
            this.on('change:_visibleResizer', e),
              this.editor.ui.on('update', o),
              this._observer.listenTo(Xn.window, 'resize', o);
            const i = this.editor.editing.view.document.selection;
            i.on('change', () => {
              const t = i.getSelectedElement();
              this._visibleResizer = this._getResizerByViewElement(t) || null;
            });
          }
          destroy() {
            this._observer.stopListening();
            for (const t of this._resizers.values()) t.destroy();
          }
          attachTo(t) {
            const e = new cg(t),
              o = this.editor.plugins;
            if ((e.attach(), o.has('WidgetToolbarRepository'))) {
              const t = o.get('WidgetToolbarRepository');
              e.on(
                'begin',
                () => {
                  t.forceDisabled('resize');
                },
                { priority: 'lowest' }
              ),
                e.on(
                  'cancel',
                  () => {
                    t.clearForceDisabled('resize');
                  },
                  { priority: 'highest' }
                ),
                e.on(
                  'commit',
                  () => {
                    t.clearForceDisabled('resize');
                  },
                  { priority: 'highest' }
                );
            }
            return this._resizers.set(t.viewElement, e), e;
          }
          _getResizerByHandle(t) {
            for (const e of this._resizers.values()) if (e.containsHandle(t)) return e;
          }
          _getResizerByViewElement(t) {
            return this._resizers.get(t);
          }
          _mouseDownListener(t, e) {
            if (!cg.isResizeHandle(e.target)) return;
            const o = e.target;
            (this._activeResizer = this._getResizerByHandle(o)), this._activeResizer && this._activeResizer.begin(o);
          }
          _mouseMoveListener(t, e) {
            this._activeResizer && this._activeResizer.updateSize(e);
          }
          _mouseUpListener() {
            this._activeResizer && (this._activeResizer.commit(), (this._activeResizer = null));
          }
        }
        xo(ug, Hi);
        class gg extends Uc {
          refresh() {
            const t = this.editor.model.document.selection.getSelectedElement();
            (this.isEnabled = xu(t)),
              t && t.hasAttribute('width')
                ? (this.value = { width: t.getAttribute('width'), height: null })
                : (this.value = null);
          }
          execute(t) {
            const e = this.editor.model,
              o = e.document.selection.getSelectedElement();
            e.change(e => {
              e.setAttribute('width', t.width, o);
            });
          }
        }
        o(76);
        class mg extends Uc {
          constructor(t, e) {
            super(t),
              (this.defaultStyle = !1),
              (this.styles = e.reduce((t, e) => ((t[e.name] = e), e.isDefault && (this.defaultStyle = e.name), t), {}));
          }
          refresh() {
            const t = this.editor.model.document.selection.getSelectedElement();
            if (((this.isEnabled = xu(t)), t))
              if (t.hasAttribute('imageStyle')) {
                const e = t.getAttribute('imageStyle');
                this.value = !!this.styles[e] && e;
              } else this.value = this.defaultStyle;
            else this.value = !1;
          }
          execute(t) {
            const e = t.value,
              o = this.editor.model,
              i = o.document.selection.getSelectedElement();
            o.change(t => {
              this.styles[e].isDefault ? t.removeAttribute('imageStyle', i) : t.setAttribute('imageStyle', e, i);
            });
          }
        }
        function fg(t, e) {
          for (const o of e) if (o.name === t) return o;
        }
        var pg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm2.5 3V12h11V7.5h-11zM4.061 6H15.94c.586 0 1.061.407 1.061.91v5.68c0 .503-.475.91-1.061.91H4.06c-.585 0-1.06-.407-1.06-.91V6.91C3 6.406 3.475 6 4.061 6zM2 16.5V15h16v1.5z"/></svg>',
          bg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M18 4.5V3H2v1.5h16zm0 3V6h-5.674v1.5H18zm0 3V9h-5.674v1.5H18zm0 3V12h-5.674v1.5H18zm-8.5-6V12h-6V7.5h6zm.818-1.5H2.682C2.305 6 2 6.407 2 6.91v5.68c0 .503.305.91.682.91h7.636c.377 0 .682-.407.682-.91V6.91c0-.503-.305-.91-.682-.91zM18 16.5V15H2v1.5h16z"/></svg>',
          wg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm4.5 3V12h7V7.5h-7zM5.758 6h8.484c.419 0 .758.407.758.91v5.681c0 .502-.34.909-.758.909H5.758c-.419 0-.758-.407-.758-.91V6.91c0-.503.34-.91.758-.91zM2 16.5V15h16v1.5z"/></svg>',
          kg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm0 3V6h5.674v1.5zm0 3V9h5.674v1.5zm0 3V12h5.674v1.5zm8.5-6V12h6V7.5h-6zM9.682 6h7.636c.377 0 .682.407.682.91v5.68c0 .503-.305.91-.682.91H9.682c-.377 0-.682-.407-.682-.91V6.91c0-.503.305-.91.682-.91zM2 16.5V15h16v1.5z"/></svg>';
        const _g = {
            full: { name: 'full', title: 'Full size image', icon: pg, isDefault: !0 },
            side: { name: 'side', title: 'Side image', icon: kg, className: 'image-style-side' },
            alignLeft: {
              name: 'alignLeft',
              title: 'Left aligned image',
              icon: bg,
              className: 'image-style-align-left',
            },
            alignCenter: {
              name: 'alignCenter',
              title: 'Centered image',
              icon: wg,
              className: 'image-style-align-center',
            },
            alignRight: {
              name: 'alignRight',
              title: 'Right aligned image',
              icon: kg,
              className: 'image-style-align-right',
            },
          },
          vg = { full: pg, left: bg, right: kg, center: wg };
        function yg(t = []) {
          return t.map(xg);
        }
        function xg(t) {
          if ('string' == typeof t) {
            const e = t;
            _g[e]
              ? (t = Object.assign({}, _g[e]))
              : (console.warn(Object(uo.a)('image-style-not-found: There is no such image style of given name.'), {
                  name: e,
                }),
                (t = { name: e }));
          } else if (_g[t.name]) {
            const e = _g[t.name],
              o = Object.assign({}, t);
            for (const i in e) t.hasOwnProperty(i) || (o[i] = e[i]);
            t = o;
          }
          return 'string' == typeof t.icon && vg[t.icon] && (t.icon = vg[t.icon]), t;
        }
        class Cg extends Hc {
          static get pluginName() {
            return 'ImageStyleEditing';
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              o = t.data,
              i = t.editing;
            t.config.define('image.styles', ['full', 'side']);
            const n = yg(t.config.get('image.styles'));
            e.extend('image', { allowAttributes: 'imageStyle' });
            const r = (function (t) {
              return (e, o, i) => {
                if (!i.consumable.consume(o.item, e.name)) return;
                const n = fg(o.attributeNewValue, t),
                  r = fg(o.attributeOldValue, t),
                  s = i.mapper.toViewElement(o.item),
                  a = i.writer;
                r && a.removeClass(r.className, s), n && a.addClass(n.className, s);
              };
            })(n);
            i.downcastDispatcher.on('attribute:imageStyle:image', r),
              o.downcastDispatcher.on('attribute:imageStyle:image', r),
              o.upcastDispatcher.on(
                'element:figure',
                (function (t) {
                  const e = t.filter(t => !t.isDefault);
                  return (t, o, i) => {
                    if (!o.modelRange) return;
                    const n = o.viewItem,
                      r = Gc(o.modelRange.getItems());
                    if (i.schema.checkAttribute(r, 'imageStyle'))
                      for (const t of e)
                        i.consumable.consume(n, { classes: t.className }) &&
                          i.writer.setAttribute('imageStyle', t.name, r);
                  };
                })(n),
                { priority: 'low' }
              ),
              t.commands.add('imageStyle', new mg(t, n));
          }
        }
        o(78);
        class Ag extends Hc {
          static get pluginName() {
            return 'ImageStyleUI';
          }
          get localizedDefaultStylesTitles() {
            const t = this.editor.t;
            return {
              'Full size image': t('Full size image'),
              'Side image': t('Side image'),
              'Left aligned image': t('Left aligned image'),
              'Centered image': t('Centered image'),
              'Right aligned image': t('Right aligned image'),
            };
          }
          init() {
            const t = (function (t, e) {
              for (const o of t) e[o.title] && (o.title = e[o.title]);
              return t;
            })(yg(this.editor.config.get('image.styles')), this.localizedDefaultStylesTitles);
            for (const e of t) this._createButton(e);
          }
          _createButton(t) {
            const e = this.editor,
              o = 'imageStyle:' + t.name;
            e.ui.componentFactory.add(o, o => {
              const i = e.commands.get('imageStyle'),
                n = new Ac(o);
              return (
                n.set({ label: t.title, icon: t.icon, tooltip: !0, isToggleable: !0 }),
                n.bind('isEnabled').to(i, 'isEnabled'),
                n.bind('isOn').to(i, 'value', e => e === t.name),
                this.listenTo(n, 'execute', () => {
                  e.execute('imageStyle', { value: t.name }), e.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        class Tg extends Hc {
          static get requires() {
            return [Qu];
          }
          static get pluginName() {
            return 'WidgetToolbarRepository';
          }
          init() {
            const t = this.editor;
            if (t.plugins.has('BalloonToolbar')) {
              const e = t.plugins.get('BalloonToolbar');
              this.listenTo(
                e,
                'show',
                e => {
                  (function (t) {
                    const e = t.getSelectedElement();
                    return !(!e || !fu(e));
                  })(t.editing.view.document.selection) && e.stop();
                },
                { priority: 'high' }
              );
            }
            (this._toolbarDefinitions = new Map()),
              (this._balloon = this.editor.plugins.get('ContextualBalloon')),
              this.on('change:isEnabled', () => {
                this._updateToolbarsVisibility();
              }),
              this.listenTo(t.ui, 'update', () => {
                this._updateToolbarsVisibility();
              }),
              this.listenTo(
                t.ui.focusTracker,
                'change:isFocused',
                () => {
                  this._updateToolbarsVisibility();
                },
                { priority: 'low' }
              );
          }
          destroy() {
            super.destroy();
            for (const t of this._toolbarDefinitions.values()) t.view.destroy();
          }
          register(t, { ariaLabel: e, items: o, getRelatedElement: i, balloonClassName: n = 'ck-toolbar-container' }) {
            const r = this.editor,
              s = r.t,
              a = new Dc(r.locale);
            if (((a.ariaLabel = e || s('Widget toolbar')), this._toolbarDefinitions.has(t)))
              throw new uo.b('widget-toolbar-duplicated: Toolbar with the given id was already added.', this, {
                toolbarId: t,
              });
            a.fillFromConfig(o, r.ui.componentFactory),
              this._toolbarDefinitions.set(t, { view: a, getRelatedElement: i, balloonClassName: n });
          }
          _updateToolbarsVisibility() {
            let t = 0,
              e = null,
              o = null;
            for (const i of this._toolbarDefinitions.values()) {
              const n = i.getRelatedElement(this.editor.editing.view.document.selection);
              if (this.isEnabled && n)
                if (this.editor.ui.focusTracker.isFocused) {
                  const r = n.getAncestors().length;
                  r > t && ((t = r), (e = n), (o = i));
                } else this._isToolbarVisible(i) && this._hideToolbar(i);
              else this._isToolbarInBalloon(i) && this._hideToolbar(i);
            }
            o && this._showToolbar(o, e);
          }
          _hideToolbar(t) {
            this._balloon.remove(t.view), this.stopListening(this._balloon, 'change:visibleView');
          }
          _showToolbar(t, e) {
            this._isToolbarVisible(t)
              ? Sg(this.editor, e)
              : this._isToolbarInBalloon(t) ||
                (this._balloon.add({
                  view: t.view,
                  position: Pg(this.editor, e),
                  balloonClassName: t.balloonClassName,
                }),
                this.listenTo(this._balloon, 'change:visibleView', () => {
                  for (const t of this._toolbarDefinitions.values())
                    if (this._isToolbarVisible(t)) {
                      const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                      Sg(this.editor, e);
                    }
                }));
          }
          _isToolbarVisible(t) {
            return this._balloon.visibleView === t.view;
          }
          _isToolbarInBalloon(t) {
            return this._balloon.hasView(t.view);
          }
        }
        function Sg(t, e) {
          const o = t.plugins.get('ContextualBalloon'),
            i = Pg(t, e);
          o.updatePosition(i);
        }
        function Pg(t, e) {
          const o = t.editing.view,
            i = hu.defaultPositions;
          return {
            target: o.domConverter.mapViewToDom(e),
            positions: [
              i.northArrowSouth,
              i.northArrowSouthWest,
              i.northArrowSouthEast,
              i.southArrowNorth,
              i.southArrowNorthWest,
              i.southArrowNorthEast,
              _u,
            ],
          };
        }
        class Eg extends sc {
          constructor(t) {
            super(t),
              (this.buttonView = new Ac(t)),
              (this._fileInputView = new Mg(t)),
              this._fileInputView.bind('acceptedType').to(this),
              this._fileInputView.bind('allowMultipleFiles').to(this),
              this._fileInputView.delegate('done').to(this),
              this.setTemplate({
                tag: 'span',
                attributes: { class: 'ck-file-dialog-button' },
                children: [this.buttonView, this._fileInputView],
              }),
              this.buttonView.on('execute', () => {
                this._fileInputView.open();
              });
          }
          focus() {
            this.buttonView.focus();
          }
        }
        class Mg extends sc {
          constructor(t) {
            super(t), this.set('acceptedType'), this.set('allowMultipleFiles', !1);
            const e = this.bindTemplate;
            this.setTemplate({
              tag: 'input',
              attributes: {
                class: ['ck-hidden'],
                type: 'file',
                tabindex: '-1',
                accept: e.to('acceptedType'),
                multiple: e.to('allowMultipleFiles'),
              },
              on: {
                change: e.to(() => {
                  this.element &&
                    this.element.files &&
                    this.element.files.length &&
                    this.fire('done', this.element.files),
                    (this.element.value = '');
                }),
              },
            });
          }
          open() {
            this.element.click();
          }
        }
        function Ig(t) {
          const e = t.map(t => t.replace('+', '\\+'));
          return new RegExp(`^image\\/(${e.join('|')})$`);
        }
        class Ng extends Hc {
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('imageUpload', o => {
              const i = new Eg(o),
                n = t.commands.get('imageUpload'),
                r = t.config.get('image.upload.types'),
                s = Ig(r);
              return (
                i.set({ acceptedType: r.map(t => 'image/' + t).join(','), allowMultipleFiles: !0 }),
                i.buttonView.set({
                  label: e('Insert image'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
                  tooltip: !0,
                }),
                i.buttonView.bind('isEnabled').to(n),
                i.on('done', (e, o) => {
                  const i = Array.from(o).filter(t => s.test(t.type));
                  i.length && t.execute('imageUpload', { file: i });
                }),
                i
              );
            });
          }
        }
        class Rg {
          constructor(t) {
            this.context = t;
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return !0;
          }
        }
        xo(Rg, Hi);
        class Og extends Rg {
          static get pluginName() {
            return 'PendingActions';
          }
          init() {
            this.set('hasAny', !1),
              (this._actions = new Co({ idProperty: '_id' })),
              this._actions.delegate('add', 'remove').to(this);
          }
          add(t) {
            if ('string' != typeof t)
              throw new uo.b('pendingactions-add-invalid-message: The message must be a string.', this);
            const e = Object.create(Hi);
            return e.set('message', t), this._actions.add(e), (this.hasAny = !0), e;
          }
          remove(t) {
            this._actions.remove(t), (this.hasAny = !!this._actions.length);
          }
          get first() {
            return this._actions.get(0);
          }
          [Symbol.iterator]() {
            return this._actions[Symbol.iterator]();
          }
        }
        class Vg {
          constructor() {
            const t = new window.FileReader();
            (this._reader = t),
              (this._data = void 0),
              this.set('loaded', 0),
              (t.onprogress = t => {
                this.loaded = t.loaded;
              });
          }
          get error() {
            return this._reader.error;
          }
          get data() {
            return this._data;
          }
          read(t) {
            const e = this._reader;
            return (
              (this.total = t.size),
              new Promise((o, i) => {
                (e.onload = () => {
                  const t = e.result;
                  (this._data = t), o(t);
                }),
                  (e.onerror = () => {
                    i('error');
                  }),
                  (e.onabort = () => {
                    i('aborted');
                  }),
                  this._reader.readAsDataURL(t);
              })
            );
          }
          abort() {
            this._reader.abort();
          }
        }
        xo(Vg, Hi);
        class Dg extends Hc {
          static get pluginName() {
            return 'FileRepository';
          }
          static get requires() {
            return [Og];
          }
          init() {
            (this.loaders = new Co()),
              this.loaders.on('add', () => this._updatePendingAction()),
              this.loaders.on('remove', () => this._updatePendingAction()),
              (this._loadersMap = new Map()),
              (this._pendingAction = null),
              this.set('uploaded', 0),
              this.set('uploadTotal', null),
              this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (t, e) => (e ? (t / e) * 100 : 0));
          }
          getLoader(t) {
            return this._loadersMap.get(t) || null;
          }
          createLoader(t) {
            if (!this.createUploadAdapter)
              return (
                console.warn(Object(uo.a)('filerepository-no-upload-adapter: Upload adapter is not defined.')), null
              );
            const e = new zg(Promise.resolve(t), this.createUploadAdapter);
            return (
              this.loaders.add(e),
              this._loadersMap.set(t, e),
              t instanceof Promise &&
                e.file
                  .then(t => {
                    this._loadersMap.set(t, e);
                  })
                  .catch(() => {}),
              e.on('change:uploaded', () => {
                let t = 0;
                for (const e of this.loaders) t += e.uploaded;
                this.uploaded = t;
              }),
              e.on('change:uploadTotal', () => {
                let t = 0;
                for (const e of this.loaders) e.uploadTotal && (t += e.uploadTotal);
                this.uploadTotal = t;
              }),
              e
            );
          }
          destroyLoader(t) {
            const e = t instanceof zg ? t : this.getLoader(t);
            e._destroy(),
              this.loaders.remove(e),
              this._loadersMap.forEach((t, o) => {
                t === e && this._loadersMap.delete(o);
              });
          }
          _updatePendingAction() {
            const t = this.editor.plugins.get(Og);
            if (this.loaders.length) {
              if (!this._pendingAction) {
                const e = this.editor.t,
                  o = t => `${e('Upload in progress')} ${parseInt(t)}%.`;
                (this._pendingAction = t.add(o(this.uploadedPercent))),
                  this._pendingAction.bind('message').to(this, 'uploadedPercent', o);
              }
            } else t.remove(this._pendingAction), (this._pendingAction = null);
          }
        }
        xo(Dg, Hi);
        class zg {
          constructor(t, e) {
            (this.id = co()),
              (this._filePromiseWrapper = this._createFilePromiseWrapper(t)),
              (this._adapter = e(this)),
              (this._reader = new Vg()),
              this.set('status', 'idle'),
              this.set('uploaded', 0),
              this.set('uploadTotal', null),
              this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', (t, e) => (e ? (t / e) * 100 : 0)),
              this.set('uploadResponse', null);
          }
          get file() {
            return this._filePromiseWrapper
              ? this._filePromiseWrapper.promise.then(t => (this._filePromiseWrapper ? t : null))
              : Promise.resolve(null);
          }
          get data() {
            return this._reader.data;
          }
          read() {
            if ('idle' != this.status)
              throw new uo.b(
                'filerepository-read-wrong-status: You cannot call read if the status is different than idle.',
                this
              );
            return (
              (this.status = 'reading'),
              this.file
                .then(t => this._reader.read(t))
                .then(t => {
                  if ('reading' !== this.status) throw this.status;
                  return (this.status = 'idle'), t;
                })
                .catch(t => {
                  if ('aborted' === t) throw ((this.status = 'aborted'), 'aborted');
                  throw ((this.status = 'error'), this._reader.error ? this._reader.error : t);
                })
            );
          }
          upload() {
            if ('idle' != this.status)
              throw new uo.b(
                'filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.',
                this
              );
            return (
              (this.status = 'uploading'),
              this.file
                .then(() => this._adapter.upload())
                .then(t => ((this.uploadResponse = t), (this.status = 'idle'), t))
                .catch(t => {
                  if ('aborted' === this.status) throw 'aborted';
                  throw ((this.status = 'error'), t);
                })
            );
          }
          abort() {
            const t = this.status;
            (this.status = 'aborted'),
              this._filePromiseWrapper.isFulfilled
                ? 'reading' == t
                  ? this._reader.abort()
                  : 'uploading' == t && this._adapter.abort && this._adapter.abort()
                : (this._filePromiseWrapper.promise.catch(() => {}), this._filePromiseWrapper.rejecter('aborted')),
              this._destroy();
          }
          _destroy() {
            (this._filePromiseWrapper = void 0),
              (this._reader = void 0),
              (this._adapter = void 0),
              (this.uploadResponse = void 0);
          }
          _createFilePromiseWrapper(t) {
            const e = {};
            return (
              (e.promise = new Promise((o, i) => {
                (e.rejecter = i),
                  (e.isFulfilled = !1),
                  t
                    .then(t => {
                      (e.isFulfilled = !0), o(t);
                    })
                    .catch(t => {
                      (e.isFulfilled = !0), i(t);
                    });
              })),
              e
            );
          }
        }
        xo(zg, Hi);
        o(80), o(82), o(84);
        class Lg extends Hc {
          constructor(t) {
            super(t),
              (this.placeholder =
                'data:image/svg+xml;utf8,' +
                encodeURIComponent(
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>'
                ));
          }
          init() {
            this.editor.editing.downcastDispatcher.on('attribute:uploadStatus:image', (...t) =>
              this.uploadStatusChange(...t)
            );
          }
          uploadStatusChange(t, e, o) {
            const i = this.editor,
              n = e.item,
              r = n.getAttribute('uploadId');
            if (!o.consumable.consume(e.item, t.name)) return;
            const s = i.plugins.get(Dg),
              a = r ? e.attributeNewValue : null,
              l = this.placeholder,
              c = i.editing.mapper.toViewElement(n),
              d = o.writer;
            if ('reading' == a) return jg(c, d), void Bg(l, c, d);
            if ('uploading' == a) {
              const t = s.loaders.get(r);
              return (
                jg(c, d),
                void (t
                  ? (Fg(c, d),
                    (function (t, e, o, i) {
                      const n = (function (t) {
                        const e = t.createUIElement('div', { class: 'ck-progress-bar' });
                        return t.setCustomProperty('progressBar', !0, e), e;
                      })(e);
                      e.insert(e.createPositionAt(t, 'end'), n),
                        o.on('change:uploadedPercent', (t, e, o) => {
                          i.change(t => {
                            t.setStyle('width', o + '%', n);
                          });
                        });
                    })(c, d, t, i.editing.view),
                    (function (t, e, o) {
                      if (o.data) {
                        const i = Tu(t);
                        e.setAttribute('src', o.data, i);
                      }
                    })(c, d, t))
                  : Bg(l, c, d))
              );
            }
            'complete' == a &&
              s.loaders.get(r) &&
              (function (t, e, o) {
                const i = e.createUIElement('div', { class: 'ck-image-upload-complete-icon' });
                e.insert(e.createPositionAt(t, 'end'), i),
                  setTimeout(() => {
                    o.change(t => t.remove(t.createRangeOn(i)));
                  }, 3e3);
              })(c, d, i.editing.view),
              (function (t, e) {
                Wg(t, e, 'progressBar');
              })(c, d),
              Fg(c, d),
              (function (t, e) {
                e.removeClass('ck-appear', t);
              })(c, d);
          }
        }
        function jg(t, e) {
          t.hasClass('ck-appear') || e.addClass('ck-appear', t);
        }
        function Bg(t, e, o) {
          e.hasClass('ck-image-upload-placeholder') || o.addClass('ck-image-upload-placeholder', e);
          const i = Tu(e);
          i.getAttribute('src') !== t && o.setAttribute('src', t, i),
            Hg(e, 'placeholder') ||
              o.insert(
                o.createPositionAfter(i),
                (function (t) {
                  const e = t.createUIElement('div', { class: 'ck-upload-placeholder-loader' });
                  return t.setCustomProperty('placeholder', !0, e), e;
                })(o)
              );
        }
        function Fg(t, e) {
          t.hasClass('ck-image-upload-placeholder') && e.removeClass('ck-image-upload-placeholder', t),
            Wg(t, e, 'placeholder');
        }
        function Hg(t, e) {
          for (const o of t.getChildren()) if (o.getCustomProperty(e)) return o;
        }
        function Wg(t, e, o) {
          const i = Hg(t, o);
          i && e.remove(e.createRangeOn(i));
        }
        class Ug extends Rg {
          static get pluginName() {
            return 'Notification';
          }
          init() {
            this.on(
              'show:warning',
              (t, e) => {
                window.alert(e.message);
              },
              { priority: 'lowest' }
            );
          }
          showSuccess(t, e = {}) {
            this._showNotification({ message: t, type: 'success', namespace: e.namespace, title: e.title });
          }
          showInfo(t, e = {}) {
            this._showNotification({ message: t, type: 'info', namespace: e.namespace, title: e.title });
          }
          showWarning(t, e = {}) {
            this._showNotification({ message: t, type: 'warning', namespace: e.namespace, title: e.title });
          }
          _showNotification(t) {
            const e = 'show:' + t.type + (t.namespace ? ':' + t.namespace : '');
            this.fire(e, { message: t.message, type: t.type, title: t.title || '' });
          }
        }
        class qg {
          constructor(t) {
            this.document = t;
          }
          createDocumentFragment(t) {
            return new xn(this.document, t);
          }
          createElement(t, e, o) {
            return new Ri(this.document, t, e, o);
          }
          createText(t) {
            return new Oo(this.document, t);
          }
          clone(t, e = !1) {
            return t._clone(e);
          }
          appendChild(t, e) {
            return e._appendChild(t);
          }
          insertChild(t, e, o) {
            return o._insertChild(t, e);
          }
          removeChildren(t, e, o) {
            return o._removeChildren(t, e);
          }
          remove(t) {
            const e = t.parent;
            return e ? this.removeChildren(e.getChildIndex(t), 1, e) : [];
          }
          replace(t, e) {
            const o = t.parent;
            if (o) {
              const i = o.getChildIndex(t);
              return this.removeChildren(i, 1, o), this.insertChild(i, e, o), !0;
            }
            return !1;
          }
          unwrapElement(t) {
            const e = t.parent;
            if (e) {
              const o = e.getChildIndex(t);
              this.remove(t), this.insertChild(o, t.getChildren(), e);
            }
          }
          rename(t, e) {
            const o = new Ri(this.document, t, e.getAttributes(), e.getChildren());
            return this.replace(e, o) ? o : null;
          }
          setAttribute(t, e, o) {
            o._setAttribute(t, e);
          }
          removeAttribute(t, e) {
            e._removeAttribute(t);
          }
          addClass(t, e) {
            e._addClass(t);
          }
          removeClass(t, e) {
            e._removeClass(t);
          }
          setStyle(t, e, o) {
            y(t) && void 0 === o && (o = e), o._setStyle(t, e);
          }
          removeStyle(t, e) {
            e._removeStyle(t);
          }
          setCustomProperty(t, e, o) {
            o._setCustomProperty(t, e);
          }
          removeCustomProperty(t, e) {
            return e._removeCustomProperty(t);
          }
          createPositionAt(t, e) {
            return Zi._createAt(t, e);
          }
          createPositionAfter(t) {
            return Zi._createAfter(t);
          }
          createPositionBefore(t) {
            return Zi._createBefore(t);
          }
          createRange(t, e) {
            return new Xi(t, e);
          }
          createRangeOn(t) {
            return Xi._createOn(t);
          }
          createRangeIn(t) {
            return Xi._createIn(t);
          }
          createSelection(t, e, o) {
            return new on(t, e, o);
          }
        }
        class Gg extends Uc {
          refresh() {
            this.isEnabled = Au(this.editor.model);
          }
          execute(t) {
            const e = this.editor,
              o = e.model,
              i = e.plugins.get(Dg);
            o.change(e => {
              const n = Array.isArray(t.file) ? t.file : [t.file];
              for (const t of n) Yg(e, o, i, t);
            });
          }
        }
        function Yg(t, e, o, i) {
          const n = o.createLoader(i);
          n && Cu(t, e, { uploadId: n.id });
        }
        class $g extends Hc {
          static get requires() {
            return [Dg, Ug, vd];
          }
          static get pluginName() {
            return 'ImageUploadEditing';
          }
          constructor(t) {
            super(t), t.config.define('image', { upload: { types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff'] } });
          }
          init() {
            const t = this.editor,
              e = t.model.document,
              o = t.model.schema,
              i = t.conversion,
              n = t.plugins.get(Dg),
              r = Ig(t.config.get('image.upload.types'));
            o.extend('image', { allowAttributes: ['uploadId', 'uploadStatus'] }),
              t.commands.add('imageUpload', new Gg(t)),
              i.for('upcast').attributeToAttribute({ view: { name: 'img', key: 'uploadId' }, model: 'uploadId' }),
              this.listenTo(t.editing.view.document, 'clipboardInput', (e, o) => {
                if (((i = o.dataTransfer), Array.from(i.types).includes('text/html') && '' !== i.getData('text/html')))
                  return;
                var i;
                const n = Array.from(o.dataTransfer.files).filter(t => !!t && r.test(t.type)),
                  s = o.targetRanges.map(e => t.editing.mapper.toModelRange(e));
                t.model.change(o => {
                  o.setSelection(s),
                    n.length &&
                      (e.stop(),
                      t.model.enqueueChange('default', () => {
                        t.execute('imageUpload', { file: n });
                      }));
                });
              }),
              this.listenTo(t.plugins.get(vd), 'inputTransformation', (e, o) => {
                const i = Array.from(t.editing.view.createRangeIn(o.content))
                  .filter(t => {
                    return (
                      !(!(e = t.item).is('element', 'img') || !e.getAttribute('src')) &&
                      (e.getAttribute('src').match(/^data:image\/\w+;base64,/g) ||
                        e.getAttribute('src').match(/^blob:/g)) &&
                      !t.item.getAttribute('uploadProcessed')
                    );
                    var e;
                  })
                  .map(t => {
                    return {
                      promise:
                        ((e = t.item),
                        new Promise((t, o) => {
                          const i = e.getAttribute('src');
                          fetch(i)
                            .then(t => t.blob())
                            .then(e => {
                              const o = (function (t, e) {
                                  return t.type
                                    ? t.type
                                    : e.match(/data:(image\/\w+);base64/)
                                    ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
                                    : 'image/jpeg';
                                })(e, i),
                                n = o.replace('image/', ''),
                                r = new File([e], 'image.' + n, { type: o });
                              t(r);
                            })
                            .catch(o);
                        })),
                      imageElement: t.item,
                    };
                    var e;
                  });
                if (!i.length) return;
                const r = new qg(t.editing.view.document);
                for (const t of i) {
                  r.setAttribute('uploadProcessed', !0, t.imageElement);
                  const e = n.createLoader(t.promise);
                  e && (r.setAttribute('src', '', t.imageElement), r.setAttribute('uploadId', e.id, t.imageElement));
                }
              }),
              t.editing.view.document.on('dragover', (t, e) => {
                e.preventDefault();
              }),
              e.on('change', () => {
                const o = e.differ.getChanges({ includeChangesInGraveyard: !0 });
                for (const e of o)
                  if ('insert' == e.type && '$text' != e.name) {
                    const o = e.position.nodeAfter,
                      i = '$graveyard' == e.position.root.rootName;
                    for (const e of Qg(t, o)) {
                      const t = e.getAttribute('uploadId');
                      if (!t) continue;
                      const o = n.loaders.get(t);
                      o && (i ? o.abort() : 'idle' == o.status && this._readAndUpload(o, e));
                    }
                  }
              });
          }
          _readAndUpload(t, e) {
            const o = this.editor,
              i = o.model,
              n = o.locale.t,
              r = o.plugins.get(Dg),
              s = o.plugins.get(Ug);
            return (
              i.enqueueChange('transparent', t => {
                t.setAttribute('uploadStatus', 'reading', e);
              }),
              t
                .read()
                .then(() => {
                  const n = t.upload();
                  if (un.isSafari) {
                    const t = Tu(o.editing.mapper.toViewElement(e));
                    o.editing.view.once('render', () => {
                      if (!t.parent) return;
                      const e = o.editing.view.domConverter.mapViewToDom(t.parent);
                      if (!e) return;
                      const i = e.style.display;
                      (e.style.display = 'none'), (e._ckHack = e.offsetHeight), (e.style.display = i);
                    });
                  }
                  return (
                    i.enqueueChange('transparent', t => {
                      t.setAttribute('uploadStatus', 'uploading', e);
                    }),
                    n
                  );
                })
                .then(t => {
                  i.enqueueChange('transparent', o => {
                    o.setAttributes({ uploadStatus: 'complete', src: t.default }, e),
                      this._parseAndSetSrcsetAttributeOnImage(t, e, o);
                  }),
                    a();
                })
                .catch(o => {
                  if ('error' !== t.status && 'aborted' !== t.status) throw o;
                  'error' == t.status && o && s.showWarning(o, { title: n('Upload failed'), namespace: 'upload' }),
                    a(),
                    i.enqueueChange('transparent', t => {
                      t.remove(e);
                    });
                })
            );
            function a() {
              i.enqueueChange('transparent', t => {
                t.removeAttribute('uploadId', e), t.removeAttribute('uploadStatus', e);
              }),
                r.destroyLoader(t);
            }
          }
          _parseAndSetSrcsetAttributeOnImage(t, e, o) {
            let i = 0;
            const n = Object.keys(t)
              .filter(t => {
                const e = parseInt(t, 10);
                if (!isNaN(e)) return (i = Math.max(i, e)), !0;
              })
              .map(e => `${t[e]} ${e}w`)
              .join(', ');
            '' != n && o.setAttribute('srcset', { data: n, width: i }, e);
          }
        }
        function Qg(t, e) {
          return Array.from(t.model.createRangeOn(e))
            .filter(t => t.item.is('image'))
            .map(t => t.item);
        }
        class Kg extends Uc {
          constructor(t) {
            super(t), (this._childCommands = []);
          }
          refresh() {}
          execute(...t) {
            this._getFirstEnabledCommand().execute(t);
          }
          registerChildCommand(t) {
            this._childCommands.push(t), t.on('change:isEnabled', () => this._checkEnabled()), this._checkEnabled();
          }
          _checkEnabled() {
            this.isEnabled = !!this._getFirstEnabledCommand();
          }
          _getFirstEnabledCommand() {
            return this._childCommands.find(t => t.isEnabled);
          }
        }
        class Jg extends Hc {
          static get pluginName() {
            return 'IndentEditing';
          }
          init() {
            const t = this.editor;
            t.commands.add('indent', new Kg(t)), t.commands.add('outdent', new Kg(t));
          }
        }
        var Zg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95L5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
          Xg =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
        class tm extends Hc {
          static get pluginName() {
            return 'IndentUI';
          }
          init() {
            const t = this.editor,
              e = t.locale,
              o = t.t,
              i = 'ltr' == e.uiLanguageDirection ? Zg : Xg,
              n = 'ltr' == e.uiLanguageDirection ? Xg : Zg;
            this._defineButton('indent', o('Increase indent'), i),
              this._defineButton('outdent', o('Decrease indent'), n);
          }
          _defineButton(t, e, o) {
            const i = this.editor;
            i.ui.componentFactory.add(t, n => {
              const r = i.commands.get(t),
                s = new Ac(n);
              return (
                s.set({ label: e, icon: o, tooltip: !0 }),
                s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled'),
                this.listenTo(s, 'execute', () => {
                  i.execute(t), i.editing.view.focus();
                }),
                s
              );
            });
          }
        }
        class em extends Uc {
          constructor(t, e) {
            super(t), (this._indentBehavior = e);
          }
          refresh() {
            const t = this.editor.model,
              e = Gc(t.document.selection.getSelectedBlocks());
            e && t.schema.checkAttribute(e, 'blockIndent')
              ? (this.isEnabled = this._indentBehavior.checkEnabled(e.getAttribute('blockIndent')))
              : (this.isEnabled = !1);
          }
          execute() {
            const t = this.editor.model,
              e = (function (t) {
                const e = t.document.selection,
                  o = t.schema;
                return Array.from(e.getSelectedBlocks()).filter(t => o.checkAttribute(t, 'blockIndent'));
              })(t);
            t.change(t => {
              for (const o of e) {
                const e = o.getAttribute('blockIndent'),
                  i = this._indentBehavior.getNextIndent(e);
                i ? t.setAttribute('blockIndent', i, o) : t.removeAttribute('blockIndent', o);
              }
            });
          }
        }
        class om {
          constructor(t) {
            (this.isForward = 'forward' === t.direction), (this.offset = t.offset), (this.unit = t.unit);
          }
          checkEnabled(t) {
            const e = parseFloat(t || 0);
            return this.isForward || e > 0;
          }
          getNextIndent(t) {
            const e = parseFloat(t || 0);
            if (!(!t || t.endsWith(this.unit))) return this.isForward ? this.offset + this.unit : void 0;
            const o = e + (this.isForward ? this.offset : -this.offset);
            return o > 0 ? o + this.unit : void 0;
          }
        }
        class im {
          constructor(t) {
            (this.isForward = 'forward' === t.direction), (this.classes = t.classes);
          }
          checkEnabled(t) {
            const e = this.classes.indexOf(t);
            return this.isForward ? e < this.classes.length - 1 : e >= 0;
          }
          getNextIndent(t) {
            const e = this.classes.indexOf(t),
              o = this.isForward ? 1 : -1;
            return this.classes[e + o];
          }
        }
        const nm = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i,
          rm = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i,
          sm = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
          am = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i,
          lm = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
          cm = new Set([
            'black',
            'silver',
            'gray',
            'white',
            'maroon',
            'red',
            'purple',
            'fuchsia',
            'green',
            'lime',
            'olive',
            'yellow',
            'navy',
            'blue',
            'teal',
            'aqua',
            'orange',
            'aliceblue',
            'antiquewhite',
            'aquamarine',
            'azure',
            'beige',
            'bisque',
            'blanchedalmond',
            'blueviolet',
            'brown',
            'burlywood',
            'cadetblue',
            'chartreuse',
            'chocolate',
            'coral',
            'cornflowerblue',
            'cornsilk',
            'crimson',
            'cyan',
            'darkblue',
            'darkcyan',
            'darkgoldenrod',
            'darkgray',
            'darkgreen',
            'darkgrey',
            'darkkhaki',
            'darkmagenta',
            'darkolivegreen',
            'darkorange',
            'darkorchid',
            'darkred',
            'darksalmon',
            'darkseagreen',
            'darkslateblue',
            'darkslategray',
            'darkslategrey',
            'darkturquoise',
            'darkviolet',
            'deeppink',
            'deepskyblue',
            'dimgray',
            'dimgrey',
            'dodgerblue',
            'firebrick',
            'floralwhite',
            'forestgreen',
            'gainsboro',
            'ghostwhite',
            'gold',
            'goldenrod',
            'greenyellow',
            'grey',
            'honeydew',
            'hotpink',
            'indianred',
            'indigo',
            'ivory',
            'khaki',
            'lavender',
            'lavenderblush',
            'lawngreen',
            'lemonchiffon',
            'lightblue',
            'lightcoral',
            'lightcyan',
            'lightgoldenrodyellow',
            'lightgray',
            'lightgreen',
            'lightgrey',
            'lightpink',
            'lightsalmon',
            'lightseagreen',
            'lightskyblue',
            'lightslategray',
            'lightslategrey',
            'lightsteelblue',
            'lightyellow',
            'limegreen',
            'linen',
            'magenta',
            'mediumaquamarine',
            'mediumblue',
            'mediumorchid',
            'mediumpurple',
            'mediumseagreen',
            'mediumslateblue',
            'mediumspringgreen',
            'mediumturquoise',
            'mediumvioletred',
            'midnightblue',
            'mintcream',
            'mistyrose',
            'moccasin',
            'navajowhite',
            'oldlace',
            'olivedrab',
            'orangered',
            'orchid',
            'palegoldenrod',
            'palegreen',
            'paleturquoise',
            'palevioletred',
            'papayawhip',
            'peachpuff',
            'peru',
            'pink',
            'plum',
            'powderblue',
            'rosybrown',
            'royalblue',
            'saddlebrown',
            'salmon',
            'sandybrown',
            'seagreen',
            'seashell',
            'sienna',
            'skyblue',
            'slateblue',
            'slategray',
            'slategrey',
            'snow',
            'springgreen',
            'steelblue',
            'tan',
            'thistle',
            'tomato',
            'turquoise',
            'violet',
            'wheat',
            'whitesmoke',
            'yellowgreen',
            'rebeccapurple',
            'currentcolor',
            'transparent',
          ]);
        function dm(t) {
          return t.startsWith('#')
            ? nm.test(t)
            : t.startsWith('rgb')
            ? rm.test(t) || sm.test(t)
            : t.startsWith('hsl')
            ? am.test(t) || lm.test(t)
            : cm.has(t.toLowerCase());
        }
        const hm = ['none', 'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];
        function um(t) {
          return hm.includes(t);
        }
        const gm = /^([+-]?[0-9]*[.]?[0-9]+(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
        function mm(t) {
          return gm.test(t);
        }
        const fm = /^[+-]?[0-9]*[.]?[0-9]+%$/;
        const pm = ['repeat-x', 'repeat-y', 'repeat', 'space', 'round', 'no-repeat'];
        const bm = ['center', 'top', 'bottom', 'left', 'right'];
        function wm(t) {
          return bm.includes(t);
        }
        const km = ['fixed', 'scroll', 'local'];
        function _m(t) {
          return km.includes(t);
        }
        const vm = /^url\(/;
        function ym(t) {
          return vm.test(t);
        }
        function xm(t = '') {
          if ('' === t) return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
          const e = Sm(t),
            o = e[0],
            i = e[2] || o,
            n = e[1] || o;
          return { top: o, bottom: i, right: n, left: e[3] || n };
        }
        function Cm(t) {
          return e => {
            const { top: o, right: i, bottom: n, left: r } = e,
              s = [];
            return (
              [o, i, r, n].every(t => !!t)
                ? s.push([t, Am(e)])
                : (o && s.push([t + '-top', o]),
                  i && s.push([t + '-right', i]),
                  n && s.push([t + '-bottom', n]),
                  r && s.push([t + '-left', r])),
              s
            );
          };
        }
        function Am({ top: t, right: e, bottom: o, left: i }) {
          const n = [];
          return (
            i !== e ? n.push(t, e, o, i) : o !== t ? n.push(t, e, o) : e !== t ? n.push(t, e) : n.push(t), n.join(' ')
          );
        }
        function Tm(t) {
          return e => ({ path: t, value: xm(e) });
        }
        function Sm(t) {
          return t
            .replace(/, /g, ',')
            .split(' ')
            .map(t => t.replace(/,/g, ', '));
        }
        function Pm(t) {
          t.setNormalizer('margin', Tm('margin')),
            t.setNormalizer('margin-top', t => ({ path: 'margin.top', value: t })),
            t.setNormalizer('margin-right', t => ({ path: 'margin.right', value: t })),
            t.setNormalizer('margin-bottom', t => ({ path: 'margin.bottom', value: t })),
            t.setNormalizer('margin-left', t => ({ path: 'margin.left', value: t })),
            t.setReducer('margin', Cm('margin')),
            t.setStyleRelation('margin', ['margin-top', 'margin-right', 'margin-bottom', 'margin-left']);
        }
        class Em extends Hc {
          static get pluginName() {
            return 'ItalicEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'italic' }),
              t.model.schema.setAttributeProperties('italic', { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: 'italic',
                view: 'i',
                upcastAlso: ['em', { styles: { 'font-style': 'italic' } }],
              }),
              t.commands.add('italic', new fd(t, 'italic')),
              t.keystrokes.set('CTRL+I', 'italic');
          }
        }
        class Mm extends Hc {
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('italic', o => {
              const i = t.commands.get('italic'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Italic'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                  keystroke: 'CTRL+I',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                n.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  t.execute('italic'), t.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        function Im(t, e, o) {
          return o.createRange(Nm(t, e, !0, o), Nm(t, e, !1, o));
        }
        function Nm(t, e, o, i) {
          let n = t.textNode || (o ? t.nodeBefore : t.nodeAfter),
            r = null;
          for (; n && n.getAttribute('linkHref') == e; ) (r = n), (n = o ? n.previousSibling : n.nextSibling);
          return r ? i.createPositionAt(r, o ? 'before' : 'after') : t;
        }
        class Rm extends Uc {
          constructor(t) {
            super(t), (this.manualDecorators = new Co());
          }
          restoreManualDecoratorStates() {
            for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id);
          }
          refresh() {
            const t = this.editor.model,
              e = t.document;
            this.value = e.selection.getAttribute('linkHref');
            for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id);
            this.isEnabled = t.schema.checkAttributeInSelection(e.selection, 'linkHref');
          }
          execute(t, e = {}) {
            const o = this.editor.model,
              i = o.document.selection,
              n = [],
              r = [];
            for (const t in e) e[t] ? n.push(t) : r.push(t);
            o.change(e => {
              if (i.isCollapsed) {
                const s = i.getFirstPosition();
                if (i.hasAttribute('linkHref')) {
                  const a = Im(s, i.getAttribute('linkHref'), o);
                  e.setAttribute('linkHref', t, a),
                    n.forEach(t => {
                      e.setAttribute(t, !0, a);
                    }),
                    r.forEach(t => {
                      e.removeAttribute(t, a);
                    }),
                    e.setSelection(a);
                } else if ('' !== t) {
                  const r = Do(i.getAttributes());
                  r.set('linkHref', t),
                    n.forEach(t => {
                      r.set(t, !0);
                    });
                  const a = e.createText(t, r);
                  o.insertContent(a, s), e.setSelection(e.createRangeOn(a));
                }
              } else {
                const s = o.schema.getValidRanges(i.getRanges(), 'linkHref');
                for (const o of s)
                  e.setAttribute('linkHref', t, o),
                    n.forEach(t => {
                      e.setAttribute(t, !0, o);
                    }),
                    r.forEach(t => {
                      e.removeAttribute(t, o);
                    });
              }
            });
          }
          _getDecoratorStateFromModel(t) {
            return this.editor.model.document.selection.getAttribute(t);
          }
        }
        class Om extends Uc {
          refresh() {
            this.isEnabled = this.editor.model.document.selection.hasAttribute('linkHref');
          }
          execute() {
            const t = this.editor,
              e = this.editor.model,
              o = e.document.selection,
              i = t.commands.get('link');
            e.change(t => {
              const n = o.isCollapsed ? [Im(o.getFirstPosition(), o.getAttribute('linkHref'), e)] : o.getRanges();
              for (const e of n)
                if ((t.removeAttribute('linkHref', e), i))
                  for (const o of i.manualDecorators) t.removeAttribute(o.id, e);
            });
          }
        }
        var Vm = function (t, e, o) {
            var i = t.length;
            return (o = void 0 === o ? i : o), !e && o >= i ? t : ii(t, e, o);
          },
          Dm = RegExp('[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]');
        var zm = function (t) {
          return Dm.test(t);
        };
        var Lm = function (t) {
            return t.split('');
          },
          jm = '[\\ud800-\\udfff]',
          Bm = '[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]',
          Fm = '\\ud83c[\\udffb-\\udfff]',
          Hm = '[^\\ud800-\\udfff]',
          Wm = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          Um = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          qm = '(?:' + Bm + '|' + Fm + ')' + '?',
          Gm = '[\\ufe0e\\ufe0f]?' + qm + ('(?:\\u200d(?:' + [Hm, Wm, Um].join('|') + ')[\\ufe0e\\ufe0f]?' + qm + ')*'),
          Ym = '(?:' + [Hm + Bm + '?', Bm, Wm, Um, jm].join('|') + ')',
          $m = RegExp(Fm + '(?=' + Fm + ')|' + Ym + Gm, 'g');
        var Qm = function (t) {
          return t.match($m) || [];
        };
        var Km = function (t) {
          return zm(t) ? Qm(t) : Lm(t);
        };
        var Jm = (function (t) {
          return function (e) {
            e = Zo(e);
            var o = zm(e) ? Km(e) : void 0,
              i = o ? o[0] : e.charAt(0),
              n = o ? Vm(o, 1).join('') : e.slice(1);
            return i[t]() + n;
          };
        })('toUpperCase');
        const Zm = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
          Xm = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        function tf(t, e) {
          const o = e.createAttributeElement('a', { href: t }, { priority: 5 });
          return e.setCustomProperty('link', !0, o), o;
        }
        function ef(t) {
          return (function (t) {
            return t.replace(Zm, '').match(Xm);
          })((t = String(t)))
            ? t
            : '#';
        }
        class of {
          constructor() {
            this._definitions = new Set();
          }
          get length() {
            return this._definitions.size;
          }
          add(t) {
            Array.isArray(t) ? t.forEach(t => this._definitions.add(t)) : this._definitions.add(t);
          }
          getDispatcher() {
            return t => {
              t.on(
                'attribute:linkHref',
                (t, e, o) => {
                  if (!o.consumable.test(e.item, 'attribute:linkHref')) return;
                  const i = o.writer,
                    n = i.document.selection;
                  for (const t of this._definitions) {
                    const r = i.createAttributeElement('a', t.attributes, { priority: 5 });
                    i.setCustomProperty('link', !0, r),
                      t.callback(e.attributeNewValue)
                        ? e.item.is('selection')
                          ? i.wrap(n.getFirstRange(), r)
                          : i.wrap(o.mapper.toViewRange(e.range), r)
                        : i.unwrap(o.mapper.toViewRange(e.range), r);
                  }
                },
                { priority: 'high' }
              );
            };
          }
        }
        class nf {
          constructor({ id: t, label: e, attributes: o, defaultValue: i }) {
            (this.id = t), this.set('value'), (this.defaultValue = i), (this.label = e), (this.attributes = o);
          }
        }
        xo(nf, Hi);
        class rf {
          constructor(t, e, o) {
            (this.model = t),
              (this.attribute = o),
              (this._modelSelection = t.document.selection),
              (this._overrideUid = null),
              (this._isNextGravityRestorationSkipped = !1),
              e.listenTo(this._modelSelection, 'change:range', (t, e) => {
                this._isNextGravityRestorationSkipped
                  ? (this._isNextGravityRestorationSkipped = !1)
                  : this._isGravityOverridden &&
                    ((!e.directChange && sf(this._modelSelection.getFirstPosition(), o)) || this._restoreGravity());
              });
          }
          handleForwardMovement(t, e) {
            const o = this.attribute;
            if (!(this._isGravityOverridden || (t.isAtStart && this._hasSelectionAttribute)))
              return cf(t, o) && this._hasSelectionAttribute
                ? (this._preventCaretMovement(e), this._removeSelectionAttribute(), !0)
                : af(t, o) || (lf(t, o) && this._hasSelectionAttribute)
                ? (this._preventCaretMovement(e), this._overrideGravity(), !0)
                : void 0;
          }
          handleBackwardMovement(t, e) {
            const o = this.attribute;
            return this._isGravityOverridden
              ? cf(t, o) && this._hasSelectionAttribute
                ? (this._preventCaretMovement(e), this._restoreGravity(), this._removeSelectionAttribute(), !0)
                : (this._preventCaretMovement(e),
                  this._restoreGravity(),
                  t.isAtStart && this._removeSelectionAttribute(),
                  !0)
              : cf(t, o) && !this._hasSelectionAttribute
              ? (this._preventCaretMovement(e), this._setSelectionAttributeFromTheNodeBefore(t), !0)
              : t.isAtEnd && lf(t, o)
              ? this._hasSelectionAttribute
                ? void (df(t, o) && (this._skipNextAutomaticGravityRestoration(), this._overrideGravity()))
                : (this._preventCaretMovement(e), this._setSelectionAttributeFromTheNodeBefore(t), !0)
              : t.isAtStart
              ? this._hasSelectionAttribute
                ? (this._removeSelectionAttribute(), this._preventCaretMovement(e), !0)
                : void 0
              : void (df(t, o) && (this._skipNextAutomaticGravityRestoration(), this._overrideGravity()));
          }
          get _isGravityOverridden() {
            return !!this._overrideUid;
          }
          get _hasSelectionAttribute() {
            return this._modelSelection.hasAttribute(this.attribute);
          }
          _overrideGravity() {
            this._overrideUid = this.model.change(t => t.overrideSelectionGravity());
          }
          _restoreGravity() {
            this.model.change(t => {
              t.restoreSelectionGravity(this._overrideUid), (this._overrideUid = null);
            });
          }
          _preventCaretMovement(t) {
            t.preventDefault();
          }
          _removeSelectionAttribute() {
            this.model.change(t => {
              t.removeSelectionAttribute(this.attribute);
            });
          }
          _setSelectionAttributeFromTheNodeBefore(t) {
            const e = this.attribute;
            this.model.change(o => {
              o.setSelectionAttribute(this.attribute, t.nodeBefore.getAttribute(e));
            });
          }
          _skipNextAutomaticGravityRestoration() {
            this._isNextGravityRestorationSkipped = !0;
          }
        }
        function sf(t, e) {
          return af(t, e) || lf(t, e);
        }
        function af(t, e) {
          const { nodeBefore: o, nodeAfter: i } = t,
            n = !!o && o.hasAttribute(e);
          return !!i && i.hasAttribute(e) && (!n || o.getAttribute(e) !== i.getAttribute(e));
        }
        function lf(t, e) {
          const { nodeBefore: o, nodeAfter: i } = t,
            n = !!o && o.hasAttribute(e),
            r = !!i && i.hasAttribute(e);
          return n && (!r || o.getAttribute(e) !== i.getAttribute(e));
        }
        function cf(t, e) {
          const { nodeBefore: o, nodeAfter: i } = t,
            n = !!o && o.hasAttribute(e);
          if (!!i && i.hasAttribute(e) && n) return i.getAttribute(e) !== o.getAttribute(e);
        }
        function df(t, e) {
          return sf(t.getShiftedBy(-1), e);
        }
        o(86);
        const hf = /^(https?:)?\/\//;
        class uf extends Hc {
          static get pluginName() {
            return 'LinkEditing';
          }
          constructor(t) {
            super(t), t.config.define('link', { addTargetToExternalLinks: !1 });
          }
          init() {
            const t = this.editor,
              e = t.locale;
            t.model.schema.extend('$text', { allowAttributes: 'linkHref' }),
              t.conversion.for('dataDowncast').attributeToElement({ model: 'linkHref', view: tf }),
              t.conversion
                .for('editingDowncast')
                .attributeToElement({ model: 'linkHref', view: (t, e) => tf(ef(t), e) }),
              t.conversion.for('upcast').elementToAttribute({
                view: { name: 'a', attributes: { href: !0 } },
                model: { key: 'linkHref', value: t => t.getAttribute('href') },
              }),
              t.commands.add('link', new Rm(t)),
              t.commands.add('unlink', new Om(t));
            const o = (function (t, e) {
              const o = { 'Open in a new tab': t('Open in a new tab'), Downloadable: t('Downloadable') };
              return e.forEach(t => (t.label && o[t.label] && (t.label = o[t.label]), t)), e;
            })(
              t.t,
              (function (t) {
                const e = [];
                if (t)
                  for (const [o, i] of Object.entries(t)) {
                    const t = Object.assign({}, i, { id: 'link' + Jm(o) });
                    e.push(t);
                  }
                return e;
              })(t.config.get('link.decorators'))
            );
            this._enableAutomaticDecorators(o.filter(t => 'automatic' === t.mode)),
              this._enableManualDecorators(o.filter(t => 'manual' === t.mode)),
              (function ({ view: t, model: e, emitter: o, attribute: i, locale: n }) {
                const r = new rf(e, o, i),
                  s = e.document.selection;
                o.listenTo(
                  t.document,
                  'keydown',
                  (t, e) => {
                    if (!s.isCollapsed) return;
                    if (e.shiftKey || e.altKey || e.ctrlKey) return;
                    const o = e.keyCode == fn.arrowright,
                      i = e.keyCode == fn.arrowleft;
                    if (!o && !i) return;
                    const a = s.getFirstPosition(),
                      l = n.contentLanguageDirection;
                    let c;
                    (c =
                      ('ltr' === l && o) || ('rtl' === l && i)
                        ? r.handleForwardMovement(a, e)
                        : r.handleBackwardMovement(a, e)),
                      c && t.stop();
                  },
                  { priority: ho.get('high') + 1 }
                );
              })({ view: t.editing.view, model: t.model, emitter: this, attribute: 'linkHref', locale: e }),
              this._setupLinkHighlight(),
              this._enableInsertContentSelectionAttributesFixer();
          }
          _enableAutomaticDecorators(t) {
            const e = this.editor,
              o = new of();
            e.config.get('link.addTargetToExternalLinks') &&
              o.add({
                id: 'linkIsExternal',
                mode: 'automatic',
                callback: t => hf.test(t),
                attributes: { target: '_blank', rel: 'noopener noreferrer' },
              }),
              o.add(t),
              o.length && e.conversion.for('downcast').add(o.getDispatcher());
          }
          _enableManualDecorators(t) {
            if (!t.length) return;
            const e = this.editor,
              o = e.commands.get('link').manualDecorators;
            t.forEach(t => {
              e.model.schema.extend('$text', { allowAttributes: t.id }),
                o.add(new nf(t)),
                e.conversion.for('downcast').attributeToElement({
                  model: t.id,
                  view: (e, i) => {
                    if (e) {
                      const e = o.get(t.id).attributes,
                        n = i.createAttributeElement('a', e, { priority: 5 });
                      return i.setCustomProperty('link', !0, n), n;
                    }
                  },
                }),
                e.conversion.for('upcast').elementToAttribute({
                  view: { name: 'a', attributes: o.get(t.id).attributes },
                  model: { key: t.id },
                });
            });
          }
          _setupLinkHighlight() {
            const t = this.editor,
              e = t.editing.view,
              o = new Set();
            e.document.registerPostFixer(e => {
              const i = t.model.document.selection;
              let n = !1;
              if (i.hasAttribute('linkHref')) {
                const r = Im(i.getFirstPosition(), i.getAttribute('linkHref'), t.model),
                  s = t.editing.mapper.toViewRange(r);
                for (const t of s.getItems())
                  t.is('a') &&
                    !t.hasClass('ck-link_selected') &&
                    (e.addClass('ck-link_selected', t), o.add(t), (n = !0));
              }
              return n;
            }),
              t.conversion.for('editingDowncast').add(t => {
                function i() {
                  e.change(t => {
                    for (const e of o.values()) t.removeClass('ck-link_selected', e), o.delete(e);
                  });
                }
                t.on('insert', i, { priority: 'highest' }),
                  t.on('remove', i, { priority: 'highest' }),
                  t.on('attribute', i, { priority: 'highest' }),
                  t.on('selection', i, { priority: 'highest' });
              });
          }
          _enableInsertContentSelectionAttributesFixer() {
            const t = this.editor.model,
              e = t.document.selection;
            t.on(
              'insertContent',
              () => {
                const o = e.anchor.nodeBefore,
                  i = e.anchor.nodeAfter;
                e.hasAttribute('linkHref') &&
                  o &&
                  o.hasAttribute('linkHref') &&
                  ((i && i.hasAttribute('linkHref')) ||
                    t.change(e => {
                      [...t.document.selection.getAttributeKeys()]
                        .filter(t => t.startsWith('link'))
                        .forEach(t => e.removeSelectionAttribute(t));
                    }));
              },
              { priority: 'low' }
            );
          }
        }
        class gf extends Nr {
          constructor(t) {
            super(t), (this.domEventType = 'click');
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        o(88);
        class mf extends sc {
          constructor(t, e) {
            super(t);
            const o = t.t;
            (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this.urlInputView = this._createUrlInput()),
              (this.saveButtonView = this._createButton(o('Save'), qu, 'ck-button-save')),
              (this.saveButtonView.type = 'submit'),
              (this.cancelButtonView = this._createButton(o('Cancel'), Gu, 'ck-button-cancel', 'cancel')),
              (this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e)),
              (this.children = this._createFormChildren(e.manualDecorators)),
              (this._focusables = new Bl()),
              (this._focusCycler = new uc({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              }));
            const i = ['ck', 'ck-link-form'];
            e.manualDecorators.length && i.push('ck-link-form_layout-vertical'),
              this.setTemplate({ tag: 'form', attributes: { class: i, tabindex: '-1' }, children: this.children });
          }
          getDecoratorSwitchesState() {
            return Array.from(this._manualDecoratorSwitches).reduce((t, e) => ((t[e.name] = e.isOn), t), {});
          }
          render() {
            super.render(), Uu({ view: this });
            [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach(
              t => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              }
            ),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createUrlInput() {
            const t = this.locale.t,
              e = new Bu(this.locale, Hu);
            return (e.label = t('Link URL')), (e.fieldView.placeholder = 'https://example.com'), e;
          }
          _createButton(t, e, o, i) {
            const n = new Ac(this.locale);
            return (
              n.set({ label: t, icon: e, tooltip: !0 }),
              n.extendTemplate({ attributes: { class: o } }),
              i && n.delegate('execute').to(this, i),
              n
            );
          }
          _createManualDecoratorSwitches(t) {
            const e = this.createCollection();
            for (const o of t.manualDecorators) {
              const i = new Ic(this.locale);
              i.set({ name: o.id, label: o.label, withText: !0 }),
                i.bind('isOn').toMany([o, t], 'value', (t, e) => (void 0 === e && void 0 === t ? o.defaultValue : t)),
                i.on('execute', () => {
                  o.set('value', !i.isOn);
                }),
                e.add(i);
            }
            return e;
          }
          _createFormChildren(t) {
            const e = this.createCollection();
            if ((e.add(this.urlInputView), t.length)) {
              const t = new sc();
              t.setTemplate({
                tag: 'ul',
                children: this._manualDecoratorSwitches.map(t => ({
                  tag: 'li',
                  children: [t],
                  attributes: { class: ['ck', 'ck-list__item'] },
                })),
                attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
              }),
                e.add(t);
            }
            return e.add(this.saveButtonView), e.add(this.cancelButtonView), e;
          }
        }
        o(90);
        class ff extends sc {
          constructor(t) {
            super(t);
            const e = t.t;
            (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this.previewButtonView = this._createPreviewButton()),
              (this.unlinkButtonView = this._createButton(
                e('Unlink'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>',
                'unlink'
              )),
              (this.editButtonView = this._createButton(
                e('Edit link'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>',
                'edit'
              )),
              this.set('href'),
              (this._focusables = new Bl()),
              (this._focusCycler = new uc({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-link-actions'], tabindex: '-1' },
                children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView],
              });
          }
          render() {
            super.render();
            [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach(t => {
              this._focusables.add(t), this.focusTracker.add(t.element);
            }),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createButton(t, e, o) {
            const i = new Ac(this.locale);
            return i.set({ label: t, icon: e, tooltip: !0 }), i.delegate('execute').to(this, o), i;
          }
          _createPreviewButton() {
            const t = new Ac(this.locale),
              e = this.bindTemplate,
              o = this.t;
            return (
              t.set({ withText: !0, tooltip: o('Open link in new tab') }),
              t.extendTemplate({
                attributes: {
                  class: ['ck', 'ck-link-actions__preview'],
                  href: e.to('href', t => t && ef(t)),
                  target: '_blank',
                  rel: 'noopener noreferrer',
                },
              }),
              t.bind('label').to(this, 'href', t => t || o('This link has no URL')),
              t.bind('isEnabled').to(this, 'href', t => !!t),
              (t.template.tag = 'a'),
              (t.template.eventListeners = {}),
              t
            );
          }
        }
        class pf extends Hc {
          static get requires() {
            return [Qu];
          }
          static get pluginName() {
            return 'LinkUI';
          }
          init() {
            const t = this.editor;
            t.editing.view.addObserver(gf),
              (this.actionsView = this._createActionsView()),
              (this.formView = this._createFormView()),
              (this._balloon = t.plugins.get(Qu)),
              this._createToolbarLinkButton(),
              this._enableUserBalloonInteractions();
          }
          destroy() {
            super.destroy(), this.formView.destroy();
          }
          _createActionsView() {
            const t = this.editor,
              e = new ff(t.locale),
              o = t.commands.get('link'),
              i = t.commands.get('unlink');
            return (
              e.bind('href').to(o, 'value'),
              e.editButtonView.bind('isEnabled').to(o),
              e.unlinkButtonView.bind('isEnabled').to(i),
              this.listenTo(e, 'edit', () => {
                this._addFormView();
              }),
              this.listenTo(e, 'unlink', () => {
                t.execute('unlink'), this._hideUI();
              }),
              e.keystrokes.set('Esc', (t, e) => {
                this._hideUI(), e();
              }),
              e.keystrokes.set('Ctrl+K', (t, e) => {
                this._addFormView(), e();
              }),
              e
            );
          }
          _createFormView() {
            const t = this.editor,
              e = t.commands.get('link'),
              o = new mf(t.locale, e);
            return (
              o.urlInputView.fieldView.bind('value').to(e, 'value'),
              o.urlInputView.bind('isReadOnly').to(e, 'isEnabled', t => !t),
              o.saveButtonView.bind('isEnabled').to(e),
              this.listenTo(o, 'submit', () => {
                t.execute('link', o.urlInputView.fieldView.element.value, o.getDecoratorSwitchesState()),
                  this._closeFormView();
              }),
              this.listenTo(o, 'cancel', () => {
                this._closeFormView();
              }),
              o.keystrokes.set('Esc', (t, e) => {
                this._closeFormView(), e();
              }),
              o
            );
          }
          _createToolbarLinkButton() {
            const t = this.editor,
              e = t.commands.get('link'),
              o = t.t;
            t.keystrokes.set('Ctrl+K', (t, e) => {
              e(), this._showUI(!0);
            }),
              t.ui.componentFactory.add('link', t => {
                const i = new Ac(t);
                return (
                  (i.isEnabled = !0),
                  (i.label = o('Link')),
                  (i.icon =
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'),
                  (i.keystroke = 'Ctrl+K'),
                  (i.tooltip = !0),
                  (i.isToggleable = !0),
                  i.bind('isEnabled').to(e, 'isEnabled'),
                  i.bind('isOn').to(e, 'value', t => !!t),
                  this.listenTo(i, 'execute', () => this._showUI(!0)),
                  i
                );
              });
          }
          _enableUserBalloonInteractions() {
            const t = this.editor.editing.view.document;
            this.listenTo(t, 'click', () => {
              this._getSelectedLinkElement() && this._showUI();
            }),
              this.editor.keystrokes.set(
                'Tab',
                (t, e) => {
                  this._areActionsVisible &&
                    !this.actionsView.focusTracker.isFocused &&
                    (this.actionsView.focus(), e());
                },
                { priority: 'high' }
              ),
              this.editor.keystrokes.set('Esc', (t, e) => {
                this._isUIVisible && (this._hideUI(), e());
              }),
              Nc({
                emitter: this.formView,
                activator: () => this._isUIInPanel,
                contextElements: [this._balloon.view.element],
                callback: () => this._hideUI(),
              });
          }
          _addActionsView() {
            this._areActionsInPanel ||
              this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
          }
          _addFormView() {
            if (this._isFormInPanel) return;
            const t = this.editor.commands.get('link');
            this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }),
              this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(),
              (this.formView.urlInputView.fieldView.element.value = t.value || '');
          }
          _closeFormView() {
            const t = this.editor.commands.get('link');
            t.restoreManualDecoratorStates(), void 0 !== t.value ? this._removeFormView() : this._hideUI();
          }
          _removeFormView() {
            this._isFormInPanel &&
              (this.formView.saveButtonView.focus(),
              this._balloon.remove(this.formView),
              this.editor.editing.view.focus());
          }
          _showUI(t = !1) {
            this._getSelectedLinkElement()
              ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(),
                t && this._balloon.showStack('main'))
              : (this._addActionsView(), t && this._balloon.showStack('main'), this._addFormView()),
              this._startUpdatingUI();
          }
          _hideUI() {
            if (!this._isUIInPanel) return;
            const t = this.editor;
            this.stopListening(t.ui, 'update'),
              this.stopListening(this._balloon, 'change:visibleView'),
              t.editing.view.focus(),
              this._removeFormView(),
              this._balloon.remove(this.actionsView);
          }
          _startUpdatingUI() {
            const t = this.editor,
              e = t.editing.view.document;
            let o = this._getSelectedLinkElement(),
              i = r();
            const n = () => {
              const t = this._getSelectedLinkElement(),
                e = r();
              (o && !t) || (!o && e !== i)
                ? this._hideUI()
                : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()),
                (o = t),
                (i = e);
            };
            function r() {
              return e.selection.focus
                .getAncestors()
                .reverse()
                .find(t => t.is('element'));
            }
            this.listenTo(t.ui, 'update', n), this.listenTo(this._balloon, 'change:visibleView', n);
          }
          get _isFormInPanel() {
            return this._balloon.hasView(this.formView);
          }
          get _areActionsInPanel() {
            return this._balloon.hasView(this.actionsView);
          }
          get _areActionsVisible() {
            return this._balloon.visibleView === this.actionsView;
          }
          get _isUIInPanel() {
            return this._isFormInPanel || this._areActionsInPanel;
          }
          get _isUIVisible() {
            return this._balloon.visibleView == this.formView || this._areActionsVisible;
          }
          _getBalloonPositionData() {
            const t = this.editor.editing.view,
              e = t.document,
              o = this._getSelectedLinkElement();
            return {
              target: o ? t.domConverter.mapViewToDom(o) : t.domConverter.viewRangeToDom(e.selection.getFirstRange()),
            };
          }
          _getSelectedLinkElement() {
            const t = this.editor.editing.view,
              e = t.document.selection;
            if (e.isCollapsed) return bf(e.getFirstPosition());
            {
              const o = e.getFirstRange().getTrimmed(),
                i = bf(o.start),
                n = bf(o.end);
              return i && i == n && t.createRangeIn(i).getTrimmed().isEqual(o) ? i : null;
            }
          }
        }
        function bf(t) {
          return t.getAncestors().find(t => {
            return (e = t).is('attributeElement') && !!e.getCustomProperty('link');
            var e;
          });
        }
        class wf extends Uc {
          constructor(t, e) {
            super(t), (this.type = e);
          }
          refresh() {
            (this.value = this._getValue()), (this.isEnabled = this._checkEnabled());
          }
          execute() {
            const t = this.editor.model,
              e = t.document,
              o = Array.from(e.selection.getSelectedBlocks()).filter(e => _f(e, t.schema)),
              i = !0 === this.value;
            t.change(t => {
              if (i) {
                let e = o[o.length - 1].nextSibling,
                  i = Number.POSITIVE_INFINITY,
                  n = [];
                for (; e && 'listItem' == e.name && 0 !== e.getAttribute('listIndent'); ) {
                  const t = e.getAttribute('listIndent');
                  t < i && (i = t);
                  const o = t - i;
                  n.push({ element: e, listIndent: o }), (e = e.nextSibling);
                }
                n = n.reverse();
                for (const e of n) t.setAttribute('listIndent', e.listIndent, e.element);
              }
              if (!i) {
                let t = Number.POSITIVE_INFINITY;
                for (const e of o)
                  e.is('listItem') && e.getAttribute('listIndent') < t && (t = e.getAttribute('listIndent'));
                (t = 0 === t ? 1 : t), kf(o, !0, t), kf(o, !1, t);
              }
              for (const e of o.reverse())
                i && 'listItem' == e.name
                  ? t.rename(e, 'paragraph')
                  : i || 'listItem' == e.name
                  ? i ||
                    'listItem' != e.name ||
                    e.getAttribute('listType') == this.type ||
                    t.setAttribute('listType', this.type, e)
                  : (t.setAttributes({ listType: this.type, listIndent: 0 }, e), t.rename(e, 'listItem'));
            });
          }
          _getValue() {
            const t = Gc(this.editor.model.document.selection.getSelectedBlocks());
            return !!t && t.is('listItem') && t.getAttribute('listType') == this.type;
          }
          _checkEnabled() {
            if (this.value) return !0;
            const t = this.editor.model.document.selection,
              e = this.editor.model.schema,
              o = Gc(t.getSelectedBlocks());
            return !!o && _f(o, e);
          }
        }
        function kf(t, e, o) {
          const i = e ? t[0] : t[t.length - 1];
          if (i.is('listItem')) {
            let n = i[e ? 'previousSibling' : 'nextSibling'],
              r = i.getAttribute('listIndent');
            for (; n && n.is('listItem') && n.getAttribute('listIndent') >= o; )
              r > n.getAttribute('listIndent') && (r = n.getAttribute('listIndent')),
                n.getAttribute('listIndent') == r && t[e ? 'unshift' : 'push'](n),
                (n = n[e ? 'previousSibling' : 'nextSibling']);
          }
        }
        function _f(t, e) {
          return e.checkChild(t.parent, 'listItem') && !e.isObject(t);
        }
        class vf extends Uc {
          constructor(t, e) {
            super(t), (this._indentBy = 'forward' == e ? 1 : -1);
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t = this.editor.model,
              e = t.document;
            let o = Array.from(e.selection.getSelectedBlocks());
            t.change(t => {
              const e = o[o.length - 1];
              let i = e.nextSibling;
              for (; i && 'listItem' == i.name && i.getAttribute('listIndent') > e.getAttribute('listIndent'); )
                o.push(i), (i = i.nextSibling);
              this._indentBy < 0 && (o = o.reverse());
              for (const e of o) {
                const o = e.getAttribute('listIndent') + this._indentBy;
                o < 0 ? t.rename(e, 'paragraph') : t.setAttribute('listIndent', o, e);
              }
            });
          }
          _checkEnabled() {
            const t = Gc(this.editor.model.document.selection.getSelectedBlocks());
            if (!t || !t.is('listItem')) return !1;
            if (this._indentBy > 0) {
              const e = t.getAttribute('listIndent'),
                o = t.getAttribute('listType');
              let i = t.previousSibling;
              for (; i && i.is('listItem') && i.getAttribute('listIndent') >= e; ) {
                if (i.getAttribute('listIndent') == e) return i.getAttribute('listType') == o;
                i = i.previousSibling;
              }
              return !1;
            }
            return !0;
          }
        }
        function yf(t, e) {
          const o = e.mapper,
            i = e.writer,
            n = 'numbered' == t.getAttribute('listType') ? 'ol' : 'ul',
            r = (function (t) {
              const e = t.createContainerElement('li');
              return (e.getFillerOffset = Pf), e;
            })(i),
            s = i.createContainerElement(n, null);
          return i.insert(i.createPositionAt(s, 0), r), o.bindElements(t, r), r;
        }
        function xf(t, e, o, i) {
          const n = e.parent,
            r = o.mapper,
            s = o.writer;
          let a = r.toViewPosition(i.createPositionBefore(t));
          const l = Tf(t.previousSibling, {
              sameIndent: !0,
              smallerIndent: !0,
              listIndent: t.getAttribute('listIndent'),
            }),
            c = t.previousSibling;
          if (l && l.getAttribute('listIndent') == t.getAttribute('listIndent')) {
            const t = r.toViewElement(l);
            a = s.breakContainer(s.createPositionAfter(t));
          } else
            a =
              c && 'listItem' == c.name
                ? r.toViewPosition(i.createPositionAt(c, 'end'))
                : r.toViewPosition(i.createPositionBefore(t));
          if (((a = Af(a)), s.insert(a, n), c && 'listItem' == c.name)) {
            const t = r.toViewElement(c),
              o = s.createRange(s.createPositionAt(t, 0), a).getWalker({ ignoreElementEnd: !0 });
            for (const t of o)
              if (t.item.is('li')) {
                const i = s.breakContainer(s.createPositionBefore(t.item)),
                  n = t.item.parent,
                  r = s.createPositionAt(e, 'end');
                Cf(s, r.nodeBefore, r.nodeAfter), s.move(s.createRangeOn(n), r), (o.position = i);
              }
          } else {
            const o = n.nextSibling;
            if (o && (o.is('ul') || o.is('ol'))) {
              let i = null;
              for (const e of o.getChildren()) {
                const o = r.toModelElement(e);
                if (!(o && o.getAttribute('listIndent') > t.getAttribute('listIndent'))) break;
                i = e;
              }
              i &&
                (s.breakContainer(s.createPositionAfter(i)),
                s.move(s.createRangeOn(i.parent), s.createPositionAt(e, 'end')));
            }
          }
          Cf(s, n, n.nextSibling), Cf(s, n.previousSibling, n);
        }
        function Cf(t, e, o) {
          return !e ||
            !o ||
            ('ul' != e.name && 'ol' != e.name) ||
            e.name != o.name ||
            e.getAttribute('class') !== o.getAttribute('class')
            ? null
            : t.mergeContainers(t.createPositionAfter(e));
        }
        function Af(t) {
          return t.getLastMatchingPosition(t => t.item.is('uiElement'));
        }
        function Tf(t, e) {
          const o = !!e.sameIndent,
            i = !!e.smallerIndent,
            n = e.listIndent;
          let r = t;
          for (; r && 'listItem' == r.name; ) {
            const t = r.getAttribute('listIndent');
            if ((o && n == t) || (i && n > t)) return r;
            r = r.previousSibling;
          }
          return null;
        }
        function Sf(t, e, o, i) {
          t.ui.componentFactory.add(e, n => {
            const r = t.commands.get(e),
              s = new Ac(n);
            return (
              s.set({ label: o, icon: i, tooltip: !0, isToggleable: !0 }),
              s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled'),
              s.on('execute', () => {
                t.execute(e), t.editing.view.focus();
              }),
              s
            );
          });
        }
        function Pf() {
          const t = !this.isEmpty && ('ul' == this.getChild(0).name || 'ol' == this.getChild(0).name);
          return this.isEmpty || t ? 0 : Di.call(this);
        }
        function Ef(t) {
          return (e, o, i) => {
            const n = i.consumable;
            if (
              !n.test(o.item, 'insert') ||
              !n.test(o.item, 'attribute:listType') ||
              !n.test(o.item, 'attribute:listIndent')
            )
              return;
            n.consume(o.item, 'insert'),
              n.consume(o.item, 'attribute:listType'),
              n.consume(o.item, 'attribute:listIndent');
            const r = o.item;
            xf(r, yf(r, i), i, t);
          };
        }
        function Mf(t, e, o) {
          if (!o.consumable.consume(e.item, 'attribute:listType')) return;
          const i = o.mapper.toViewElement(e.item),
            n = o.writer;
          n.breakContainer(n.createPositionBefore(i)), n.breakContainer(n.createPositionAfter(i));
          const r = i.parent,
            s = 'numbered' == e.attributeNewValue ? 'ol' : 'ul';
          n.rename(s, r);
        }
        function If(t, e, o) {
          const i = o.mapper.toViewElement(e.item).parent,
            n = o.writer;
          Cf(n, i, i.nextSibling), Cf(n, i.previousSibling, i);
          for (const t of e.item.getChildren()) o.consumable.consume(t, 'insert');
        }
        function Nf(t, e, o) {
          if ('listItem' != e.item.name) {
            let t = o.mapper.toViewPosition(e.range.start);
            const i = o.writer,
              n = [];
            for (
              ;
              ('ul' == t.parent.name || 'ol' == t.parent.name) && ((t = i.breakContainer(t)), 'li' == t.parent.name);

            ) {
              const e = t,
                o = i.createPositionAt(t.parent, 'end');
              if (!e.isEqual(o)) {
                const t = i.remove(i.createRange(e, o));
                n.push(t);
              }
              t = i.createPositionAfter(t.parent);
            }
            if (n.length > 0) {
              for (let e = 0; e < n.length; e++) {
                const o = t.nodeBefore;
                if (((t = i.insert(t, n[e]).end), e > 0)) {
                  const e = Cf(i, o, o.nextSibling);
                  e && e.parent == o && t.offset--;
                }
              }
              Cf(i, t.nodeBefore, t.nodeAfter);
            }
          }
        }
        function Rf(t, e, o) {
          const i = o.mapper.toViewPosition(e.position),
            n = i.nodeBefore,
            r = i.nodeAfter;
          Cf(o.writer, n, r);
        }
        function Of(t, e, o) {
          if (o.consumable.consume(e.viewItem, { name: !0 })) {
            const t = o.writer,
              i = t.createElement('listItem'),
              n = (function (t) {
                let e = 0,
                  o = t.parent;
                for (; o; ) {
                  if (o.is('li')) e++;
                  else {
                    const t = o.previousSibling;
                    t && t.is('li') && e++;
                  }
                  o = o.parent;
                }
                return e;
              })(e.viewItem);
            t.setAttribute('listIndent', n, i);
            const r = e.viewItem.parent && 'ol' == e.viewItem.parent.name ? 'numbered' : 'bulleted';
            t.setAttribute('listType', r, i);
            const s = o.splitToAllowedParent(i, e.modelCursor);
            if (!s) return;
            t.insert(i, s.position);
            const a = (function (t, e, o) {
              const { writer: i, schema: n } = o;
              let r = i.createPositionAfter(t);
              for (const s of e)
                if ('ul' == s.name || 'ol' == s.name) r = o.convertItem(s, r).modelCursor;
                else {
                  const e = o.convertItem(s, i.createPositionAt(t, 'end')),
                    a = e.modelRange.start.nodeAfter;
                  a &&
                    a.is('element') &&
                    !n.checkChild(t, a.name) &&
                    ((t = e.modelCursor.parent.is('listItem') ? e.modelCursor.parent : jf(e.modelCursor)),
                    (r = i.createPositionAfter(t)));
                }
              return r;
            })(i, e.viewItem.getChildren(), o);
            (e.modelRange = t.createRange(e.modelCursor, a)),
              s.cursorParent
                ? (e.modelCursor = t.createPositionAt(s.cursorParent, 0))
                : (e.modelCursor = e.modelRange.end);
          }
        }
        function Vf(t, e, o) {
          if (o.consumable.test(e.viewItem, { name: !0 })) {
            const t = Array.from(e.viewItem.getChildren());
            for (const e of t) {
              !(e.is('li') || Ff(e)) && e._remove();
            }
          }
        }
        function Df(t, e, o) {
          if (o.consumable.test(e.viewItem, { name: !0 })) {
            if (0 === e.viewItem.childCount) return;
            const t = [...e.viewItem.getChildren()];
            let o = !1,
              i = !0;
            for (const e of t)
              o && !Ff(e) && e._remove(),
                e.is('text')
                  ? (i && (e._data = e.data.replace(/^\s+/, '')),
                    (e.nextSibling && !Ff(e.nextSibling)) || (e._data = e.data.replace(/\s+$/, '')))
                  : Ff(e) && (o = !0),
                (i = !1);
          }
        }
        function zf(t) {
          return (e, o) => {
            if (o.isPhantom) return;
            const i = o.modelPosition.nodeBefore;
            if (i && i.is('listItem')) {
              const e = o.mapper.toViewElement(i),
                n = e.getAncestors().find(Ff),
                r = t.createPositionAt(e, 0).getWalker();
              for (const t of r) {
                if ('elementStart' == t.type && t.item.is('li')) {
                  o.viewPosition = t.previousPosition;
                  break;
                }
                if ('elementEnd' == t.type && t.item == n) {
                  o.viewPosition = t.nextPosition;
                  break;
                }
              }
            }
          };
        }
        function Lf(t, [e, o]) {
          let i,
            n = e.is('documentFragment') ? e.getChild(0) : e;
          if (((i = o ? this.createSelection(o) : this.document.selection), n && n.is('listItem'))) {
            const t = i.getFirstPosition();
            let e = null;
            if (
              (t.parent.is('listItem')
                ? (e = t.parent)
                : t.nodeBefore && t.nodeBefore.is('listItem') && (e = t.nodeBefore),
              e)
            ) {
              const t = e.getAttribute('listIndent');
              if (t > 0)
                for (; n && n.is('listItem'); )
                  n._setAttribute('listIndent', n.getAttribute('listIndent') + t), (n = n.nextSibling);
            }
          }
        }
        function jf(t) {
          const e = new bs({ startPosition: t });
          let o;
          do {
            o = e.next();
          } while (!o.value.item.is('listItem'));
          return o.value.item;
        }
        function Bf(t, e, o, i, n, r) {
          const s = Tf(e.nodeBefore, { sameIndent: !0, smallerIndent: !0, listIndent: t, foo: 'b' }),
            a = n.mapper,
            l = n.writer,
            c = s ? s.getAttribute('listIndent') : null;
          let d;
          if (s)
            if (c == t) {
              const t = a.toViewElement(s).parent;
              d = l.createPositionAfter(t);
            } else {
              const t = r.createPositionAt(s, 'end');
              d = a.toViewPosition(t);
            }
          else d = o;
          d = Af(d);
          for (const t of [...i.getChildren()])
            Ff(t) && ((d = l.move(l.createRangeOn(t), d).end), Cf(l, t, t.nextSibling), Cf(l, t.previousSibling, t));
        }
        function Ff(t) {
          return t.is('ol') || t.is('ul');
        }
        class Hf extends Hc {
          static get pluginName() {
            return 'ListEditing';
          }
          static get requires() {
            return [qh];
          }
          init() {
            const t = this.editor;
            t.model.schema.register('listItem', {
              inheritAllFrom: '$block',
              allowAttributes: ['listType', 'listIndent'],
            });
            const e = t.data,
              o = t.editing;
            var i;
            t.model.document.registerPostFixer(e =>
              (function (t, e) {
                const o = t.document.differ.getChanges(),
                  i = new Map();
                let n = !1;
                for (const i of o)
                  if ('insert' == i.type && 'listItem' == i.name) r(i.position);
                  else if ('insert' == i.type && 'listItem' != i.name) {
                    if ('$text' != i.name) {
                      const o = i.position.nodeAfter;
                      o.hasAttribute('listIndent') && (e.removeAttribute('listIndent', o), (n = !0)),
                        o.hasAttribute('listType') && (e.removeAttribute('listType', o), (n = !0));
                      for (const e of Array.from(t.createRangeIn(o)).filter(t => t.item.is('listItem')))
                        r(e.previousPosition);
                    }
                    r(i.position.getShiftedBy(i.length));
                  } else
                    'remove' == i.type && 'listItem' == i.name
                      ? r(i.position)
                      : (('attribute' == i.type && 'listIndent' == i.attributeKey) ||
                          ('attribute' == i.type && 'listType' == i.attributeKey)) &&
                        r(i.range.start);
                for (const t of i.values()) s(t), a(t);
                return n;
                function r(t) {
                  const e = t.nodeBefore;
                  if (e && e.is('listItem')) {
                    let t = e;
                    if (i.has(t)) return;
                    for (let e = t.previousSibling; e && e.is('listItem'); e = t.previousSibling)
                      if (((t = e), i.has(t))) return;
                    i.set(e, t);
                  } else {
                    const e = t.nodeAfter;
                    e && e.is('listItem') && i.set(e, e);
                  }
                }
                function s(t) {
                  let o = 0,
                    i = null;
                  for (; t && t.is('listItem'); ) {
                    const r = t.getAttribute('listIndent');
                    if (r > o) {
                      let s;
                      null === i ? ((i = r - o), (s = o)) : (i > r && (i = r), (s = r - i)),
                        e.setAttribute('listIndent', s, t),
                        (n = !0);
                    } else (i = null), (o = t.getAttribute('listIndent') + 1);
                    t = t.nextSibling;
                  }
                }
                function a(t) {
                  let o = [],
                    i = null;
                  for (; t && t.is('listItem'); ) {
                    const r = t.getAttribute('listIndent');
                    if ((i && i.getAttribute('listIndent') > r && (o = o.slice(0, r + 1)), 0 != r))
                      if (o[r]) {
                        const i = o[r];
                        t.getAttribute('listType') != i && (e.setAttribute('listType', i, t), (n = !0));
                      } else o[r] = t.getAttribute('listType');
                    (i = t), (t = t.nextSibling);
                  }
                }
              })(t.model, e)
            ),
              o.mapper.registerViewToModelLength('li', Wf),
              e.mapper.registerViewToModelLength('li', Wf),
              o.mapper.on('modelToViewPosition', zf(o.view)),
              o.mapper.on(
                'viewToModelPosition',
                ((i = t.model),
                (t, e) => {
                  const o = e.viewPosition,
                    n = o.parent,
                    r = e.mapper;
                  if ('ul' == n.name || 'ol' == n.name) {
                    if (o.isAtEnd) {
                      const t = r.toModelElement(o.nodeBefore),
                        n = r.getModelLength(o.nodeBefore);
                      e.modelPosition = i.createPositionBefore(t).getShiftedBy(n);
                    } else {
                      const t = r.toModelElement(o.nodeAfter);
                      e.modelPosition = i.createPositionBefore(t);
                    }
                    t.stop();
                  } else if (
                    'li' == n.name &&
                    o.nodeBefore &&
                    ('ul' == o.nodeBefore.name || 'ol' == o.nodeBefore.name)
                  ) {
                    const s = r.toModelElement(n);
                    let a = 1,
                      l = o.nodeBefore;
                    for (; l && Ff(l); ) (a += r.getModelLength(l)), (l = l.previousSibling);
                    (e.modelPosition = i.createPositionBefore(s).getShiftedBy(a)), t.stop();
                  }
                })
              ),
              e.mapper.on('modelToViewPosition', zf(o.view)),
              t.conversion.for('editingDowncast').add(e => {
                e.on('insert', Nf, { priority: 'high' }),
                  e.on('insert:listItem', Ef(t.model)),
                  e.on('attribute:listType:listItem', Mf, { priority: 'high' }),
                  e.on('attribute:listType:listItem', If, { priority: 'low' }),
                  e.on(
                    'attribute:listIndent:listItem',
                    (function (t) {
                      return (e, o, i) => {
                        if (!i.consumable.consume(o.item, 'attribute:listIndent')) return;
                        const n = i.mapper.toViewElement(o.item),
                          r = i.writer;
                        r.breakContainer(r.createPositionBefore(n)), r.breakContainer(r.createPositionAfter(n));
                        const s = n.parent,
                          a = s.previousSibling,
                          l = r.createRangeOn(s);
                        r.remove(l),
                          a && a.nextSibling && Cf(r, a, a.nextSibling),
                          Bf(o.attributeOldValue + 1, o.range.start, l.start, n, i, t),
                          xf(o.item, n, i, t);
                        for (const t of o.item.getChildren()) i.consumable.consume(t, 'insert');
                      };
                    })(t.model)
                  ),
                  e.on(
                    'remove:listItem',
                    (function (t) {
                      return (e, o, i) => {
                        const n = i.mapper.toViewPosition(o.position).getLastMatchingPosition(t => !t.item.is('li'))
                            .nodeAfter,
                          r = i.writer;
                        r.breakContainer(r.createPositionBefore(n)), r.breakContainer(r.createPositionAfter(n));
                        const s = n.parent,
                          a = s.previousSibling,
                          l = r.createRangeOn(s),
                          c = r.remove(l);
                        a && a.nextSibling && Cf(r, a, a.nextSibling);
                        Bf(i.mapper.toModelElement(n).getAttribute('listIndent') + 1, o.position, l.start, n, i, t);
                        for (const t of r.createRangeIn(c).getItems()) i.mapper.unbindViewElement(t);
                        e.stop();
                      };
                    })(t.model)
                  ),
                  e.on('remove', Rf, { priority: 'low' });
              }),
              t.conversion.for('dataDowncast').add(e => {
                e.on('insert', Nf, { priority: 'high' }), e.on('insert:listItem', Ef(t.model));
              }),
              t.conversion.for('upcast').add(t => {
                t.on('element:ul', Vf, { priority: 'high' }),
                  t.on('element:ol', Vf, { priority: 'high' }),
                  t.on('element:li', Df, { priority: 'high' }),
                  t.on('element:li', Of);
              }),
              t.model.on('insertContent', Lf, { priority: 'high' }),
              t.commands.add('numberedList', new wf(t, 'numbered')),
              t.commands.add('bulletedList', new wf(t, 'bulleted')),
              t.commands.add('indentList', new vf(t, 'forward')),
              t.commands.add('outdentList', new vf(t, 'backward'));
            const n = o.view.document;
            this.listenTo(n, 'enter', (t, e) => {
              const o = this.editor.model.document,
                i = o.selection.getLastPosition().parent;
              o.selection.isCollapsed &&
                'listItem' == i.name &&
                i.isEmpty &&
                (this.editor.execute('outdentList'), e.preventDefault(), t.stop());
            }),
              this.listenTo(
                n,
                'delete',
                (t, e) => {
                  if ('backward' !== e.direction) return;
                  const o = this.editor.model.document.selection;
                  if (!o.isCollapsed) return;
                  const i = o.getFirstPosition();
                  if (!i.isAtStart) return;
                  const n = i.parent;
                  if ('listItem' !== n.name) return;
                  (n.previousSibling && 'listItem' === n.previousSibling.name) ||
                    (this.editor.execute('outdentList'), e.preventDefault(), t.stop());
                },
                { priority: 'high' }
              );
            const r = t => (e, o) => {
              this.editor.commands.get(t).isEnabled && (this.editor.execute(t), o());
            };
            t.keystrokes.set('Tab', r('indentList')), t.keystrokes.set('Shift+Tab', r('outdentList'));
          }
          afterInit() {
            const t = this.editor.commands,
              e = t.get('indent'),
              o = t.get('outdent');
            e && e.registerChildCommand(t.get('indentList')), o && o.registerChildCommand(t.get('outdentList'));
          }
        }
        function Wf(t) {
          let e = 1;
          for (const o of t.getChildren())
            if ('ul' == o.name || 'ol' == o.name) for (const t of o.getChildren()) e += Wf(t);
          return e;
        }
        class Uf extends Hc {
          init() {
            const t = this.editor.t;
            Sf(
              this.editor,
              'numberedList',
              t('Numbered List'),
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'
            ),
              Sf(
                this.editor,
                'bulletedList',
                t('Bulleted List'),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>'
              );
          }
        }
        function qf(t, e) {
          return t => {
            t.on('attribute:url:media', o);
          };
          function o(o, i, n) {
            if (!n.consumable.consume(i.item, o.name)) return;
            const r = i.attributeNewValue,
              s = n.writer,
              a = n.mapper.toViewElement(i.item),
              l = [...a.getChildren()].find(t => t.getCustomProperty('media-content'));
            s.remove(l);
            const c = t.getMediaViewElement(s, r, e);
            s.insert(s.createPositionAt(a, 0), c);
          }
        }
        function Gf(t, e, o, i) {
          const n = t.createContainerElement('figure', { class: 'media' });
          return (n.getFillerOffset = Qf), t.insert(t.createPositionAt(n, 0), e.getMediaViewElement(t, o, i)), n;
        }
        function Yf(t) {
          const e = t.getSelectedElement();
          return e && e.is('media') ? e : null;
        }
        function $f(t, e, o) {
          t.change(i => {
            const n = i.createElement('media', { url: e });
            t.insertContent(n, o), i.setSelection(n, 'on');
          });
        }
        function Qf() {
          return null;
        }
        class Kf extends Uc {
          refresh() {
            const t = this.editor.model,
              e = t.document.selection,
              o = t.schema,
              i = e.getFirstPosition(),
              n = Yf(e);
            let r = i.parent;
            r != r.root && (r = r.parent),
              (this.value = n ? n.getAttribute('url') : null),
              (this.isEnabled = o.checkChild(r, 'media'));
          }
          execute(t) {
            const e = this.editor.model,
              o = e.document.selection,
              i = Yf(o);
            if (i)
              e.change(e => {
                e.setAttribute('url', t, i);
              });
            else {
              const i = ku(o, e);
              $f(e, t, i);
            }
          }
        }
        class Jf {
          constructor(t, e) {
            const o = e.providers,
              i = e.extraProviders || [],
              n = new Set(e.removeProviders),
              r = o.concat(i).filter(t => {
                const e = t.name;
                return e
                  ? !n.has(e)
                  : (console.warn(
                      Object(uo.a)(
                        'media-embed-no-provider-name: The configured media provider has no name and cannot be used.'
                      ),
                      { provider: t }
                    ),
                    !1);
              });
            (this.locale = t), (this.providerDefinitions = r);
          }
          hasMedia(t) {
            return !!this._getMedia(t);
          }
          getMediaViewElement(t, e, o) {
            return this._getMedia(e).getViewElement(t, o);
          }
          _getMedia(t) {
            if (!t) return new Zf(this.locale);
            t = t.trim();
            for (const e of this.providerDefinitions) {
              const o = e.html;
              let i = e.url;
              Array.isArray(i) || (i = [i]);
              for (const e of i) {
                const i = this._getUrlMatches(t, e);
                if (i) return new Zf(this.locale, t, i, o);
              }
            }
            return null;
          }
          _getUrlMatches(t, e) {
            let o = t.match(e);
            if (o) return o;
            let i = t.replace(/^https?:\/\//, '');
            return (o = i.match(e)), o || ((i = i.replace(/^www\./, '')), (o = i.match(e)), o || null);
          }
        }
        class Zf {
          constructor(t, e, o, i) {
            (this.url = this._getValidUrl(e)), (this._t = t.t), (this._match = o), (this._previewRenderer = i);
          }
          getViewElement(t, e) {
            const o = {};
            let i;
            if (e.renderForEditingView || (e.renderMediaPreview && this.url && this._previewRenderer)) {
              this.url && (o['data-oembed-url'] = this.url), e.renderForEditingView && (o.class = 'ck-media__wrapper');
              const n = this._getPreviewHtml(e);
              i = t.createUIElement('div', o, function (t) {
                const e = this.toDomElement(t);
                return (e.innerHTML = n), e;
              });
            } else this.url && (o.url = this.url), (i = t.createEmptyElement('oembed', o));
            return t.setCustomProperty('media-content', !0, i), i;
          }
          _getPreviewHtml(t) {
            return this._previewRenderer
              ? this._previewRenderer(this._match)
              : this.url && t.renderForEditingView
              ? this._getPlaceholderHtml()
              : '';
          }
          _getPlaceholderHtml() {
            const t = new Cc(),
              e = new xc();
            (t.text = this._t('Open media in new tab')),
              (e.content =
                '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>'),
              (e.viewBox = '0 0 64 42');
            return new Fl({
              tag: 'div',
              attributes: { class: 'ck ck-reset_all ck-media__placeholder' },
              children: [
                { tag: 'div', attributes: { class: 'ck-media__placeholder__icon' }, children: [e] },
                {
                  tag: 'a',
                  attributes: {
                    class: 'ck-media__placeholder__url',
                    target: '_blank',
                    rel: 'noopener noreferrer',
                    href: this.url,
                  },
                  children: [
                    { tag: 'span', attributes: { class: 'ck-media__placeholder__url__text' }, children: [this.url] },
                    t,
                  ],
                },
              ],
            }).render().outerHTML;
          }
          _getValidUrl(t) {
            return t ? (t.match(/^https?/) ? t : 'https://' + t) : null;
          }
        }
        o(92);
        class Xf extends Hc {
          static get pluginName() {
            return 'MediaEmbedEditing';
          }
          constructor(t) {
            super(t),
              t.config.define('mediaEmbed', {
                providers: [
                  {
                    name: 'dailymotion',
                    url: /^dailymotion\.com\/video\/(\w+)/,
                    html: t =>
                      `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`,
                  },
                  {
                    name: 'spotify',
                    url: [
                      /^open\.spotify\.com\/(artist\/\w+)/,
                      /^open\.spotify\.com\/(album\/\w+)/,
                      /^open\.spotify\.com\/(track\/\w+)/,
                    ],
                    html: t =>
                      `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`,
                  },
                  {
                    name: 'youtube',
                    url: [
                      /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/,
                      /^(?:m\.)?youtube\.com\/v\/([\w-]+)/,
                      /^youtube\.com\/embed\/([\w-]+)/,
                      /^youtu\.be\/([\w-]+)/,
                    ],
                    html: t =>
                      `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`,
                  },
                  {
                    name: 'vimeo',
                    url: [
                      /^vimeo\.com\/(\d+)/,
                      /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
                      /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
                      /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
                      /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
                      /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
                      /^player\.vimeo\.com\/video\/(\d+)/,
                    ],
                    html: t =>
                      `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`,
                  },
                  { name: 'instagram', url: /^instagram\.com\/p\/(\w+)/ },
                  { name: 'twitter', url: /^twitter\.com/ },
                  { name: 'googleMaps', url: /^google\.com\/maps/ },
                  { name: 'flickr', url: /^flickr\.com/ },
                  { name: 'facebook', url: /^facebook\.com/ },
                ],
              }),
              (this.registry = new Jf(t.locale, t.config.get('mediaEmbed')));
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              o = t.t,
              i = t.conversion,
              n = t.config.get('mediaEmbed.previewsInData'),
              r = this.registry;
            t.commands.add('mediaEmbed', new Kf(t)),
              e.register('media', { isObject: !0, isBlock: !0, allowWhere: '$block', allowAttributes: ['url'] }),
              i.for('dataDowncast').elementToElement({
                model: 'media',
                view: (t, e) => {
                  const o = t.getAttribute('url');
                  return Gf(e, r, o, { renderMediaPreview: o && n });
                },
              }),
              i.for('dataDowncast').add(qf(r, { renderMediaPreview: n })),
              i.for('editingDowncast').elementToElement({
                model: 'media',
                view: (t, e) => {
                  const i = t.getAttribute('url'),
                    n = Gf(e, r, i, { renderForEditingView: !0 });
                  return (
                    (s = n),
                    (a = e),
                    (l = o('media widget')),
                    a.setCustomProperty('media', !0, s),
                    pu(s, a, { label: l })
                  );
                  var s, a, l;
                },
              }),
              i.for('editingDowncast').add(qf(r, { renderForEditingView: !0 })),
              i
                .for('upcast')
                .elementToElement({
                  view: { name: 'oembed', attributes: { url: !0 } },
                  model: (t, e) => {
                    const o = t.getAttribute('url');
                    if (r.hasMedia(o)) return e.createElement('media', { url: o });
                  },
                })
                .elementToElement({
                  view: { name: 'div', attributes: { 'data-oembed-url': !0 } },
                  model: (t, e) => {
                    const o = t.getAttribute('data-oembed-url');
                    if (r.hasMedia(o)) return e.createElement('media', { url: o });
                  },
                });
          }
        }
        const tp = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w\-._~:/?#[\]@!$&'()*+,;=]+$/;
        class ep extends Hc {
          static get requires() {
            return [vd, fh];
          }
          static get pluginName() {
            return 'AutoMediaEmbed';
          }
          constructor(t) {
            super(t), (this._timeoutId = null), (this._positionToInsert = null);
          }
          init() {
            const t = this.editor,
              e = t.model.document;
            this.listenTo(t.plugins.get(vd), 'inputTransformation', () => {
              const t = e.selection.getFirstRange(),
                o = al.fromPosition(t.start);
              o.stickiness = 'toPrevious';
              const i = al.fromPosition(t.end);
              (i.stickiness = 'toNext'),
                e.once(
                  'change:data',
                  () => {
                    this._embedMediaBetweenPositions(o, i), o.detach(), i.detach();
                  },
                  { priority: 'high' }
                );
            }),
              t.commands.get('undo').on(
                'execute',
                () => {
                  this._timeoutId &&
                    (Xn.window.clearTimeout(this._timeoutId),
                    this._positionToInsert.detach(),
                    (this._timeoutId = null),
                    (this._positionToInsert = null));
                },
                { priority: 'high' }
              );
          }
          _embedMediaBetweenPositions(t, e) {
            const o = this.editor,
              i = o.plugins.get(Xf).registry,
              n = new Os(t, e),
              r = n.getWalker({ ignoreElementEnd: !0 });
            let s = '';
            for (const t of r) t.item.is('textProxy') && (s += t.item.data);
            if (((s = s.trim()), !s.match(tp))) return void n.detach();
            if (!i.hasMedia(s)) return void n.detach();
            o.commands.get('mediaEmbed').isEnabled
              ? ((this._positionToInsert = al.fromPosition(t)),
                (this._timeoutId = Xn.window.setTimeout(() => {
                  o.model.change(t => {
                    let e;
                    (this._timeoutId = null),
                      t.remove(n),
                      n.detach(),
                      '$graveyard' !== this._positionToInsert.root.rootName && (e = this._positionToInsert),
                      $f(o.model, s, e),
                      this._positionToInsert.detach(),
                      (this._positionToInsert = null);
                  });
                }, 100)))
              : n.detach();
          }
        }
        o(94);
        class op extends sc {
          constructor(t, e) {
            super(e);
            const o = e.t;
            (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this.urlInputView = this._createUrlInput()),
              (this.saveButtonView = this._createButton(o('Save'), qu, 'ck-button-save')),
              (this.saveButtonView.type = 'submit'),
              (this.cancelButtonView = this._createButton(o('Cancel'), Gu, 'ck-button-cancel', 'cancel')),
              (this._focusables = new Bl()),
              (this._focusCycler = new uc({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              (this._validators = t),
              this.setTemplate({
                tag: 'form',
                attributes: { class: ['ck', 'ck-media-form'], tabindex: '-1' },
                children: [this.urlInputView, this.saveButtonView, this.cancelButtonView],
              });
          }
          render() {
            super.render(), Uu({ view: this });
            [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach(t => {
              this._focusables.add(t), this.focusTracker.add(t.element);
            }),
              this.keystrokes.listenTo(this.element);
            const t = t => t.stopPropagation();
            this.keystrokes.set('arrowright', t),
              this.keystrokes.set('arrowleft', t),
              this.keystrokes.set('arrowup', t),
              this.keystrokes.set('arrowdown', t),
              this.listenTo(
                this.urlInputView.element,
                'selectstart',
                (t, e) => {
                  e.stopPropagation();
                },
                { priority: 'high' }
              );
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          get url() {
            return this.urlInputView.fieldView.element.value.trim();
          }
          set url(t) {
            this.urlInputView.fieldView.element.value = t.trim();
          }
          isValid() {
            this.resetFormStatus();
            for (const t of this._validators) {
              const e = t(this);
              if (e) return (this.urlInputView.errorText = e), !1;
            }
            return !0;
          }
          resetFormStatus() {
            (this.urlInputView.errorText = null), (this.urlInputView.infoText = this._urlInputViewInfoDefault);
          }
          _createUrlInput() {
            const t = this.locale.t,
              e = new Bu(this.locale, Hu),
              o = e.fieldView;
            return (
              (this._urlInputViewInfoDefault = t('Paste the media URL in the input.')),
              (this._urlInputViewInfoTip = t('Tip: Paste the URL into the content to embed faster.')),
              (e.label = t('Media URL')),
              (e.infoText = this._urlInputViewInfoDefault),
              (o.placeholder = 'https://example.com'),
              o.on('input', () => {
                e.infoText = o.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
              }),
              e
            );
          }
          _createButton(t, e, o, i) {
            const n = new Ac(this.locale);
            return (
              n.set({ label: t, icon: e, tooltip: !0 }),
              n.extendTemplate({ attributes: { class: o } }),
              i && n.delegate('execute').to(this, i),
              n
            );
          }
        }
        class ip extends Hc {
          static get requires() {
            return [Xf];
          }
          static get pluginName() {
            return 'MediaEmbedUI';
          }
          init() {
            const t = this.editor,
              e = t.commands.get('mediaEmbed'),
              o = t.plugins.get(Xf).registry;
            t.ui.componentFactory.add('mediaEmbed', i => {
              const n = Rc(i),
                r = new op(
                  (function (t, e) {
                    return [
                      e => {
                        if (!e.url.length) return t('The URL must not be empty.');
                      },
                      o => {
                        if (!e.hasMedia(o.url)) return t('This media URL is not supported.');
                      },
                    ];
                  })(t.t, o),
                  t.locale
                );
              return this._setUpDropdown(n, r, e, t), this._setUpForm(n, r, e), n;
            });
          }
          _setUpDropdown(t, e, o) {
            const i = this.editor,
              n = i.t,
              r = t.buttonView;
            function s() {
              i.editing.view.focus(), (t.isOpen = !1);
            }
            t.bind('isEnabled').to(o),
              t.panelView.children.add(e),
              r.set({
                label: n('Insert media'),
                icon:
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 01.593-.351l5.133 2.824a.4.4 0 010 .7l-5.133 2.824a.4.4 0 01-.593-.35V7.176v.001z"/></svg>\n',
                tooltip: !0,
              }),
              r.on(
                'open',
                () => {
                  (e.url = o.value || ''), e.urlInputView.fieldView.select(), e.focus();
                },
                { priority: 'low' }
              ),
              t.on('submit', () => {
                e.isValid() && (i.execute('mediaEmbed', e.url), s());
              }),
              t.on('change:isOpen', () => e.resetFormStatus()),
              t.on('cancel', () => s());
          }
          _setUpForm(t, e, o) {
            e.delegate('submit', 'cancel').to(t),
              e.urlInputView.bind('value').to(o, 'value'),
              e.urlInputView.bind('isReadOnly').to(o, 'isEnabled', t => !t),
              e.saveButtonView.bind('isEnabled').to(o);
          }
        }
        o(96);
        function np(t, e) {
          if (!t.childCount) return;
          const o = new qg(t.document),
            i = (function (t, e) {
              const o = e.createRangeIn(t),
                i = new zo({ name: /^p|h\d+$/, styles: { 'mso-list': /.*/ } }),
                n = [];
              for (const t of o)
                if ('elementStart' === t.type && i.match(t.item)) {
                  const e = sp(t.item);
                  n.push({ element: t.item, id: e.id, order: e.order, indent: e.indent });
                }
              return n;
            })(t, o);
          if (!i.length) return;
          let n = null,
            r = 1;
          i.forEach((t, s) => {
            const a = (function (t, e) {
                if (!t) return !0;
                if (t.id !== e.id) return !0;
                const o = e.element.previousSibling;
                if (!o) return !0;
                return (i = o), !(i.is('ol') || i.is('ul'));
                var i;
              })(i[s - 1], t),
              l = a ? null : i[s - 1],
              c = ((h = t), (d = l) ? h.indent - d.indent : h.indent - 1);
            var d, h;
            if ((a && ((n = null), (r = 1)), !n || 0 !== c)) {
              const i = (function (t, e) {
                const o = new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`, 'gi'),
                  i = /mso-level-number-format:([^;]*);/gi,
                  n = o.exec(e);
                let r = 'decimal';
                if (n && n[1]) {
                  const t = i.exec(n[1]);
                  t && t[1] && (r = t[1].trim());
                }
                return { type: 'bullet' !== r && 'image' !== r ? 'ol' : 'ul', style: r };
              })(t, e);
              if (n) {
                if (t.indent > r) {
                  const t = n.getChild(n.childCount - 1),
                    e = t.getChild(t.childCount - 1);
                  (n = rp(i, e, o)), (r += 1);
                } else if (t.indent < r) {
                  const e = r - t.indent;
                  (n = (function (t, e) {
                    const o = t.getAncestors({ parentFirst: !0 });
                    let i = null,
                      n = 0;
                    for (const t of o)
                      if ((('ul' !== t.name && 'ol' !== t.name) || n++, n === e)) {
                        i = t;
                        break;
                      }
                    return i;
                  })(n, e)),
                    (r = parseInt(t.indent));
                }
              } else n = rp(i, t.element, o);
              t.indent <= r && (n.is(i.type) || (n = o.rename(i.type, n)));
            }
            const u = (function (t, e) {
              return (
                (function (t, e) {
                  const o = new zo({ name: 'span', styles: { 'mso-list': 'Ignore' } }),
                    i = e.createRangeIn(t);
                  for (const t of i) 'elementStart' === t.type && o.match(t.item) && e.remove(t.item);
                })(t, e),
                e.rename('li', t)
              );
            })(t.element, o);
            o.appendChild(u, n);
          });
        }
        function rp(t, e, o) {
          const i = e.parent,
            n = o.createElement(t.type),
            r = i.getChildIndex(e) + 1;
          return o.insertChild(r, n, i), n;
        }
        function sp(t) {
          const e = {},
            o = t.getStyle('mso-list');
          if (o) {
            const t = o.match(/(^|\s+)l(\d+)/i),
              i = o.match(/\s*lfo(\d+)/i),
              n = o.match(/\s*level(\d+)/i);
            t && i && n && ((e.id = t[2]), (e.order = i[1]), (e.indent = n[1]));
          }
          return e;
        }
        const ap = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
        class lp {
          constructor(t) {
            this.document = t;
          }
          isActive(t) {
            return ap.test(t);
          }
          execute(t) {
            const e = new qg(this.document);
            !(function (t, e) {
              for (const o of t.getChildren())
                if (o.is('b') && 'normal' === o.getStyle('font-weight')) {
                  const i = t.getChildIndex(o);
                  e.remove(o), e.insertChild(i, o.getChildren(), t);
                }
            })(t.content, e),
              (function (t, e) {
                for (const o of e.createRangeIn(t)) {
                  const t = o.item;
                  if (t.is('li')) {
                    const o = t.getChild(0);
                    o.is('p') && e.unwrapElement(o);
                  }
                }
              })(t.content, e);
          }
        }
        function cp(t) {
          return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) =>
            1 === e.length
              ? ' '
              : Array(e.length + 1)
                  .join('  ')
                  .substr(0, e.length)
          );
        }
        function dp(t, e) {
          const o = new DOMParser(),
            i = (function (t) {
              return cp(cp(t))
                .replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[\s]*?)[\r\n]+(\s*<\/span>)/g, '$1$2')
                .replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, '')
                .replace(/ <\//g, ' </')
                .replace(/ <o:p><\/o:p>/g, ' <o:p></o:p>')
                .replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, '')
                .replace(/>(\s*[\r\n]\s*)</g, '><');
            })(
              (function (t) {
                const e = t.match(/<\/body>(.*?)(<\/html>|$)/);
                e && e[1] && (t = t.slice(0, e.index) + t.slice(e.index).replace(e[1], ''));
                return t;
              })((t = t.replace(/<!--\[if gte vml 1]>/g, '')))
            ),
            n = o.parseFromString(i, 'text/html');
          !(function (t) {
            t.querySelectorAll('span[style*=spacerun]').forEach(t => {
              const e = t.innerText.length || 0;
              t.innerHTML = Array(e + 1)
                .join('  ')
                .substr(0, e);
            });
          })(n);
          const r = n.body.innerHTML,
            s = (function (t, e) {
              const o = new rn(e),
                i = new ir(o, { blockFillerMode: 'nbsp' }),
                n = t.createDocumentFragment(),
                r = t.body.childNodes;
              for (; r.length > 0; ) n.appendChild(r[0]);
              return i.domToView(n);
            })(n, e),
            a = (function (t) {
              const e = [],
                o = [],
                i = Array.from(t.getElementsByTagName('style'));
              for (const t of i)
                t.sheet && t.sheet.cssRules && t.sheet.cssRules.length && (e.push(t.sheet), o.push(t.innerHTML));
              return { styles: e, stylesString: o.join(' ') };
            })(n);
          return { body: s, bodyString: r, styles: a.styles, stylesString: a.stylesString };
        }
        function hp(t, e) {
          if (!t.childCount) return;
          const o = new qg();
          !(function (t, e, o) {
            const i = o.createRangeIn(e),
              n = new zo({ name: 'img' }),
              r = [];
            for (const e of i)
              if (n.match(e.item)) {
                const o = e.item,
                  i = o.getAttribute('v:shapes') ? o.getAttribute('v:shapes').split(' ') : [];
                i.length && i.every(e => t.indexOf(e) > -1) ? r.push(o) : o.getAttribute('src') || r.push(o);
              }
            for (const t of r) o.remove(t);
          })(
            (function (t, e) {
              const o = e.createRangeIn(t),
                i = new zo({ name: /v:(.+)/ }),
                n = [];
              for (const t of o) {
                const e = t.item,
                  o = (e.previousSibling && e.previousSibling.name) || null;
                i.match(e) && e.getAttribute('o:gfxdata') && 'v:shapetype' !== o && n.push(t.item.getAttribute('id'));
              }
              return n;
            })(t, o),
            t,
            o
          ),
            (function (t, e) {
              const o = e.createRangeIn(t),
                i = new zo({ name: /v:(.+)/ }),
                n = [];
              for (const t of o) i.match(t.item) && n.push(t.item);
              for (const t of n) e.remove(t);
            })(t, o);
          const i = (function (t, e) {
            const o = e.createRangeIn(t),
              i = new zo({ name: 'img' }),
              n = [];
            for (const t of o) i.match(t.item) && t.item.getAttribute('src').startsWith('file://') && n.push(t.item);
            return n;
          })(t, o);
          i.length &&
            (function (t, e, o) {
              if (t.length === e.length)
                for (let n = 0; n < t.length; n++) {
                  const r = `data:${e[n].type};base64,${
                    ((i = e[n].hex),
                    btoa(
                      i
                        .match(/\w{2}/g)
                        .map(t => String.fromCharCode(parseInt(t, 16)))
                        .join('')
                    ))
                  }`;
                  o.setAttribute('src', r, t[n]);
                }
              var i;
            })(
              i,
              (function (t) {
                if (!t) return [];
                const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
                  o = new RegExp('(?:(' + e.source + '))([\\da-fA-F\\s]+)\\}', 'g'),
                  i = t.match(o),
                  n = [];
                if (i)
                  for (const t of i) {
                    let o = !1;
                    t.includes('\\pngblip') ? (o = 'image/png') : t.includes('\\jpegblip') && (o = 'image/jpeg'),
                      o && n.push({ hex: t.replace(e, '').replace(/[^\da-fA-F]/g, ''), type: o });
                  }
                return n;
              })(e),
              o
            );
        }
        const up = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
          gp = /xmlns:o="urn:schemas-microsoft-com/i;
        class mp {
          constructor(t) {
            this.document = t;
          }
          isActive(t) {
            return up.test(t) || gp.test(t);
          }
          execute(t) {
            const { body: e, stylesString: o } = dp(t.dataTransfer.getData('text/html'), this.document.stylesProcessor);
            np(e, o), hp(e, t.dataTransfer.getData('text/rtf')), (t.content = e);
          }
        }
        class fp extends Hc {
          static get pluginName() {
            return 'RemoveFormatUI';
          }
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('removeFormat', o => {
              const i = t.commands.get('removeFormat'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Remove Format'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>',
                  tooltip: !0,
                }),
                n.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  t.execute('removeFormat'), t.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        class pp extends Uc {
          refresh() {
            const t = this.editor.model;
            this.isEnabled = !!Gc(this._getFormattingItems(t.document.selection, t.schema));
          }
          execute() {
            const t = this.editor.model,
              e = t.schema;
            t.change(o => {
              for (const i of this._getFormattingItems(t.document.selection, e))
                if (i.is('selection'))
                  for (const t of this._getFormattingAttributes(i, e)) o.removeSelectionAttribute(t);
                else {
                  const t = o.createRangeOn(i);
                  for (const n of this._getFormattingAttributes(i, e)) o.removeAttribute(n, t);
                }
            });
          }
          *_getFormattingItems(t, e) {
            const o = t => !!Gc(this._getFormattingAttributes(t, e));
            for (const e of t.getRanges()) for (const t of e.getItems()) o(t) && (yield t);
            o(t) && (yield t);
          }
          *_getFormattingAttributes(t, e) {
            for (const [o] of t.getAttributes()) {
              const t = e.getAttributeProperties(o);
              t && t.isFormatting && (yield o);
            }
          }
        }
        class bp extends Hc {
          static get pluginName() {
            return 'RemoveFormatEditing';
          }
          init() {
            const t = this.editor;
            t.commands.add('removeFormat', new pp(t));
          }
        }
        class wp {
          constructor(t, e) {
            (this.loader = t), (this.options = e);
          }
          upload() {
            return this.loader.file.then(
              t =>
                new Promise((e, o) => {
                  this._initRequest(), this._initListeners(e, o, t), this._sendRequest(t);
                })
            );
          }
          abort() {
            this.xhr && this.xhr.abort();
          }
          _initRequest() {
            const t = (this.xhr = new XMLHttpRequest());
            t.open('POST', this.options.uploadUrl, !0), (t.responseType = 'json');
          }
          _initListeners(t, e, o) {
            const i = this.xhr,
              n = this.loader,
              r = `Couldn't upload file: ${o.name}.`;
            i.addEventListener('error', () => e(r)),
              i.addEventListener('abort', () => e()),
              i.addEventListener('load', () => {
                const o = i.response;
                if (!o || o.error) return e(o && o.error && o.error.message ? o.error.message : r);
                t(o.url ? { default: o.url } : o.urls);
              }),
              i.upload &&
                i.upload.addEventListener('progress', t => {
                  t.lengthComputable && ((n.uploadTotal = t.total), (n.uploaded = t.loaded));
                });
          }
          _sendRequest(t) {
            const e = this.options.headers || {};
            for (const t of Object.keys(e)) this.xhr.setRequestHeader(t, e[t]);
            const o = new FormData();
            o.append('upload', t), this.xhr.send(o);
          }
        }
        class kp extends Hc {
          static get pluginName() {
            return 'StrikethroughEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'strikethrough' }),
              t.model.schema.setAttributeProperties('strikethrough', { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: 'strikethrough',
                view: 's',
                upcastAlso: ['del', 'strike', { styles: { 'text-decoration': 'line-through' } }],
              }),
              t.commands.add('strikethrough', new fd(t, 'strikethrough')),
              t.keystrokes.set('CTRL+SHIFT+X', 'strikethrough');
          }
        }
        class _p extends Hc {
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('strikethrough', o => {
              const i = t.commands.get('strikethrough'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Strikethrough'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9L6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>',
                  keystroke: 'CTRL+SHIFT+X',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                n.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  t.execute('strikethrough'), t.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        function vp(t, e) {
          let o = e.parent;
          for (; o; ) {
            if (o.name === t) return o;
            o = o.parent;
          }
        }
        function yp(t, e, o, i, n = 1) {
          e > n ? i.setAttribute(t, e, o) : i.removeAttribute(t, o);
        }
        function xp(t, e, o = {}) {
          const i = t.createElement('tableCell', o);
          t.insertElement('paragraph', i), t.insert(i, e);
        }
        function Cp(t) {
          if (!t || !z(t)) return t;
          const { top: e, right: o, bottom: i, left: n } = t;
          return e == o && o == i && i == n ? e : void 0;
        }
        function Ap(t, e) {
          const o = parseFloat(t);
          return Number.isNaN(o) || String(o) !== String(t) ? t : `${o}${e}`;
        }
        function Tp(t, e) {
          const o = e.parent.parent,
            i = parseInt(o.getAttribute('headingColumns') || 0),
            { column: n } = t.getCellLocation(e);
          return !!i && n < i;
        }
        function Sp() {
          return t => {
            t.on('element:table', (t, e, o) => {
              const i = e.viewItem;
              if (!o.consumable.test(i, { name: !0 })) return;
              const { rows: n, headingRows: r, headingColumns: s } = (function (t) {
                  const e = { headingRows: 0, headingColumns: 0 },
                    o = [],
                    i = [];
                  let n;
                  for (const r of Array.from(t.getChildren()))
                    if ('tbody' === r.name || 'thead' === r.name || 'tfoot' === r.name) {
                      'thead' !== r.name || n || (n = r);
                      const t = Array.from(r.getChildren()).filter(t => t.is('element', 'tr'));
                      for (const r of t)
                        if ('thead' === r.parent.name && r.parent === n) e.headingRows++, o.push(r);
                        else {
                          i.push(r);
                          const t = Ep(r);
                          t > e.headingColumns && (e.headingColumns = t);
                        }
                    }
                  return (e.rows = [...o, ...i]), e;
                })(i),
                a = {};
              s && (a.headingColumns = s), r && (a.headingRows = r);
              const l = o.writer.createElement('table', a),
                c = o.splitToAllowedParent(l, e.modelCursor);
              if (c) {
                if (
                  (o.writer.insert(l, c.position),
                  o.consumable.consume(i, { name: !0 }),
                  n.forEach(t => o.convertItem(t, o.writer.createPositionAt(l, 'end'))),
                  l.isEmpty)
                ) {
                  const t = o.writer.createElement('tableRow');
                  o.writer.insert(t, o.writer.createPositionAt(l, 'end')),
                    xp(o.writer, o.writer.createPositionAt(t, 'end'));
                }
                (e.modelRange = o.writer.createRange(
                  o.writer.createPositionBefore(l),
                  o.writer.createPositionAfter(l)
                )),
                  c.cursorParent
                    ? (e.modelCursor = o.writer.createPositionAt(c.cursorParent, 0))
                    : (e.modelCursor = e.modelRange.end);
              }
            });
          };
        }
        function Pp(t) {
          return e => {
            e.on('element:' + t, (t, e, o) => {
              const i = e.viewItem;
              if (!o.consumable.test(i, { name: !0 })) return;
              const n = o.writer.createElement('tableCell'),
                r = o.splitToAllowedParent(n, e.modelCursor);
              if (!r) return;
              o.writer.insert(n, r.position), o.consumable.consume(i, { name: !0 });
              const s = o.writer.createPositionAt(n, 0);
              o.convertChildren(i, s),
                n.childCount || o.writer.insertElement('paragraph', s),
                (e.modelRange = o.writer.createRange(
                  o.writer.createPositionBefore(n),
                  o.writer.createPositionAfter(n)
                )),
                (e.modelCursor = e.modelRange.end);
            });
          };
        }
        function Ep(t) {
          let e = 0,
            o = 0;
          const i = Array.from(t.getChildren()).filter(t => 'th' === t.name || 'td' === t.name);
          for (; o < i.length && 'th' === i[o].name; ) {
            const t = i[o];
            (e += parseInt(t.getAttribute('colspan') || 1)), o++;
          }
          return e;
        }
        class Mp {
          constructor(t, e = {}) {
            (this.table = t),
              (this.startRow = e.startRow || 0),
              (this.endRow = 'number' == typeof e.endRow ? e.endRow : void 0),
              (this.includeSpanned = !!e.includeSpanned),
              (this.column = 'number' == typeof e.column ? e.column : void 0),
              (this._skipRows = new Set()),
              (this._row = 0),
              (this._column = 0),
              (this._cellIndex = 0),
              (this._spannedCells = new Map()),
              (this._nextCellAtColumn = -1);
          }
          [Symbol.iterator]() {
            return this;
          }
          next() {
            const t = this.table.getChild(this._row);
            if (!t || this._isOverEndRow()) return { done: !0 };
            let e, o, i;
            if (this._isSpanned(this._row, this._column))
              (e = this._getSpanned(this._row, this._column)),
                (o = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn()),
                (i = this._formatOutValue(e, this._column, !0));
            else {
              if (((e = t.getChild(this._cellIndex)), !e))
                return (
                  this._row++, (this._column = 0), (this._cellIndex = 0), (this._nextCellAtColumn = -1), this.next()
                );
              const n = parseInt(e.getAttribute('colspan') || 1),
                r = parseInt(e.getAttribute('rowspan') || 1);
              (n > 1 || r > 1) && this._recordSpans(this._row, this._column, r, n, e),
                (this._nextCellAtColumn = this._column + n),
                (o = this._shouldSkipRow() || this._shouldSkipColumn()),
                (i = this._formatOutValue(e, this._column, !1, r, n));
            }
            return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, o ? this.next() : i;
          }
          skipRow(t) {
            this._skipRows.add(t);
          }
          _isOverEndRow() {
            return void 0 !== this.endRow && this._row > this.endRow;
          }
          _formatOutValue(t, e, o, i = 1, n = 1) {
            return {
              done: !1,
              value: {
                cell: t,
                row: this._row,
                column: e,
                isSpanned: o,
                rowspan: i,
                colspan: n,
                cellIndex: this._cellIndex,
              },
            };
          }
          _shouldSkipRow() {
            const t = this._row < this.startRow,
              e = this._skipRows.has(this._row);
            return t || e;
          }
          _shouldSkipColumn() {
            return void 0 !== this.column && this.column != this._column;
          }
          _isSpanned(t, e) {
            if (!this._spannedCells.has(t)) return !1;
            return this._spannedCells.get(t).has(e);
          }
          _getSpanned(t, e) {
            return this._spannedCells.get(t).get(e);
          }
          _recordSpans(t, e, o, i, n) {
            for (let o = e + 1; o <= e + i - 1; o++) this._markSpannedCell(t, o, n);
            for (let r = t + 1; r < t + o; r++) for (let t = e; t <= e + i - 1; t++) this._markSpannedCell(r, t, n);
          }
          _markSpannedCell(t, e, o) {
            this._spannedCells.has(t) || this._spannedCells.set(t, new Map());
            this._spannedCells.get(t).set(e, o);
          }
        }
        function Ip(t) {
          return !!t.getCustomProperty('table') && fu(t);
        }
        function Np(t) {
          const e = t.getSelectedElement();
          return e && Ip(e) ? e : null;
        }
        function Rp(t) {
          const e = vp('table', t.getFirstPosition());
          return e && Ip(e.parent) ? e.parent : null;
        }
        function Op(t) {
          const e = [];
          for (const i of ((o = t.getRanges()), Array.from(o).sort(qp))) {
            const t = i.getContainedElement();
            t && t.is('tableCell') && e.push(t);
          }
          var o;
          return e;
        }
        function Vp(t) {
          const e = [];
          for (const o of t.getRanges()) {
            const t = vp('tableCell', o.start);
            t && e.push(t);
          }
          return e;
        }
        function Dp(t) {
          const e = Op(t);
          return e.length ? e : Vp(t);
        }
        function zp(t) {
          return Up(t.map(t => t.parent.index));
        }
        function Lp(t) {
          const e = vp('table', t[0]);
          return Up([...new Mp(e)].filter(e => t.includes(e.cell)).map(t => t.column));
        }
        function jp(t, e) {
          if (
            t.length < 2 ||
            !(function (t) {
              const e = vp('table', t[0]),
                o = zp(t),
                i = parseInt(e.getAttribute('headingRows') || 0);
              if (!Gp(o, i)) return !1;
              const n = parseInt(e.getAttribute('headingColumns') || 0);
              return Gp(Lp(t), n);
            })(t)
          )
            return !1;
          const o = new Set(),
            i = new Set();
          let n = 0;
          for (const r of t) {
            const { row: t, column: s } = e.getCellLocation(r),
              a = parseInt(r.getAttribute('rowspan') || 1),
              l = parseInt(r.getAttribute('colspan') || 1);
            o.add(t), i.add(s), a > 1 && o.add(t + a - 1), l > 1 && i.add(s + l - 1), (n += a * l);
          }
          return (
            (function (t, e) {
              const o = Array.from(t.values()),
                i = Array.from(e.values()),
                n = Math.max(...o),
                r = Math.min(...o),
                s = Math.max(...i),
                a = Math.min(...i);
              return (n - r + 1) * (s - a + 1);
            })(o, i) == n
          );
        }
        function Bp(t, e, o = 0) {
          const i = [],
            n = new Mp(t, { startRow: o, endRow: e - 1 });
          for (const t of n) {
            const { row: o, rowspan: n } = t,
              r = o + n - 1;
            o < e && e <= r && i.push(t);
          }
          return i;
        }
        function Fp(t, e, o) {
          const i = t.parent,
            n = i.parent,
            r = i.index,
            s = e - r,
            a = {},
            l = parseInt(t.getAttribute('rowspan')) - s;
          l > 1 && (a.rowspan = l);
          const c = parseInt(t.getAttribute('colspan') || 1);
          c > 1 && (a.colspan = c);
          const d = r + s,
            h = [...new Mp(n, { startRow: r, endRow: d, includeSpanned: !0 })];
          let u;
          for (const { row: e, column: i, cell: r, cellIndex: s } of h)
            if ((r === t && void 0 === u && (u = i), void 0 !== u && u === i && e === d)) {
              const t = n.getChild(e),
                i = o.createPositionAt(t, s);
              xp(o, i, a);
            }
          yp('rowspan', s, t, o);
        }
        function Hp(t, e) {
          const o = [],
            i = new Mp(t);
          for (const t of i) {
            const { column: i, colspan: n } = t,
              r = i + n - 1;
            i < e && e <= r && o.push(t);
          }
          return o;
        }
        function Wp(t, e, o, i) {
          const n = o - e,
            r = {},
            s = parseInt(t.getAttribute('colspan')) - n;
          s > 1 && (r.colspan = s);
          const a = parseInt(t.getAttribute('rowspan') || 1);
          a > 1 && (r.rowspan = a), xp(i, i.createPositionAfter(t), r), yp('colspan', n, t, i);
        }
        function Up(t) {
          const e = t.sort((t, e) => t - e);
          return { first: e[0], last: e[e.length - 1] };
        }
        function qp(t, e) {
          const o = t.start,
            i = e.start;
          return o.isBefore(i) ? -1 : 1;
        }
        function Gp({ first: t, last: e }, o) {
          return t < o === e < o;
        }
        function Yp(t = {}) {
          return e =>
            e.on('insert:table', (e, o, i) => {
              const n = o.item;
              if (!i.consumable.consume(n, 'insert')) return;
              i.consumable.consume(n, 'attribute:headingRows:table'),
                i.consumable.consume(n, 'attribute:headingColumns:table');
              const r = t && t.asWidget,
                s = i.writer.createContainerElement('figure', { class: 'table' }),
                a = i.writer.createContainerElement('table');
              let l;
              var c, d;
              i.writer.insert(i.writer.createPositionAt(s, 0), a),
                r &&
                  ((c = s),
                  (d = i.writer).setCustomProperty('table', !0, c),
                  (l = pu(c, d, { hasSelectionHandle: !0 })));
              const h = new Mp(n),
                u = {
                  headingRows: n.getAttribute('headingRows') || 0,
                  headingColumns: n.getAttribute('headingColumns') || 0,
                },
                g = new Map();
              for (const e of h) {
                const { row: o, cell: r } = e,
                  s = nb(ib(o, u), a, i),
                  l = n.getChild(o),
                  c = g.get(o) || eb(l, o, s, i);
                g.set(o, c), i.consumable.consume(r, 'insert');
                tb(e, u, i.writer.createPositionAt(c, 'end'), i, t);
              }
              const m = i.mapper.toViewPosition(o.range.start);
              i.mapper.bindElements(n, r ? l : s), i.writer.insert(m, r ? l : s);
            });
        }
        function $p(t = {}) {
          return e =>
            e.on('insert:tableRow', (e, o, i) => {
              const n = o.item;
              if (!i.consumable.consume(n, 'insert')) return;
              const r = n.parent,
                s = lb(i.mapper.toViewElement(r)),
                a = r.getChildIndex(n),
                l = new Mp(r, { startRow: a, endRow: a }),
                c = {
                  headingRows: r.getAttribute('headingRows') || 0,
                  headingColumns: r.getAttribute('headingColumns') || 0,
                },
                d = new Map();
              for (const e of l) {
                const o = nb(ib(a, c), s, i),
                  r = d.get(a) || eb(n, a, o, i);
                d.set(a, r), i.consumable.consume(e.cell, 'insert');
                tb(e, c, i.writer.createPositionAt(r, 'end'), i, t);
              }
            });
        }
        function Qp(t = {}) {
          return e =>
            e.on('insert:tableCell', (e, o, i) => {
              const n = o.item;
              if (!i.consumable.consume(n, 'insert')) return;
              const r = n.parent,
                s = r.parent,
                a = s.getChildIndex(r),
                l = new Mp(s, { startRow: a, endRow: a }),
                c = {
                  headingRows: s.getAttribute('headingRows') || 0,
                  headingColumns: s.getAttribute('headingColumns') || 0,
                };
              for (const e of l)
                if (e.cell === n) {
                  const o = i.mapper.toViewElement(r);
                  return void tb(e, c, i.writer.createPositionAt(o, r.getChildIndex(n)), i, t);
                }
            });
        }
        function Kp(t = {}) {
          const e = !!t.asWidget;
          return t =>
            t.on('attribute:headingRows:table', (t, o, i) => {
              const n = o.item;
              if (!i.consumable.consume(o.item, t.name)) return;
              const r = lb(i.mapper.toViewElement(n)),
                s = o.attributeOldValue,
                a = o.attributeNewValue;
              if (a > s) {
                const t = Array.from(n.getChildren()).filter(({ index: t }) => l(t, s - 1, a));
                ab(t, nb('thead', r, i), i, 'end');
                for (const o of t) for (const t of o.getChildren()) Zp(t, 'th', i, e);
              } else {
                ab(
                  Array.from(n.getChildren())
                    .filter(({ index: t }) => l(t, a - 1, s))
                    .reverse(),
                  nb('tbody', r, i),
                  i,
                  0
                );
                const t = new Mp(n, { startRow: a ? a - 1 : a, endRow: s - 1 }),
                  o = {
                    headingRows: n.getAttribute('headingRows') || 0,
                    headingColumns: n.getAttribute('headingColumns') || 0,
                  };
                for (const n of t) Xp(n, o, i, e);
              }
              function l(t, e, o) {
                return t > e && t < o;
              }
              sb('thead', r, i), sb('tbody', r, i);
            });
        }
        function Jp(t = {}) {
          const e = !!t.asWidget;
          return t =>
            t.on('attribute:headingColumns:table', (t, o, i) => {
              const n = o.item;
              if (!i.consumable.consume(o.item, t.name)) return;
              const r = {
                  headingRows: n.getAttribute('headingRows') || 0,
                  headingColumns: n.getAttribute('headingColumns') || 0,
                },
                s = o.attributeOldValue,
                a = o.attributeNewValue,
                l = (s > a ? s : a) - 1;
              for (const t of new Mp(n)) t.column > l || Xp(t, r, i, e);
            });
        }
        function Zp(t, e, o, i) {
          const n = o.writer,
            r = o.mapper.toViewElement(t);
          if (!r) return;
          let s;
          if (i) {
            (s = wu(n.createEditableElement(e, r.getAttributes()), n)),
              n.insert(n.createPositionAfter(r), s),
              n.move(n.createRangeIn(r), n.createPositionAt(s, 0)),
              n.remove(n.createRangeOn(r));
          } else s = n.rename(e, r);
          o.mapper.unbindViewElement(r), o.mapper.bindElements(t, s);
        }
        function Xp(t, e, o, i) {
          const { cell: n } = t,
            r = ob(t, e),
            s = o.mapper.toViewElement(n);
          s && s.name !== r && Zp(n, r, o, i);
        }
        function tb(t, e, o, i, n) {
          const r = n && n.asWidget,
            s = ob(t, e),
            a = r ? wu(i.writer.createEditableElement(s), i.writer) : i.writer.createContainerElement(s),
            l = t.cell,
            c = l.getChild(0),
            d = 1 === l.childCount && 'paragraph' === c.name;
          if ((i.writer.insert(o, a), d && ![...c.getAttributeKeys()].length)) {
            const t = l.getChild(0),
              e = i.writer.createPositionAt(a, 'end');
            if ((i.consumable.consume(t, 'insert'), n.asWidget)) {
              const o = i.writer.createContainerElement('span', { style: 'display:inline-block' });
              i.mapper.bindElements(t, o), i.writer.insert(e, o), i.mapper.bindElements(l, a);
            } else i.mapper.bindElements(l, a), i.mapper.bindElements(t, a);
          } else i.mapper.bindElements(l, a);
        }
        function eb(t, e, o, i) {
          i.consumable.consume(t, 'insert');
          const n = i.writer.createContainerElement('tr');
          i.mapper.bindElements(t, n);
          const r = t.parent.getAttribute('headingRows') || 0,
            s = r > 0 && e >= r ? e - r : e,
            a = i.writer.createPositionAt(o, s);
          return i.writer.insert(a, n), n;
        }
        function ob(t, e) {
          const { row: o, column: i } = t,
            { headingColumns: n, headingRows: r } = e;
          if (r && r > o) return 'th';
          return n && n > i ? 'th' : 'td';
        }
        function ib(t, e) {
          return t < e.headingRows ? 'thead' : 'tbody';
        }
        function nb(t, e, o) {
          const i = rb(t, e);
          return (
            i ||
            (function (t, e, o) {
              const i = o.writer.createContainerElement(t),
                n = o.writer.createPositionAt(e, 'tbody' == t ? 'end' : 0);
              return o.writer.insert(n, i), i;
            })(t, e, o)
          );
        }
        function rb(t, e) {
          for (const o of e.getChildren()) if (o.name == t) return o;
        }
        function sb(t, e, o) {
          const i = rb(t, e);
          i && 0 === i.childCount && o.writer.remove(o.writer.createRangeOn(i));
        }
        function ab(t, e, o, i) {
          for (const n of t) {
            const t = o.mapper.toViewElement(n);
            t && o.writer.move(o.writer.createRangeOn(t), o.writer.createPositionAt(e, i));
          }
        }
        function lb(t) {
          for (const e of t.getChildren()) if ('table' === e.name) return e;
        }
        class cb extends Uc {
          refresh() {
            const t = this.editor.model,
              e = t.document.selection,
              o = t.schema,
              i = (function (t) {
                const e = t.parent;
                return e === e.root ? e : e.parent;
              })(e.getFirstPosition());
            this.isEnabled = o.checkChild(i, 'table');
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document.selection,
              i = this.editor.plugins.get('TableUtils'),
              n = parseInt(t.rows) || 2,
              r = parseInt(t.columns) || 2,
              s = ku(o, e);
            e.change(t => {
              const o = i.createTable(t, n, r);
              e.insertContent(o, s), t.setSelection(t.createPositionAt(o.getNodeByPath([0, 0, 0]), 0));
            });
          }
        }
        class db extends Uc {
          constructor(t, e = {}) {
            super(t), (this.order = e.order || 'below');
          }
          refresh() {
            const t = vp('table', this.editor.model.document.selection.getFirstPosition());
            this.isEnabled = !!t;
          }
          execute() {
            const t = this.editor,
              e = t.model.document.selection,
              o = t.plugins.get('TableUtils'),
              i = 'above' === this.order,
              n = Dp(e),
              r = zp(n),
              s = i ? r.first : r.last,
              a = vp('table', n[0]);
            o.insertRows(a, { at: i ? s : s + 1, copyStructureFromAbove: !i });
          }
        }
        class hb extends Uc {
          constructor(t, e = {}) {
            super(t), (this.order = e.order || 'right');
          }
          refresh() {
            const t = vp('table', this.editor.model.document.selection.getFirstPosition());
            this.isEnabled = !!t;
          }
          execute() {
            const t = this.editor,
              e = t.model.document.selection,
              o = t.plugins.get('TableUtils'),
              i = 'left' === this.order,
              n = Dp(e),
              r = Lp(n),
              s = i ? r.first : r.last,
              a = vp('table', n[0]);
            o.insertColumns(a, { columns: 1, at: i ? s : s + 1 });
          }
        }
        class ub extends Uc {
          constructor(t, e = {}) {
            super(t), (this.direction = e.direction || 'horizontally');
          }
          refresh() {
            const t = Dp(this.editor.model.document.selection);
            this.isEnabled = 1 === t.length;
          }
          execute() {
            const t = Dp(this.editor.model.document.selection)[0],
              e = 'horizontally' === this.direction,
              o = this.editor.plugins.get('TableUtils');
            e ? o.splitCellHorizontally(t, 2) : o.splitCellVertically(t, 2);
          }
        }
        class gb extends Uc {
          constructor(t, e) {
            super(t),
              (this.direction = e.direction),
              (this.isHorizontal = 'right' == this.direction || 'left' == this.direction);
          }
          refresh() {
            const t = this._getMergeableCell();
            (this.value = t), (this.isEnabled = !!t);
          }
          execute() {
            const t = this.editor.model,
              e = Vp(t.document.selection)[0],
              o = this.value,
              i = this.direction;
            t.change(t => {
              const n = 'right' == i || 'down' == i,
                r = n ? e : o,
                s = n ? o : e,
                a = s.parent;
              !(function (t, e, o) {
                mb(t) ||
                  (mb(e) && o.remove(o.createRangeIn(e)), o.move(o.createRangeIn(t), o.createPositionAt(e, 'end')));
                o.remove(t);
              })(s, r, t);
              const l = this.isHorizontal ? 'colspan' : 'rowspan',
                c = parseInt(e.getAttribute(l) || 1),
                d = parseInt(o.getAttribute(l) || 1);
              if ((t.setAttribute(l, c + d, r), t.setSelection(t.createRangeIn(r)), !a.childCount)) {
                const e = this.editor.plugins.get('TableUtils'),
                  o = vp('table', a);
                e.removeRows(o, { at: a.index, batch: t.batch });
              }
            });
          }
          _getMergeableCell() {
            const t = Vp(this.editor.model.document.selection)[0];
            if (!t) return;
            const e = this.editor.plugins.get('TableUtils'),
              o = this.isHorizontal
                ? (function (t, e, o) {
                    const i = t.parent.parent,
                      n = 'right' == e ? t.nextSibling : t.previousSibling,
                      r = (i.getAttribute('headingColumns') || 0) > 0;
                    if (!n) return;
                    const s = 'right' == e ? t : n,
                      a = 'right' == e ? n : t,
                      { column: l } = o.getCellLocation(s),
                      { column: c } = o.getCellLocation(a),
                      d = parseInt(s.getAttribute('colspan') || 1),
                      h = Tp(o, s),
                      u = Tp(o, a);
                    if (r && h != u) return;
                    return l + d === c ? n : void 0;
                  })(t, this.direction, e)
                : (function (t, e) {
                    const o = t.parent,
                      i = o.parent,
                      n = i.getChildIndex(o);
                    if (('down' == e && n === i.childCount - 1) || ('up' == e && 0 === n)) return;
                    const r = parseInt(t.getAttribute('rowspan') || 1),
                      s = i.getAttribute('headingRows') || 0,
                      a = 'down' == e && n + r === s,
                      l = 'up' == e && n === s;
                    if (s && (a || l)) return;
                    const c = parseInt(t.getAttribute('rowspan') || 1),
                      d = 'down' == e ? n + c : n,
                      h = [...new Mp(i, { endRow: d })],
                      u = h.find(e => e.cell === t).column,
                      g = h.find(
                        ({ row: t, rowspan: o, column: i }) => i === u && ('down' == e ? t === d : d === t + o)
                      );
                    return g && g.cell;
                  })(t, this.direction);
            if (!o) return;
            const i = this.isHorizontal ? 'rowspan' : 'colspan',
              n = parseInt(t.getAttribute(i) || 1);
            return parseInt(o.getAttribute(i) || 1) === n ? o : void 0;
          }
        }
        function mb(t) {
          return 1 == t.childCount && t.getChild(0).is('paragraph') && t.getChild(0).isEmpty;
        }
        class fb extends Uc {
          refresh() {
            const t = Dp(this.editor.model.document.selection),
              e = t[0];
            if (e) {
              const o = vp('table', e),
                i = this.editor.plugins.get('TableUtils').getRows(o) - 1,
                n = zp(t),
                r = 0 === n.first && n.last === i;
              this.isEnabled = !r;
            } else this.isEnabled = !1;
          }
          execute() {
            const t = this.editor.model,
              e = Dp(t.document.selection),
              o = zp(e),
              i = e[0],
              n = vp('table', i),
              r = this.editor.plugins.get('TableUtils').getCellLocation(i).column,
              s = t.createBatch();
            t.enqueueChange(s, t => {
              t.setSelection(t.createSelection(n, 'on'));
              const e = o.last - o.first + 1;
              this.editor.plugins.get('TableUtils').removeRows(n, { at: o.first, rows: e, batch: s });
            }),
              t.enqueueChange(s, t => {
                const e = (function (t, e, o) {
                  const i = t.getChild(e) || t.getChild(t.childCount - 1);
                  let n = i.getChild(0),
                    r = 0;
                  for (const t of i.getChildren()) {
                    if (r > o) return n;
                    (n = t), (r += parseInt(t.getAttribute('colspan') || 1));
                  }
                  return n;
                })(n, o.first, r);
                t.setSelection(t.createPositionAt(e, 0));
              });
          }
        }
        class pb extends Uc {
          refresh() {
            const t = Dp(this.editor.model.document.selection),
              e = t[0];
            if (e) {
              const o = vp('table', e),
                i = this.editor.plugins.get('TableUtils').getColumns(o),
                { first: n, last: r } = Lp(t);
              this.isEnabled = r - n < i - 1;
            } else this.isEnabled = !1;
          }
          execute() {
            const [t, e] = (function (t) {
                const e = Dp(t),
                  o = e[0],
                  i = e.pop(),
                  n = [o, i];
                return o.isBefore(i) ? n : n.reverse();
              })(this.editor.model.document.selection),
              o = t.parent.parent,
              i = [...new Mp(o)],
              n = { first: i.find(e => e.cell === t).column, last: i.find(t => t.cell === e).column },
              r = (function (t, e, o, i) {
                return parseInt(o.getAttribute('colspan') || 1) > 1
                  ? o
                  : e.previousSibling || o.nextSibling
                  ? o.nextSibling || e.previousSibling
                  : i.first
                  ? t.reverse().find(({ column: t }) => t < i.first).cell
                  : t.reverse().find(({ column: t }) => t > i.last).cell;
              })(i, t, e, n);
            this.editor.model.change(t => {
              const e = n.last - n.first + 1;
              this.editor.plugins.get('TableUtils').removeColumns(o, { at: n.first, columns: e }),
                t.setSelection(t.createPositionAt(r, 0));
            });
          }
        }
        class bb extends Uc {
          refresh() {
            const t = Dp(this.editor.model.document.selection),
              e = t.length > 0;
            (this.isEnabled = e), (this.value = e && t.every(t => this._isInHeading(t, t.parent.parent)));
          }
          execute(t = {}) {
            if (t.forceValue === this.value) return;
            const e = this.editor.model,
              o = Dp(e.document.selection),
              i = vp('table', o[0]),
              { first: n, last: r } = zp(o),
              s = this.value ? n : r + 1,
              a = i.getAttribute('headingRows') || 0;
            e.change(t => {
              if (s) {
                const e = Bp(i, s, s > a ? a : 0);
                for (const { cell: o } of e) Fp(o, s, t);
              }
              yp('headingRows', s, i, t, 0);
            });
          }
          _isInHeading(t, e) {
            const o = parseInt(e.getAttribute('headingRows') || 0);
            return !!o && t.parent.index < o;
          }
        }
        class wb extends Uc {
          refresh() {
            const t = Dp(this.editor.model.document.selection),
              e = this.editor.plugins.get('TableUtils'),
              o = t.length > 0;
            (this.isEnabled = o), (this.value = o && t.every(t => Tp(e, t)));
          }
          execute(t = {}) {
            if (t.forceValue === this.value) return;
            const e = this.editor.model,
              o = Dp(e.document.selection),
              i = vp('table', o[0]),
              { first: n, last: r } = Lp(o),
              s = this.value ? n : r + 1;
            e.change(t => {
              if (s) {
                const e = Hp(i, s);
                for (const { cell: o, column: i } of e) Wp(o, i, s, t);
              }
              yp('headingColumns', s, i, t, 0);
            });
          }
        }
        class kb extends Hc {
          static get pluginName() {
            return 'TableUtils';
          }
          getCellLocation(t) {
            const e = t.parent,
              o = e.parent,
              i = o.getChildIndex(e),
              n = new Mp(o, { startRow: i, endRow: i });
            for (const { cell: e, row: o, column: i } of n) if (e === t) return { row: o, column: i };
          }
          createTable(t, e, o) {
            const i = t.createElement('table');
            return _b(t, i, 0, e, o), i;
          }
          insertRows(t, e = {}) {
            const o = this.editor.model,
              i = e.at || 0,
              n = e.rows || 1,
              r = void 0 !== e.copyStructureFromAbove,
              s = e.copyStructureFromAbove ? i - 1 : i,
              a = this.getRows(t),
              l = this.getColumns(t);
            o.change(e => {
              const o = t.getAttribute('headingRows') || 0;
              if ((o > i && e.setAttribute('headingRows', o + n, t), !r && (0 === i || i === a)))
                return void _b(e, t, i, n, l);
              const c = r ? Math.max(i, s) : i,
                d = new Mp(t, { endRow: c }),
                h = new Array(l).fill(1);
              for (const { row: t, column: o, rowspan: a, colspan: l, cell: c } of d) {
                const d = t + a - 1,
                  u = t <= s && s <= d;
                t < i && i <= d ? (e.setAttribute('rowspan', a + n, c), (h[o] = -l)) : r && u && (h[o] = l);
              }
              for (let o = 0; o < n; o++) {
                const o = e.createElement('tableRow');
                e.insert(o, t, i);
                for (let t = 0; t < h.length; t++) {
                  const i = h[t],
                    n = e.createPositionAt(o, 'end');
                  i > 0 && xp(e, n, i > 1 ? { colspan: i } : null), (t += Math.abs(i) - 1);
                }
              }
            });
          }
          insertColumns(t, e = {}) {
            const o = this.editor.model,
              i = e.at || 0,
              n = e.columns || 1;
            o.change(e => {
              const o = t.getAttribute('headingColumns');
              i < o && e.setAttribute('headingColumns', o + n, t);
              const r = this.getColumns(t);
              if (0 === i || r === i) {
                for (const o of t.getChildren()) vb(n, e, e.createPositionAt(o, i ? 'end' : 0));
                return;
              }
              const s = new Mp(t, { column: i, includeSpanned: !0 });
              for (const { row: o, cell: r, cellIndex: a } of s) {
                const l = parseInt(r.getAttribute('rowspan') || 1),
                  c = parseInt(r.getAttribute('colspan') || 1);
                if (a !== i && c > 1) {
                  if ((e.setAttribute('colspan', c + n, r), s.skipRow(o), l > 1))
                    for (let t = o + 1; t < o + l; t++) s.skipRow(t);
                } else {
                  const i = e.createPositionAt(t.getChild(o), a);
                  vb(n, e, i);
                }
              }
            });
          }
          removeRows(t, e) {
            const o = this.editor.model,
              i = e.rows || 1,
              n = e.at,
              r = n + i - 1,
              s = e.batch || 'default';
            o.enqueueChange(s, e => {
              const { cellsToMove: i, cellsToTrim: a } = (function (t, e, o) {
                const i = new Map(),
                  n = [];
                for (const { row: r, column: s, rowspan: a, cell: l } of new Mp(t, { endRow: o })) {
                  const t = r + a - 1;
                  if (r >= e && r <= o && t > o) {
                    const t = a - (o - r + 1);
                    i.set(s, { cell: l, rowspan: t });
                  }
                  if (r < e && t >= e) {
                    let i;
                    (i = t >= o ? o - e + 1 : t - e + 1), n.push({ cell: l, rowspan: a - i });
                  }
                }
                return { cellsToMove: i, cellsToTrim: n };
              })(t, n, r);
              if (i.size) {
                !(function (t, e, o, i) {
                  const n = [...new Mp(t, { includeSpanned: !0, startRow: e, endRow: e })],
                    r = t.getChild(e);
                  let s;
                  for (const { column: t, cell: e, isSpanned: a } of n)
                    if (o.has(t)) {
                      const { cell: e, rowspan: n } = o.get(t),
                        a = s ? i.createPositionAfter(s) : i.createPositionAt(r, 0);
                      i.move(i.createRangeOn(e), a), yp('rowspan', n, e, i), (s = e);
                    } else a || (s = e);
                })(t, r + 1, i, e);
              }
              for (let o = r; o >= n; o--) e.remove(t.getChild(o));
              for (const { rowspan: t, cell: o } of a) yp('rowspan', t, o, e);
              !(function (t, e, o, i, n) {
                i.enqueueChange(n, i => {
                  const n = t.getAttribute('headingRows') || 0;
                  if (e < n) {
                    yp('headingRows', o < n ? n - (o - e + 1) : e, t, i, 0);
                  }
                });
              })(t, n, r, o, s);
            });
          }
          removeColumns(t, e) {
            const o = this.editor.model,
              i = e.at,
              n = e.columns || 1,
              r = e.at + n - 1;
            o.change(e => {
              !(function (t, e, o) {
                const i = t.getAttribute('headingColumns') || 0;
                if (i && e.first < i) {
                  const n = Math.min(i - 1, e.last) - e.first + 1;
                  o.setAttribute('headingColumns', i - n, t);
                }
              })(t, { first: i, last: r }, e);
              const o = [];
              for (let n = r; n >= i; n--)
                for (const { cell: i, column: r, colspan: s } of [...new Mp(t)])
                  if (r <= n && s > 1 && r + s > n) yp('colspan', s - 1, i, e);
                  else if (r === n) {
                    const t = i.parent;
                    e.remove(i), t.childCount || o.push(t.index);
                  }
              o.reverse().forEach(o => this.removeRows(t, { at: o, batch: e.batch }));
            });
          }
          splitCellVertically(t, e = 2) {
            const o = this.editor.model,
              i = t.parent.parent,
              n = parseInt(t.getAttribute('rowspan') || 1),
              r = parseInt(t.getAttribute('colspan') || 1);
            o.change(o => {
              if (r > 1) {
                const { newCellsSpan: i, updatedSpan: s } = yb(r, e);
                yp('colspan', s, t, o);
                const a = {};
                i > 1 && (a.colspan = i), n > 1 && (a.rowspan = n);
                vb(r > e ? e - 1 : r - 1, o, o.createPositionAfter(t), a);
              }
              if (r < e) {
                const s = e - r,
                  a = [...new Mp(i)],
                  { column: l } = a.find(({ cell: e }) => e === t),
                  c = a.filter(({ cell: e, colspan: o, column: i }) => (e !== t && i === l) || (i < l && i + o > l));
                for (const { cell: t, colspan: e } of c) o.setAttribute('colspan', e + s, t);
                const d = {};
                n > 1 && (d.rowspan = n), vb(s, o, o.createPositionAfter(t), d);
                const h = i.getAttribute('headingColumns') || 0;
                h > l && yp('headingColumns', h + s, i, o);
              }
            });
          }
          splitCellHorizontally(t, e = 2) {
            const o = this.editor.model,
              i = t.parent,
              n = i.parent,
              r = n.getChildIndex(i),
              s = parseInt(t.getAttribute('rowspan') || 1),
              a = parseInt(t.getAttribute('colspan') || 1);
            o.change(o => {
              if (s > 1) {
                const i = [...new Mp(n, { startRow: r, endRow: r + s - 1, includeSpanned: !0 })],
                  { newCellsSpan: l, updatedSpan: c } = yb(s, e);
                yp('rowspan', c, t, o);
                const { column: d } = i.find(({ cell: e }) => e === t),
                  h = {};
                l > 1 && (h.rowspan = l), a > 1 && (h.colspan = a);
                for (const { column: t, row: e, cellIndex: s } of i) {
                  const i = t === d,
                    a = (e + r + c) % l == 0;
                  if (e >= r + c && i && a) {
                    const t = o.createPositionAt(n.getChild(e), s);
                    vb(1, o, t, h);
                  }
                }
              }
              if (s < e) {
                const i = e - s,
                  l = [...new Mp(n, { startRow: 0, endRow: r })];
                for (const { cell: e, rowspan: n, row: s } of l)
                  if (e !== t && s + n > r) {
                    const t = n + i;
                    o.setAttribute('rowspan', t, e);
                  }
                const c = {};
                a > 1 && (c.colspan = a), _b(o, n, r + 1, i, 1, c);
                const d = n.getAttribute('headingRows') || 0;
                d > r && yp('headingRows', d + i, n, o);
              }
            });
          }
          getColumns(t) {
            return [...t.getChild(0).getChildren()].reduce((t, e) => t + parseInt(e.getAttribute('colspan') || 1), 0);
          }
          getRows(t) {
            return t.childCount;
          }
        }
        function _b(t, e, o, i, n, r = {}) {
          for (let s = 0; s < i; s++) {
            const i = t.createElement('tableRow');
            t.insert(i, e, o), vb(n, t, t.createPositionAt(i, 'end'), r);
          }
        }
        function vb(t, e, o, i = {}) {
          for (let n = 0; n < t; n++) xp(e, o, i);
        }
        function yb(t, e) {
          if (t < e) return { newCellsSpan: 1, updatedSpan: 1 };
          const o = Math.floor(t / e);
          return { newCellsSpan: o, updatedSpan: t - o * e + o };
        }
        class xb extends Uc {
          refresh() {
            const t = Op(this.editor.model.document.selection);
            this.isEnabled = jp(t, this.editor.plugins.get(kb));
          }
          execute() {
            const t = this.editor.model,
              e = this.editor.plugins.get(kb);
            t.change(o => {
              const i = Op(t.document.selection),
                n = i.shift();
              o.setSelection(n, 0);
              const { mergeWidth: r, mergeHeight: s } = (function (t, e, o) {
                let i = 0,
                  n = 0;
                for (const t of e) {
                  const { row: e, column: r } = o.getCellLocation(t);
                  (i = Tb(t, r, i, 'colspan')), (n = Tb(t, e, n, 'rowspan'));
                }
                const { row: r, column: s } = o.getCellLocation(t);
                return { mergeWidth: i - s, mergeHeight: n - r };
              })(n, i, e);
              yp('colspan', r, n, o), yp('rowspan', s, n, o);
              const a = [];
              for (const t of i) {
                const e = t.parent;
                Cb(t, n, o), e.childCount || a.push(e.index);
              }
              if (a.length) {
                const t = vp('table', n);
                a.reverse().forEach(i => e.removeRows(t, { at: i, batch: o.batch }));
              }
              o.setSelection(n, 'in');
            });
          }
        }
        function Cb(t, e, o) {
          Ab(t) || (Ab(e) && o.remove(o.createRangeIn(e)), o.move(o.createRangeIn(t), o.createPositionAt(e, 'end'))),
            o.remove(t);
        }
        function Ab(t) {
          return 1 == t.childCount && t.getChild(0).is('paragraph') && t.getChild(0).isEmpty;
        }
        function Tb(t, e, o, i) {
          const n = parseInt(t.getAttribute(i) || 1);
          return Math.max(o, e + n);
        }
        class Sb extends Uc {
          refresh() {
            const t = Dp(this.editor.model.document.selection);
            this.isEnabled = t.length > 0;
          }
          execute() {
            const t = this.editor.model,
              e = Dp(t.document.selection),
              o = zp(e),
              i = vp('table', e[0]),
              n = [];
            for (let e = o.first; e <= o.last; e++)
              for (const o of i.getChild(e).getChildren()) n.push(t.createRangeOn(o));
            t.change(t => {
              t.setSelection(n);
            });
          }
        }
        class Pb extends Uc {
          refresh() {
            const t = Dp(this.editor.model.document.selection);
            this.isEnabled = t.length > 0;
          }
          execute() {
            const t = this.editor.model,
              e = Dp(t.document.selection),
              o = e[0],
              i = e.pop(),
              n = this.editor.plugins.get('TableUtils'),
              r = n.getCellLocation(o),
              s = n.getCellLocation(i),
              a = Math.min(r.column, s.column),
              l = Math.max(r.column, s.column),
              c = [];
            for (const e of new Mp(vp('table', o))) e.column >= a && e.column <= l && c.push(t.createRangeOn(e.cell));
            t.change(t => {
              t.setSelection(c);
            });
          }
        }
        function Eb(t) {
          t.document.registerPostFixer(e =>
            (function (t, e) {
              const o = e.document.differ.getChanges();
              let i = !1;
              const n = new Set();
              for (const e of o) {
                let o;
                'table' == e.name && 'insert' == e.type && (o = e.position.nodeAfter),
                  ('tableRow' != e.name && 'tableCell' != e.name) || (o = vp('table', e.position)),
                  Nb(e) && (o = vp('table', e.range.start)),
                  o && !n.has(o) && ((i = Mb(o, t) || i), (i = Ib(o, t) || i), n.add(o));
              }
              return i;
            })(e, t)
          );
        }
        function Mb(t, e) {
          let o = !1;
          const i = (function (t) {
            const e = parseInt(t.getAttribute('headingRows') || 0),
              o = t.childCount,
              i = [];
            for (const { row: n, rowspan: r, cell: s } of new Mp(t)) {
              if (r < 2) continue;
              const t = n < e ? e : o;
              if (n + r > t) {
                const e = t - n;
                i.push({ cell: s, rowspan: e });
              }
            }
            return i;
          })(t);
          if (i.length) {
            o = !0;
            for (const t of i) yp('rowspan', t.rowspan, t.cell, e, 1);
          }
          return o;
        }
        function Ib(t, e) {
          let o = !1;
          const i = (function (t) {
              const e = new Array(t.childCount).fill(0);
              for (const { row: o } of new Mp(t, { includeSpanned: !0 })) e[o]++;
              return e;
            })(t),
            n = [];
          for (const [t, e] of i.entries()) e || n.push(t);
          if (n.length) {
            o = !0;
            for (const o of n.reverse()) e.remove(t.getChild(o)), i.splice(o, 1);
          }
          const r = i[0];
          if (!i.every(t => t === r)) {
            const n = i.reduce((t, e) => (e > t ? e : t), 0);
            for (const [r, s] of i.entries()) {
              const i = n - s;
              if (i) {
                for (let o = 0; o < i; o++) xp(e, e.createPositionAt(t.getChild(r), 'end'));
                o = !0;
              }
            }
          }
          return o;
        }
        function Nb(t) {
          const e = 'attribute' === t.type,
            o = t.attributeKey;
          return e && ('headingRows' === o || 'colspan' === o || 'rowspan' === o);
        }
        function Rb(t) {
          t.document.registerPostFixer(e =>
            (function (t, e) {
              const o = e.document.differ.getChanges();
              let i = !1;
              for (const e of o)
                'insert' == e.type && 'table' == e.name && (i = Ob(e.position.nodeAfter, t) || i),
                  'insert' == e.type && 'tableRow' == e.name && (i = Vb(e.position.nodeAfter, t) || i),
                  'insert' == e.type && 'tableCell' == e.name && (i = Db(e.position.nodeAfter, t) || i),
                  zb(e) && (i = Db(e.position.parent, t) || i);
              return i;
            })(e, t)
          );
        }
        function Ob(t, e) {
          let o = !1;
          for (const i of t.getChildren()) o = Vb(i, e) || o;
          return o;
        }
        function Vb(t, e) {
          let o = !1;
          for (const i of t.getChildren()) o = Db(i, e) || o;
          return o;
        }
        function Db(t, e) {
          if (0 == t.childCount) return e.insertElement('paragraph', t), !0;
          const o = Array.from(t.getChildren()).filter(t => t.is('text'));
          for (const t of o) e.wrap(e.createRangeOn(t), 'paragraph');
          return !!o.length;
        }
        function zb(t) {
          return (
            !(!t.position || !t.position.parent.is('tableCell')) &&
            (('insert' == t.type && '$text' == t.name) || 'remove' == t.type)
          );
        }
        function Lb(t) {
          t.document.registerPostFixer(() =>
            (function (t) {
              const e = t.document.differ,
                o = new Set();
              let i = 0;
              for (const t of e.getChanges()) {
                const e = 'insert' == t.type || 'remove' == t.type ? t.position.parent : t.range.start.parent;
                e.is('tableCell') && ('insert' == t.type && i++, jb(e, t.type, i) && o.add(e));
              }
              if (o.size) {
                for (const t of o.values()) e.refreshItem(t);
                return !0;
              }
              return !1;
            })(t)
          );
        }
        function jb(t, e, o) {
          if (!Array.from(t.getChildren()).some(t => t.is('paragraph'))) return !1;
          if ('attribute' == e) {
            const e = Array.from(t.getChild(0).getAttributeKeys()).length;
            return 1 === t.childCount && e < 2;
          }
          return t.childCount <= ('insert' == e ? o + 1 : 1);
        }
        o(98);
        class Bb extends Hc {
          static get pluginName() {
            return 'TableEditing';
          }
          init() {
            const t = this.editor,
              e = t.model,
              o = e.schema,
              i = t.conversion;
            o.register('table', {
              allowWhere: '$block',
              allowAttributes: ['headingRows', 'headingColumns'],
              isLimit: !0,
              isObject: !0,
              isBlock: !0,
            }),
              o.register('tableRow', { allowIn: 'table', isLimit: !0 }),
              o.register('tableCell', { allowIn: 'tableRow', allowAttributes: ['colspan', 'rowspan'], isObject: !0 }),
              o.extend('$block', { allowIn: 'tableCell' }),
              o.addChildCheck((t, e) => {
                if ('table' == e.name && Array.from(t.getNames()).includes('table')) return !1;
              }),
              i.for('upcast').add(Sp()),
              i.for('editingDowncast').add(Yp({ asWidget: !0 })),
              i.for('dataDowncast').add(Yp()),
              i.for('upcast').elementToElement({ model: 'tableRow', view: 'tr' }),
              i.for('upcast').add(t => {
                t.on(
                  'element:tr',
                  (t, e) => {
                    e.viewItem.isEmpty && t.stop();
                  },
                  { priority: 'high' }
                );
              }),
              i.for('editingDowncast').add($p({ asWidget: !0 })),
              i.for('dataDowncast').add($p()),
              i.for('downcast').add(t =>
                t.on(
                  'remove:tableRow',
                  (t, e, o) => {
                    t.stop();
                    const i = o.writer,
                      n = o.mapper,
                      r = n.toViewPosition(e.position).getLastMatchingPosition(t => !t.item.is('tr')).nodeAfter,
                      s = r.parent.parent,
                      a = i.createRangeOn(r),
                      l = i.remove(a);
                    for (const t of i.createRangeIn(l).getItems()) n.unbindViewElement(t);
                    sb('thead', s, o), sb('tbody', s, o);
                  },
                  { priority: 'higher' }
                )
              ),
              i.for('upcast').add(Pp('td')),
              i.for('upcast').add(Pp('th')),
              i.for('editingDowncast').add(Qp({ asWidget: !0 })),
              i.for('dataDowncast').add(Qp()),
              i.attributeToAttribute({ model: 'colspan', view: 'colspan' }),
              i.attributeToAttribute({ model: 'rowspan', view: 'rowspan' }),
              i.for('editingDowncast').add(Jp({ asWidget: !0 })),
              i.for('dataDowncast').add(Jp()),
              i.for('editingDowncast').add(Kp({ asWidget: !0 })),
              i.for('dataDowncast').add(Kp()),
              t.commands.add('insertTable', new cb(t)),
              t.commands.add('insertTableRowAbove', new db(t, { order: 'above' })),
              t.commands.add('insertTableRowBelow', new db(t, { order: 'below' })),
              t.commands.add('insertTableColumnLeft', new hb(t, { order: 'left' })),
              t.commands.add('insertTableColumnRight', new hb(t, { order: 'right' })),
              t.commands.add('removeTableRow', new fb(t)),
              t.commands.add('removeTableColumn', new pb(t)),
              t.commands.add('splitTableCellVertically', new ub(t, { direction: 'vertically' })),
              t.commands.add('splitTableCellHorizontally', new ub(t, { direction: 'horizontally' })),
              t.commands.add('mergeTableCells', new xb(t)),
              t.commands.add('mergeTableCellRight', new gb(t, { direction: 'right' })),
              t.commands.add('mergeTableCellLeft', new gb(t, { direction: 'left' })),
              t.commands.add('mergeTableCellDown', new gb(t, { direction: 'down' })),
              t.commands.add('mergeTableCellUp', new gb(t, { direction: 'up' })),
              t.commands.add('setTableColumnHeader', new wb(t)),
              t.commands.add('setTableRowHeader', new bb(t)),
              t.commands.add('selectTableRow', new Sb(t)),
              t.commands.add('selectTableColumn', new Pb(t)),
              Eb(e),
              Lb(e),
              Rb(e);
          }
          static get requires() {
            return [kb];
          }
        }
        o(100);
        class Fb extends sc {
          constructor(t) {
            super(t);
            const e = this.bindTemplate;
            (this.items = this._createGridCollection()),
              this.set('rows', 0),
              this.set('columns', 0),
              this.bind('label').to(this, 'columns', this, 'rows', (t, e) => `${e} × ${t}`),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck'] },
                children: [
                  {
                    tag: 'div',
                    attributes: { class: ['ck-insert-table-dropdown__grid'] },
                    on: { 'mouseover@.ck-insert-table-dropdown-grid-box': e.to('boxover') },
                    children: this.items,
                  },
                  {
                    tag: 'div',
                    attributes: { class: ['ck-insert-table-dropdown__label'] },
                    children: [{ text: e.to('label') }],
                  },
                ],
                on: {
                  mousedown: e.to(t => {
                    t.preventDefault();
                  }),
                  click: e.to(() => {
                    this.fire('execute');
                  }),
                },
              }),
              this.on('boxover', (t, e) => {
                const { row: o, column: i } = e.target.dataset;
                this.set({ rows: parseInt(o), columns: parseInt(i) });
              }),
              this.on('change:columns', () => {
                this._highlightGridBoxes();
              }),
              this.on('change:rows', () => {
                this._highlightGridBoxes();
              });
          }
          focus() {}
          focusLast() {}
          _highlightGridBoxes() {
            const t = this.rows,
              e = this.columns;
            this.items.map((o, i) => {
              const n = Math.floor(i / 10) < t && i % 10 < e;
              o.set('isOn', n);
            });
          }
          _createGridCollection() {
            const t = [];
            for (let e = 0; e < 100; e++) {
              const o = Math.floor(e / 10),
                i = e % 10;
              t.push(new Hb(this.locale, o + 1, i + 1));
            }
            return this.createCollection(t);
          }
        }
        class Hb extends sc {
          constructor(t, e, o) {
            super(t);
            const i = this.bindTemplate;
            this.set('isOn', !1),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck-insert-table-dropdown-grid-box', i.if('isOn', 'ck-on')],
                  'data-row': e,
                  'data-column': o,
                },
              });
          }
        }
        class Wb extends Hc {
          init() {
            const t = this.editor,
              e = this.editor.t,
              o = 'ltr' === t.locale.contentLanguageDirection;
            t.ui.componentFactory.add('insertTable', o => {
              const i = t.commands.get('insertTable'),
                n = Rc(o);
              let r;
              return (
                n.bind('isEnabled').to(i),
                n.buttonView.set({
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',
                  label: e('Insert table'),
                  tooltip: !0,
                }),
                n.on('change:isOpen', () => {
                  r ||
                    ((r = new Fb(o)),
                    n.panelView.children.add(r),
                    r.delegate('execute').to(n),
                    n.buttonView.on('open', () => {
                      (r.rows = 0), (r.columns = 0);
                    }),
                    n.on('execute', () => {
                      t.execute('insertTable', { rows: r.rows, columns: r.columns }), t.editing.view.focus();
                    }));
                }),
                n
              );
            }),
              t.ui.componentFactory.add('tableColumn', t => {
                const i = [
                  {
                    type: 'switchbutton',
                    model: { commandName: 'setTableColumnHeader', label: e('Header column'), bindIsOn: !0 },
                  },
                  { type: 'separator' },
                  {
                    type: 'button',
                    model: {
                      commandName: o ? 'insertTableColumnLeft' : 'insertTableColumnRight',
                      label: e('Insert column left'),
                    },
                  },
                  {
                    type: 'button',
                    model: {
                      commandName: o ? 'insertTableColumnRight' : 'insertTableColumnLeft',
                      label: e('Insert column right'),
                    },
                  },
                  { type: 'button', model: { commandName: 'removeTableColumn', label: e('Delete column') } },
                  { type: 'button', model: { commandName: 'selectTableColumn', label: e('Select column') } },
                ];
                return this._prepareDropdown(
                  e('Column'),
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>',
                  i,
                  t
                );
              }),
              t.ui.componentFactory.add('tableRow', t => {
                const o = [
                  {
                    type: 'switchbutton',
                    model: { commandName: 'setTableRowHeader', label: e('Header row'), bindIsOn: !0 },
                  },
                  { type: 'separator' },
                  { type: 'button', model: { commandName: 'insertTableRowAbove', label: e('Insert row above') } },
                  { type: 'button', model: { commandName: 'insertTableRowBelow', label: e('Insert row below') } },
                  { type: 'button', model: { commandName: 'removeTableRow', label: e('Delete row') } },
                  { type: 'button', model: { commandName: 'selectTableRow', label: e('Select row') } },
                ];
                return this._prepareDropdown(
                  e('Row'),
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>',
                  o,
                  t
                );
              }),
              t.ui.componentFactory.add('mergeTableCells', t => {
                const i = [
                  { type: 'button', model: { commandName: 'mergeTableCellUp', label: e('Merge cell up') } },
                  {
                    type: 'button',
                    model: {
                      commandName: o ? 'mergeTableCellRight' : 'mergeTableCellLeft',
                      label: e('Merge cell right'),
                    },
                  },
                  { type: 'button', model: { commandName: 'mergeTableCellDown', label: e('Merge cell down') } },
                  {
                    type: 'button',
                    model: {
                      commandName: o ? 'mergeTableCellLeft' : 'mergeTableCellRight',
                      label: e('Merge cell left'),
                    },
                  },
                  { type: 'separator' },
                  {
                    type: 'button',
                    model: { commandName: 'splitTableCellVertically', label: e('Split cell vertically') },
                  },
                  {
                    type: 'button',
                    model: { commandName: 'splitTableCellHorizontally', label: e('Split cell horizontally') },
                  },
                ];
                return this._prepareMergeSplitButtonDropdown(
                  e('Merge cells'),
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>',
                  i,
                  t
                );
              });
          }
          _prepareDropdown(t, e, o, i) {
            const n = this.editor,
              r = Rc(i),
              s = this._fillDropdownWithListOptions(r, o);
            return (
              r.buttonView.set({ label: t, icon: e, tooltip: !0 }),
              r.bind('isEnabled').toMany(s, 'isEnabled', (...t) => t.some(t => t)),
              this.listenTo(r, 'execute', t => {
                n.execute(t.source.commandName), n.editing.view.focus();
              }),
              r
            );
          }
          _prepareMergeSplitButtonDropdown(t, e, o, i) {
            const n = this.editor,
              r = Rc(i, tu);
            return (
              this._fillDropdownWithListOptions(r, o),
              r.buttonView.set({ label: t, icon: e, tooltip: !0, isEnabled: !0 }),
              this.listenTo(r.buttonView, 'execute', () => {
                n.execute('mergeTableCells'), n.editing.view.focus();
              }),
              this.listenTo(r, 'execute', t => {
                n.execute(t.source.commandName), n.editing.view.focus();
              }),
              r
            );
          }
          _fillDropdownWithListOptions(t, e) {
            const o = this.editor,
              i = [],
              n = new Co();
            for (const t of e) Ub(t, o, i, n);
            return Vc(t, n, o.ui.componentFactory), i;
          }
        }
        function Ub(t, e, o, i) {
          const n = (t.model = new Bh(t.model)),
            { commandName: r, bindIsOn: s } = t.model;
          if ('button' === t.type || 'switchbutton' === t.type) {
            const t = e.commands.get(r);
            o.push(t), n.set({ commandName: r }), n.bind('isEnabled').to(t), s && n.bind('isOn').to(t, 'value');
          }
          n.set({ withText: !0 }), i.add(t);
        }
        class qb extends Nr {
          constructor(t) {
            super(t), (this.domEventType = ['mousemove', 'mouseup', 'mouseleave']);
          }
          onDomEvent(t) {
            this.fire(t.type, t);
          }
        }
        function Gb(t, e, o, i) {
          const { startRow: n, startColumn: r, endRow: s, endColumn: a } = e,
            l = o.createElement('table'),
            c = s - n + 1;
          for (let t = 0; t < c; t++) o.insertElement('tableRow', l, 'end');
          const d = [...new Mp(t, { startRow: n, endRow: s, includeSpanned: !0 })];
          for (const { row: t, column: e, cell: c, isSpanned: h } of d) {
            if (e < r || e > a) continue;
            const d = t - n,
              u = l.getChild(d);
            if (h) {
              const { row: t, column: e } = i.getCellLocation(c);
              (t < n || e < r) && xp(o, o.createPositionAt(u, 'end'));
            } else {
              const i = c._clone(!0);
              o.append(i, u), Yb(i, t, e, s, a, o);
            }
          }
          return (
            (function (t, e, o, i, n) {
              const r = parseInt(e.getAttribute('headingRows') || 0);
              if (r > 0) {
                yp('headingRows', r - o, t, n, 0);
              }
              const s = parseInt(e.getAttribute('headingColumns') || 0);
              if (s > 0) {
                yp('headingColumns', s - i, t, n, 0);
              }
            })(l, t, n, r, o),
            l
          );
        }
        function Yb(t, e, o, i, n, r) {
          const s = parseInt(t.getAttribute('colspan') || 1),
            a = parseInt(t.getAttribute('rowspan') || 1);
          if (o + s - 1 > n) {
            yp('colspan', n - o + 1, t, r, 1);
          }
          if (e + a - 1 > i) {
            yp('rowspan', i - e + 1, t, r, 1);
          }
        }
        o(102);
        class $b extends Hc {
          static get pluginName() {
            return 'TableSelection';
          }
          static get requires() {
            return [kb];
          }
          init() {
            const t = this.editor,
              e = t.model;
            this.listenTo(e, 'deleteContent', (t, e) => this._handleDeleteContent(t, e), { priority: 'high' }),
              t.editing.view.addObserver(qb),
              this._defineSelectionConverter(),
              this._enableShiftClickSelection(),
              this._enableMouseDragSelection(),
              this._enablePluginDisabling();
          }
          getSelectedTableCells() {
            const t = Op(this.editor.model.document.selection);
            return 0 == t.length ? null : t;
          }
          getSelectionAsFragment() {
            const t = this.getSelectedTableCells();
            return t
              ? this.editor.model.change(e => {
                  const o = e.createDocumentFragment(),
                    { first: i, last: n } = Lp(t),
                    { first: r, last: s } = zp(t),
                    a = Gb(
                      vp('table', t[0]),
                      { startRow: r, startColumn: i, endRow: s, endColumn: n },
                      e,
                      this.editor.plugins.get('TableUtils')
                    );
                  return e.insert(a, o, 0), o;
                })
              : null;
          }
          setCellSelection(t, e) {
            const o = this._getCellsToSelect(t, e);
            this.editor.model.change(t => {
              t.setSelection(
                o.cells.map(e => t.createRangeOn(e)),
                { backward: o.backward }
              );
            });
          }
          getFocusCell() {
            const t = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
            return t && t.is('tableCell') ? t : null;
          }
          getAnchorCell() {
            const t = Gc(this.editor.model.document.selection.getRanges()).getContainedElement();
            return t && t.is('tableCell') ? t : null;
          }
          _defineSelectionConverter() {
            const t = this.editor,
              e = new Set();
            t.conversion.for('editingDowncast').add(t =>
              t.on(
                'selection',
                (t, o, i) => {
                  const n = i.writer;
                  !(function (t) {
                    for (const o of e) t.removeClass('ck-editor__editable_selected', o);
                    e.clear();
                  })(n);
                  const r = this.getSelectedTableCells();
                  if (!r) return;
                  for (const t of r) {
                    const o = i.mapper.toViewElement(t);
                    n.addClass('ck-editor__editable_selected', o), e.add(o);
                  }
                  const s = i.mapper.toViewElement(r[r.length - 1]);
                  n.setSelection(s, 0);
                },
                { priority: 'lowest' }
              )
            );
          }
          _enableShiftClickSelection() {
            const t = this.editor;
            let e = !1;
            this.listenTo(t.editing.view.document, 'mousedown', (o, i) => {
              if (!this.isEnabled) return;
              if (!i.domEvent.shiftKey) return;
              const n = this.getAnchorCell() || Vp(t.model.document.selection)[0];
              if (!n) return;
              const r = this._getModelTableCellFromDomEvent(i);
              r && Qb(n, r) && ((e = !0), this.setCellSelection(n, r), i.preventDefault());
            }),
              this.listenTo(t.editing.view.document, 'mouseup', () => {
                e = !1;
              }),
              this.listenTo(
                t.editing.view.document,
                'selectionChange',
                t => {
                  e && t.stop();
                },
                { priority: 'highest' }
              );
          }
          _enableMouseDragSelection() {
            const t = this.editor;
            let e,
              o,
              i = !1,
              n = !1;
            this.listenTo(t.editing.view.document, 'mousedown', (t, o) => {
              this.isEnabled &&
                (o.domEvent.shiftKey ||
                  o.domEvent.ctrlKey ||
                  o.domEvent.altKey ||
                  (e = this._getModelTableCellFromDomEvent(o)));
            }),
              this.listenTo(t.editing.view.document, 'mousemove', (t, r) => {
                if (!r.domEvent.buttons) return;
                if (!e) return;
                const s = this._getModelTableCellFromDomEvent(r);
                s && Qb(e, s) && ((o = s), i || o == e || (i = !0)),
                  i && ((n = !0), this.setCellSelection(e, o), r.preventDefault());
              }),
              this.listenTo(t.editing.view.document, 'mouseup', () => {
                (i = !1), (n = !1), (e = null), (o = null);
              }),
              this.listenTo(
                t.editing.view.document,
                'selectionChange',
                t => {
                  n && t.stop();
                },
                { priority: 'highest' }
              );
          }
          _enablePluginDisabling() {
            const t = this.editor;
            this.on('change:isEnabled', () => {
              if (!this.isEnabled) {
                const e = this.getSelectedTableCells();
                if (!e) return;
                t.model.change(o => {
                  const i = o.createPositionAt(e[0], 0),
                    n = t.model.schema.getNearestSelectionRange(i);
                  o.setSelection(n);
                });
              }
            });
          }
          _handleDeleteContent(t, e) {
            const [o, i] = e,
              n = this.editor.model,
              r = !i || 'backward' == i.direction,
              s = Op(o);
            s.length &&
              (t.stop(),
              n.change(t => {
                const e = s[r ? s.length - 1 : 0];
                n.change(t => {
                  for (const e of s) n.deleteContent(t.createSelection(e, 'in'));
                });
                const i = n.schema.getNearestSelectionRange(t.createPositionAt(e, 0));
                o.is('documentSelection') ? t.setSelection(i) : o.setTo(i);
              }));
          }
          _getModelTableCellFromDomEvent(t) {
            const e = t.target,
              o = this.editor.editing.view.createPositionAt(e, 0),
              i = this.editor.editing.mapper.toModelPosition(o).parent;
            return i.is('tableCell') ? i : vp('tableCell', i);
          }
          _getCellsToSelect(t, e) {
            const o = this.editor.plugins.get('TableUtils'),
              i = o.getCellLocation(t),
              n = o.getCellLocation(e),
              r = Math.min(i.row, n.row),
              s = Math.max(i.row, n.row),
              a = Math.min(i.column, n.column),
              l = Math.max(i.column, n.column),
              c = new Array(s - r + 1).fill(null).map(() => []);
            for (const e of new Mp(vp('table', t), { startRow: r, endRow: s }))
              e.column >= a && e.column <= l && c[e.row - r].push(e.cell);
            const d = n.row < i.row,
              h = n.column < i.column;
            return d && c.reverse(), h && c.forEach(t => t.reverse()), { cells: c.flat(), backward: d || h };
          }
        }
        function Qb(t, e) {
          return t.parent.parent == e.parent.parent;
        }
        class Kb extends Hc {
          static get pluginName() {
            return 'TableClipboard';
          }
          static get requires() {
            return [$b, kb];
          }
          init() {
            const t = this.editor,
              e = t.editing.view.document;
            this.listenTo(e, 'copy', (t, e) => this._onCopyCut(t, e)),
              this.listenTo(e, 'cut', (t, e) => this._onCopyCut(t, e)),
              this.listenTo(t.model, 'insertContent', (t, e) => this._onInsertContent(t, ...e), { priority: 'high' });
          }
          _onCopyCut(t, e) {
            const o = this.editor.plugins.get($b);
            if (!o.getSelectedTableCells()) return;
            if ('cut' == t.name && this.editor.isReadOnly) return;
            e.preventDefault(), t.stop();
            const i = this.editor.data,
              n = this.editor.editing.view.document,
              r = i.toView(o.getSelectionAsFragment());
            n.fire('clipboardOutput', { dataTransfer: e.dataTransfer, content: r, method: t.name });
          }
          _onInsertContent(t, e, o) {
            if (o && !o.is('documentSelection')) return;
            const i = this.editor.model,
              n = this.editor.plugins.get(kb),
              r = Dp(i.document.selection);
            if (!r.length) return;
            let s = (function (t) {
              if (t.is('table')) return t;
              if (1 != t.childCount || !t.getChild(0).is('table')) return null;
              return t.getChild(0);
            })(e);
            s &&
              (t.stop(),
              i.change(t => {
                const e = Lp(r),
                  o = zp(r);
                let { first: i, last: a } = e,
                  { first: l, last: c } = o;
                const d = n.getRows(s),
                  h = n.getColumns(s),
                  u = vp('table', r[0]),
                  g = 1 === r.length;
                if (
                  (g &&
                    ((c += d - 1),
                    (a += h - 1),
                    (function (t, e, o, i, n) {
                      const r = n.getColumns(t),
                        s = n.getRows(t);
                      o > r && n.insertColumns(t, { batch: i.batch, at: r, columns: o - r });
                      e > s && n.insertRows(t, { batch: i.batch, at: s, rows: e - s });
                    })(u, c + 1, a + 1, t, n)),
                  g || !jp(r, n))
                ) {
                  !(function (t, e, o) {
                    const { firstRow: i, lastRow: n, firstColumn: r, lastColumn: s } = e,
                      a = { first: i, last: n },
                      l = { first: r, last: s };
                    Zb(t, r, a, o), Zb(t, s + 1, a, o), Jb(t, i, l, o), Jb(t, n + 1, l, o, i);
                  })(u, { firstRow: l, lastRow: c, firstColumn: i, lastColumn: a }, t);
                } else
                  (c = (function (t, e, o) {
                    const i = new Mp(t, { startRow: e.last, endRow: e.last }),
                      n = Array.from(i).filter(({ column: t }) => o.first <= t && t <= o.last);
                    if (n.every(({ rowspan: t }) => 1 === t)) return e.last;
                    const r = n[0].rowspan - 1;
                    return e.last + r;
                  })(u, o, e)),
                    (a = (function (t, e, o) {
                      const i = Array.from(new Mp(t, { startRow: e.first, endRow: e.last, column: o.last }));
                      if (i.every(({ colspan: t }) => 1 === t)) return o.last;
                      const n = i[0].colspan - 1;
                      return o.last + n;
                    })(u, o, e));
                const m = c - l + 1,
                  f = a - i + 1,
                  p = {
                    startRow: 0,
                    startColumn: 0,
                    endRow: Math.min(m - 1, d - 1),
                    endColumn: Math.min(f - 1, h - 1),
                  };
                s = Gb(s, p, t, n);
                !(function (t, e, o, i, n) {
                  const {
                      firstColumnOfSelection: r,
                      lastColumnOfSelection: s,
                      firstRowOfSelection: a,
                      lastRowOfSelection: l,
                    } = i,
                    { width: c, height: d } = e,
                    h = (function (t, e, o) {
                      const i = new Array(o).fill(null).map(() => new Array(e).fill(null));
                      for (const { column: e, row: o, cell: n } of new Mp(t)) i[o][e] = n;
                      return i;
                    })(t, c, d),
                    u = [...new Mp(o, { startRow: a, endRow: l, includeSpanned: !0 })],
                    g = [];
                  let m;
                  for (const { row: t, column: e, cell: i, isSpanned: f } of u) {
                    if ((0 === e && (m = null), e < r || e > s)) {
                      f || (m = i);
                      continue;
                    }
                    f || n.remove(i);
                    const u = e - r,
                      p = h[(t - a) % d][u % c];
                    if (!p) continue;
                    const b = p._clone(!0);
                    let w;
                    Yb(b, t, e, l, s, n),
                      (w = m ? n.createPositionAfter(m) : n.createPositionAt(o.getChild(t), 0)),
                      n.insert(b, w),
                      g.push(b),
                      (m = b);
                  }
                  n.setSelection(g.map(t => n.createRangeOn(t)));
                })(
                  s,
                  { width: h, height: d },
                  u,
                  {
                    firstColumnOfSelection: i,
                    firstRowOfSelection: l,
                    lastColumnOfSelection: a,
                    lastRowOfSelection: c,
                  },
                  t
                );
              }));
          }
        }
        function Jb(t, e, o, i, n = 0) {
          if (e < 1) return;
          const r = Bp(t, e, n).filter(({ column: t, colspan: e }) => Xb(t, e, o));
          for (const { cell: t } of r) Fp(t, e, i);
        }
        function Zb(t, e, o, i) {
          if (e < 1) return;
          const n = Hp(t, e).filter(({ row: t, rowspan: e }) => Xb(t, e, o));
          for (const { cell: t, column: o } of n) Wp(t, o, e, i);
        }
        function Xb(t, e, o) {
          const i = t + e - 1,
            { first: n, last: r } = o;
          return (t >= n && t <= r) || (t < n && i >= n);
        }
        class tw extends Hc {
          static get pluginName() {
            return 'TableNavigation';
          }
          static get requires() {
            return [$b];
          }
          init() {
            const t = this.editor.editing.view.document;
            this.editor.keystrokes.set('Tab', (...t) => this._handleTabOnSelectedTable(...t), { priority: 'low' }),
              this.editor.keystrokes.set('Tab', this._getTabHandler(!0), { priority: 'low' }),
              this.editor.keystrokes.set('Shift+Tab', this._getTabHandler(!1), { priority: 'low' }),
              this.listenTo(t, 'keydown', (...t) => this._onKeydown(...t), { priority: ho.get('high') + 1 });
          }
          _handleTabOnSelectedTable(t, e) {
            const o = this.editor,
              i = o.model.document.selection;
            if (!i.isCollapsed && 1 === i.rangeCount && i.getFirstRange().isFlat) {
              const t = i.getSelectedElement();
              if (!t || !t.is('table')) return;
              e(),
                o.model.change(e => {
                  e.setSelection(e.createRangeIn(t.getChild(0).getChild(0)));
                });
            }
          }
          _getTabHandler(t) {
            const e = this.editor;
            return (o, i) => {
              const n = Vp(e.model.document.selection)[0];
              if (!n) return;
              i();
              const r = n.parent,
                s = r.parent,
                a = s.getChildIndex(r),
                l = r.getChildIndex(n),
                c = 0 === l;
              if (!t && c && 0 === a) return;
              const d = l === r.childCount - 1,
                h = a === s.childCount - 1;
              if (t && h && d && (e.execute('insertTableRowBelow'), a === s.childCount - 1)) return;
              let u;
              if (t && d) {
                const t = s.getChild(a + 1);
                u = t.getChild(0);
              } else if (!t && c) {
                const t = s.getChild(a - 1);
                u = t.getChild(t.childCount - 1);
              } else u = r.getChild(l + (t ? 1 : -1));
              e.model.change(t => {
                t.setSelection(t.createRangeIn(u));
              });
            };
          }
          _onKeydown(t, e) {
            const o = e.keyCode;
            if (
              !(function (t) {
                return t == fn.arrowright || t == fn.arrowleft || t == fn.arrowup || t == fn.arrowdown;
              })(o)
            )
              return;
            const i = (function (t, e) {
              const o = 'ltr' === e;
              switch (t) {
                case fn.arrowleft:
                  return o ? 'left' : 'right';
                case fn.arrowright:
                  return o ? 'right' : 'left';
                case fn.arrowup:
                  return 'up';
                case fn.arrowdown:
                  return 'down';
              }
            })(o, this.editor.locale.contentLanguageDirection);
            this._handleArrowKeys(i, e.shiftKey) && (e.preventDefault(), e.stopPropagation(), t.stop());
          }
          _handleArrowKeys(t, e) {
            const o = this.editor.model,
              i = o.document.selection,
              n = ['right', 'down'].includes(t),
              r = Op(i);
            if (r.length) {
              let o;
              return (
                (o = e ? this.editor.plugins.get('TableSelection').getFocusCell() : n ? r[r.length - 1] : r[0]),
                this._navigateFromCellInDirection(o, t, e),
                !0
              );
            }
            const s = vp('tableCell', i.focus);
            if (!s) return !1;
            const a = o.createRangeIn(s);
            if (this._isSelectionAtCellEdge(i, n)) return this._navigateFromCellInDirection(s, t, e), !0;
            const l = i.getSelectedElement();
            if (l && o.schema.isObject(l)) return !1;
            if (this._isObjectElementNextToSelection(i, n)) return !1;
            const c = this._findTextRangeFromSelection(a, i, n);
            return c
              ? !['left', 'right'].includes(t) &&
                  (this._isSingleLineRange(c, n)
                    ? (o.change(t => {
                        const r = n ? a.end : a.start;
                        if (e) {
                          const e = o.createSelection(i.anchor);
                          e.setFocus(r), t.setSelection(e);
                        } else t.setSelection(r);
                      }),
                      !0)
                    : void 0)
              : (this._navigateFromCellInDirection(s, t, e), !0);
          }
          _isSelectionAtCellEdge(t, e) {
            const o = this.editor.model,
              i = this.editor.model.schema,
              n = e ? t.getLastPosition() : t.getFirstPosition();
            if (!i.getLimitElement(n).is('tableCell')) return !1;
            const r = o.createSelection(n);
            return o.modifySelection(r, { direction: e ? 'forward' : 'backward' }), n.isEqual(r.focus);
          }
          _isObjectElementNextToSelection(t, e) {
            const o = this.editor.model,
              i = o.schema,
              n = o.createSelection(t);
            o.modifySelection(n, { direction: e ? 'forward' : 'backward' });
            const r = e ? n.focus.nodeBefore : n.focus.nodeAfter;
            return r && i.isObject(r);
          }
          _findTextRangeFromSelection(t, e, o) {
            const i = this.editor.model;
            if (o) {
              const o = e.getLastPosition(),
                n = this._getNearestVisibleTextPosition(t, 'backward');
              return n && o.isBefore(n) ? i.createRange(o, n) : null;
            }
            {
              const o = e.getFirstPosition(),
                n = this._getNearestVisibleTextPosition(t, 'forward');
              return n && o.isAfter(n) ? i.createRange(n, o) : null;
            }
          }
          _getNearestVisibleTextPosition(t, e) {
            const o = this.editor.model.schema,
              i = this.editor.editing.mapper;
            for (const { nextPosition: n, item: r } of t.getWalker({ direction: e }))
              if (o.checkChild(n, '$text')) {
                const t = i.toViewElement(r);
                if (t && !t.hasClass('ck-hidden')) return n;
              }
          }
          _isSingleLineRange(t, e) {
            const o = this.editor.model,
              i = this.editor.editing,
              n = i.view.domConverter;
            if (e) {
              const e = o.createSelection(t.start);
              o.modifySelection(e), e.focus.isAtEnd || t.start.isEqual(e.focus) || (t = o.createRange(e.focus, t.end));
            }
            const r = i.mapper.toViewRange(t),
              s = n.viewRangeToDom(r),
              a = Zr.getDomRangeRects(s);
            let l;
            for (const t of a)
              if (void 0 !== l) {
                if (Math.round(t.top) >= l) return !1;
                l = Math.max(l, Math.round(t.bottom));
              } else l = Math.round(t.bottom);
            return !0;
          }
          _navigateFromCellInDirection(t, e, o = !1) {
            const i = this.editor.model,
              n = vp('table', t),
              r = [...new Mp(n, { includeSpanned: !0 })],
              { row: s, column: a } = r[r.length - 1],
              l = r.find(({ cell: e }) => e == t);
            let { row: c, column: d } = l;
            switch (e) {
              case 'left':
                d--;
                break;
              case 'up':
                c--;
                break;
              case 'right':
                d += l.colspan;
                break;
              case 'down':
                c += l.rowspan;
            }
            if (c < 0 || c > s || (d < 0 && c <= 0) || (d > a && c >= s))
              return void i.change(t => {
                t.setSelection(t.createRangeOn(n));
              });
            d < 0 ? ((d = o ? 0 : a), c--) : d > a && ((d = o ? a : 0), c++);
            const h = r.find(t => t.row == c && t.column == d).cell,
              u = ['right', 'down'].includes(e);
            if (o) {
              const e = this.editor.plugins.get('TableSelection'),
                o = e.getAnchorCell() || t;
              e.setCellSelection(o, h);
            } else {
              const t = i.createPositionAt(h, u ? 0 : 'end');
              i.change(e => {
                e.setSelection(t);
              });
            }
          }
        }
        o(104);
        function ew(t) {
          t.setNormalizer('border', ow),
            t.setNormalizer('border-top', iw('top')),
            t.setNormalizer('border-right', iw('right')),
            t.setNormalizer('border-bottom', iw('bottom')),
            t.setNormalizer('border-left', iw('left')),
            t.setNormalizer('border-color', nw('color')),
            t.setNormalizer('border-width', nw('width')),
            t.setNormalizer('border-style', nw('style')),
            t.setNormalizer('border-top-color', sw('color', 'top')),
            t.setNormalizer('border-top-style', sw('style', 'top')),
            t.setNormalizer('border-top-width', sw('width', 'top')),
            t.setNormalizer('border-right-color', sw('color', 'right')),
            t.setNormalizer('border-right-style', sw('style', 'right')),
            t.setNormalizer('border-right-width', sw('width', 'right')),
            t.setNormalizer('border-bottom-color', sw('color', 'bottom')),
            t.setNormalizer('border-bottom-style', sw('style', 'bottom')),
            t.setNormalizer('border-bottom-width', sw('width', 'bottom')),
            t.setNormalizer('border-left-color', sw('color', 'left')),
            t.setNormalizer('border-left-style', sw('style', 'left')),
            t.setNormalizer('border-left-width', sw('width', 'left')),
            t.setExtractor('border-top', aw('top')),
            t.setExtractor('border-right', aw('right')),
            t.setExtractor('border-bottom', aw('bottom')),
            t.setExtractor('border-left', aw('left')),
            t.setExtractor('border-top-color', 'border.color.top'),
            t.setExtractor('border-right-color', 'border.color.right'),
            t.setExtractor('border-bottom-color', 'border.color.bottom'),
            t.setExtractor('border-left-color', 'border.color.left'),
            t.setExtractor('border-top-width', 'border.width.top'),
            t.setExtractor('border-right-width', 'border.width.right'),
            t.setExtractor('border-bottom-width', 'border.width.bottom'),
            t.setExtractor('border-left-width', 'border.width.left'),
            t.setExtractor('border-top-style', 'border.style.top'),
            t.setExtractor('border-right-style', 'border.style.right'),
            t.setExtractor('border-bottom-style', 'border.style.bottom'),
            t.setExtractor('border-left-style', 'border.style.left'),
            t.setReducer('border-color', Cm('border-color')),
            t.setReducer('border-style', Cm('border-style')),
            t.setReducer('border-width', Cm('border-width')),
            t.setReducer('border-top', hw('top')),
            t.setReducer('border-right', hw('right')),
            t.setReducer('border-bottom', hw('bottom')),
            t.setReducer('border-left', hw('left')),
            t.setReducer('border', dw),
            t.setStyleRelation('border', [
              'border-color',
              'border-style',
              'border-width',
              'border-top',
              'border-right',
              'border-bottom',
              'border-left',
              'border-top-color',
              'border-right-color',
              'border-bottom-color',
              'border-left-color',
              'border-top-style',
              'border-right-style',
              'border-bottom-style',
              'border-left-style',
              'border-top-width',
              'border-right-width',
              'border-bottom-width',
              'border-left-width',
            ]),
            t.setStyleRelation('border-color', [
              'border-top-color',
              'border-right-color',
              'border-bottom-color',
              'border-left-color',
            ]),
            t.setStyleRelation('border-style', [
              'border-top-style',
              'border-right-style',
              'border-bottom-style',
              'border-left-style',
            ]),
            t.setStyleRelation('border-width', [
              'border-top-width',
              'border-right-width',
              'border-bottom-width',
              'border-left-width',
            ]),
            t.setStyleRelation('border-top', ['border-top-color', 'border-top-style', 'border-top-width']),
            t.setStyleRelation('border-right', ['border-right-color', 'border-right-style', 'border-right-width']),
            t.setStyleRelation('border-bottom', ['border-bottom-color', 'border-bottom-style', 'border-bottom-width']),
            t.setStyleRelation('border-left', ['border-left-color', 'border-left-style', 'border-left-width']);
        }
        function ow(t) {
          const { color: e, style: o, width: i } = cw(t);
          return { path: 'border', value: { color: xm(e), style: xm(o), width: xm(i) } };
        }
        function iw(t) {
          return e => {
            const { color: o, style: i, width: n } = cw(e),
              r = {};
            return (
              void 0 !== o && (r.color = { [t]: o }),
              void 0 !== i && (r.style = { [t]: i }),
              void 0 !== n && (r.width = { [t]: n }),
              { path: 'border', value: r }
            );
          };
        }
        function nw(t) {
          return e => ({ path: 'border', value: rw(e, t) });
        }
        function rw(t, e) {
          return { [e]: xm(t) };
        }
        function sw(t, e) {
          return o => ({ path: 'border', value: { [t]: { [e]: o } } });
        }
        function aw(t) {
          return (e, o) => {
            if (o.border) return lw(o.border, t);
          };
        }
        function lw(t, e) {
          const o = {};
          return (
            t.width && t.width[e] && (o.width = t.width[e]),
            t.style && t.style[e] && (o.style = t.style[e]),
            t.color && t.color[e] && (o.color = t.color[e]),
            o
          );
        }
        function cw(t) {
          const e = {},
            o = Sm(t);
          for (const t of o)
            mm(t) || /thin|medium|thick/.test(t) ? (e.width = t) : um(t) ? (e.style = t) : (e.color = t);
          return e;
        }
        function dw(t) {
          const e = [];
          return (
            e.push(...uw(lw(t, 'top'), 'top')),
            e.push(...uw(lw(t, 'right'), 'right')),
            e.push(...uw(lw(t, 'bottom'), 'bottom')),
            e.push(...uw(lw(t, 'left'), 'left')),
            e
          );
        }
        function hw(t) {
          return e => uw(e, t);
        }
        function uw(t, e) {
          const o = [];
          return (
            t && void 0 !== t.width && o.push(t.width),
            t && void 0 !== t.style && o.push(t.style),
            t && void 0 !== t.color && o.push(t.color),
            o.length ? [['border-' + e, o.join(' ')]] : []
          );
        }
        function gw(t) {
          t.setNormalizer('background', mw),
            t.setNormalizer('background-color', t => ({ path: 'background.color', value: t })),
            t.setReducer('background', t => {
              const e = [];
              return e.push(['background-color', t.color]), e;
            });
        }
        function mw(t) {
          const e = {},
            o = Sm(t);
          for (const t of o)
            (i = t),
              pm.includes(i)
                ? ((e.repeat = e.repeat || []), e.repeat.push(t))
                : wm(t)
                ? ((e.position = e.position || []), e.position.push(t))
                : _m(t)
                ? (e.attachment = t)
                : dm(t)
                ? (e.color = t)
                : ym(t) && (e.image = t);
          var i;
          return { path: 'background', value: e };
        }
        function fw(t, e, o, i) {
          t.for('upcast').attributeToAttribute({
            view: { styles: { [i]: /[\s\S]+/ } },
            model: { name: e, key: o, value: t => t.getNormalizedStyle(i) },
          });
        }
        function pw(t, e) {
          t.for('upcast').add(t =>
            t.on('element:' + e, (t, e, o) => {
              const i = ['border-top', 'border-right', 'border-bottom', 'border-left'].filter(t =>
                e.viewItem.hasStyle(t)
              );
              if (!i.length) return;
              const n = { styles: i };
              if (!o.consumable.test(e.viewItem, n)) return;
              e.modelRange || (e = Object.assign(e, o.convertChildren(e.viewItem, e.modelCursor)));
              const r = [...e.modelRange.getItems({ shallow: !0 })].pop();
              o.consumable.consume(e.viewItem, n),
                o.writer.setAttribute('borderStyle', e.viewItem.getNormalizedStyle('border-style'), r),
                o.writer.setAttribute('borderColor', e.viewItem.getNormalizedStyle('border-color'), r),
                o.writer.setAttribute('borderWidth', e.viewItem.getNormalizedStyle('border-width'), r);
            })
          );
        }
        function bw(t, e, o, i) {
          t.for('downcast').attributeToAttribute({
            model: { name: e, key: o },
            view: t => ({ key: 'style', value: { [i]: t } }),
          });
        }
        function ww(t, e, o) {
          t.for('downcast').add(t =>
            t.on(`attribute:${e}:table`, (t, e, i) => {
              const { item: n, attributeNewValue: r } = e,
                { mapper: s, writer: a } = i;
              if (!i.consumable.consume(e.item, t.name)) return;
              const l = [...s.toViewElement(n).getChildren()].find(t => t.is('table'));
              r ? a.setStyle(o, r, l) : a.removeStyle(o, l);
            })
          );
        }
        class kw extends Uc {
          constructor(t, e) {
            super(t), (this.attributeName = e);
          }
          refresh() {
            const t = vp('table', this.editor.model.document.selection.getFirstPosition());
            (this.isEnabled = !!t), (this.value = this._getValue(t));
          }
          execute(t = {}) {
            const e = this.editor.model,
              o = e.document.selection,
              { value: i, batch: n } = t,
              r = vp('table', o.getFirstPosition()),
              s = this._getValueToSet(i);
            e.enqueueChange(n || 'default', t => {
              s ? t.setAttribute(this.attributeName, s, r) : t.removeAttribute(this.attributeName, r);
            });
          }
          _getValue(t) {
            if (t) return t.getAttribute(this.attributeName);
          }
          _getValueToSet(t) {
            return t;
          }
        }
        class _w extends kw {
          constructor(t) {
            super(t, 'backgroundColor');
          }
        }
        class vw extends kw {
          constructor(t) {
            super(t, 'borderColor');
          }
          _getValue(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
        }
        class yw extends kw {
          constructor(t) {
            super(t, 'borderStyle');
          }
          _getValue(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
        }
        class xw extends kw {
          constructor(t) {
            super(t, 'borderWidth');
          }
          _getValue(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        class Cw extends kw {
          constructor(t) {
            super(t, 'width');
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        class Aw extends kw {
          constructor(t) {
            super(t, 'height');
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        class Tw extends kw {
          constructor(t) {
            super(t, 'alignment');
          }
        }
        const Sw = /^(left|right)$/;
        class Pw extends Hc {
          static get pluginName() {
            return 'TablePropertiesEditing';
          }
          static get requires() {
            return [Bb];
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              o = t.conversion;
            t.data.addStyleProcessorRules(ew),
              (function (t, e) {
                t.extend('table', { allowAttributes: ['borderWidth', 'borderColor', 'borderStyle'] }),
                  pw(e, 'table'),
                  ww(e, 'borderColor', 'border-color'),
                  ww(e, 'borderStyle', 'border-style'),
                  ww(e, 'borderWidth', 'border-width');
              })(e, o),
              t.commands.add('tableBorderColor', new vw(t)),
              t.commands.add('tableBorderStyle', new yw(t)),
              t.commands.add('tableBorderWidth', new xw(t)),
              (function (t, e) {
                t.extend('table', { allowAttributes: ['alignment'] }),
                  e.attributeToAttribute({
                    model: { name: 'table', key: 'alignment', values: ['left', 'right'] },
                    view: {
                      left: { key: 'style', value: { float: 'left' } },
                      right: { key: 'style', value: { float: 'right' } },
                    },
                    converterPriority: 'high',
                  }),
                  e.for('upcast').attributeToAttribute({
                    view: { attributes: { align: Sw } },
                    model: { name: 'table', key: 'alignment', value: t => t.getAttribute('align') },
                  });
              })(e, o),
              t.commands.add('tableAlignment', new Tw(t)),
              Ew(e, o, 'width', 'width'),
              t.commands.add('tableWidth', new Cw(t)),
              Ew(e, o, 'height', 'height'),
              t.commands.add('tableHeight', new Aw(t)),
              t.data.addStyleProcessorRules(gw),
              (function (t, e, o, i) {
                t.extend('table', { allowAttributes: [o] }), fw(e, 'table', o, i), ww(e, o, i);
              })(e, o, 'backgroundColor', 'background-color'),
              t.commands.add('tableBackgroundColor', new _w(t));
          }
        }
        function Ew(t, e, o, i) {
          t.extend('table', { allowAttributes: [o] }), fw(e, 'table', o, i), bw(e, 'table', o, i);
        }
        o(106);
        class Mw extends sc {
          constructor(t, e) {
            super(t);
            const o = this.bindTemplate;
            this.set('value', ''),
              this.set('id'),
              this.set('isReadOnly', !1),
              this.set('hasError', !1),
              this.set('ariaDescribedById'),
              (this.options = e),
              (this._dropdownView = this._createDropdownView(t)),
              (this._inputView = this._createInputTextView(t)),
              (this._stillTyping = !1),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-input-color', o.if('hasError', 'ck-error')],
                  id: o.to('id'),
                  'aria-invalid': o.if('hasError', !0),
                  'aria-describedby': o.to('ariaDescribedById'),
                },
                children: [this._inputView, this._dropdownView],
              }),
              this.on('change:value', (t, e, o) => this._setInputValue(o));
          }
          focus() {
            this._inputView.focus();
          }
          _createDropdownView() {
            const t = this.locale,
              e = t.t,
              o = this.bindTemplate,
              i = this._createColorGrid(t),
              n = Rc(t),
              r = new sc(),
              s = this._createRemoveColorButton(t);
            return (
              r.setTemplate({
                tag: 'span',
                attributes: {
                  class: ['ck', 'ck-input-color__button__preview'],
                  style: { backgroundColor: o.to('value') },
                },
                children: [
                  {
                    tag: 'span',
                    attributes: {
                      class: [
                        'ck',
                        'ck-input-color__button__preview__no-color-indicator',
                        o.if('value', 'ck-hidden', t => '' != t),
                      ],
                    },
                  },
                ],
              }),
              n.buttonView.extendTemplate({ attributes: { class: 'ck-input-color__button' } }),
              n.buttonView.children.add(r),
              (n.buttonView.tooltip = e('Color picker')),
              (n.panelPosition = 'rtl' === t.uiLanguageDirection ? 'se' : 'sw'),
              n.panelView.children.add(s),
              n.panelView.children.add(i),
              n.bind('isEnabled').to(this, 'isReadOnly', t => !t),
              n
            );
          }
          _createInputTextView() {
            const t = this.locale,
              e = new Fu(t);
            return (
              e.extendTemplate({ on: { blur: e.bindTemplate.to('blur') } }),
              (e.value = this.value),
              e.bind('isReadOnly').to(this),
              e.bind('hasError').to(this),
              e.on('input', () => {
                const t = e.element.value,
                  o = this.options.colorDefinitions.find(e => t === e.label);
                (this._stillTyping = !0), (this.value = (o && o.color) || t);
              }),
              e.on('blur', () => {
                (this._stillTyping = !1), this._setInputValue(e.element.value);
              }),
              e.delegate('input').to(this),
              e
            );
          }
          _createRemoveColorButton() {
            const t = this.locale,
              e = t.t,
              o = new Ac(t);
            return (
              (o.class = 'ck-input-color__remove-color'),
              (o.withText = !0),
              (o.icon = vh),
              (o.label = e('Remove color')),
              o.on('execute', () => {
                (this.value = ''), (this._dropdownView.isOpen = !1), this.fire('input');
              }),
              o
            );
          }
          _createColorGrid(t) {
            const e = new wh(t, { colorDefinitions: this.options.colorDefinitions, columns: this.options.columns });
            return (
              e.on('execute', (t, e) => {
                (this.value = e.value), (this._dropdownView.isOpen = !1), this.fire('input');
              }),
              e.bind('selectedColor').to(this, 'value'),
              e
            );
          }
          _setInputValue(t) {
            if (!this._stillTyping) {
              const e = Iw(t),
                o = this.options.colorDefinitions.find(t => e === Iw(t.color));
              this._inputView.value = o ? o.label : t || '';
            }
          }
        }
        function Iw(t) {
          return t
            .replace(/([(,])\s+/g, '$1')
            .replace(/^\s+|\s+(?=[),\s]|$)/g, '')
            .replace(/,|\s/g, ' ');
        }
        const Nw = hu.defaultPositions,
          Rw = [
            Nw.northArrowSouth,
            Nw.northArrowSouthWest,
            Nw.northArrowSouthEast,
            Nw.southArrowNorth,
            Nw.southArrowNorthWest,
            Nw.southArrowNorthEast,
          ],
          Ow = [...Rw, _u],
          Vw = t => '' === t;
        function Dw(t, e) {
          const o = t.plugins.get('ContextualBalloon');
          if (Rp(t.editing.view.document.selection)) {
            let i;
            (i = 'cell' === e ? Lw(t) : zw(t)), o.updatePosition(i);
          }
        }
        function zw(t) {
          const e = vp('table', t.model.document.selection.getFirstPosition()),
            o = t.editing.mapper.toViewElement(e);
          return { target: t.editing.view.domConverter.viewToDom(o), positions: Ow };
        }
        function Lw(t) {
          const e = t.editing.mapper,
            o = t.editing.view.domConverter,
            i = t.model.document.selection;
          if (i.rangeCount > 1)
            return {
              target: () =>
                (function (t, e) {
                  const o = {
                    left: Number.POSITIVE_INFINITY,
                    top: Number.POSITIVE_INFINITY,
                    right: Number.NEGATIVE_INFINITY,
                    bottom: Number.NEGATIVE_INFINITY,
                  };
                  for (const i of t) {
                    const t = e(i);
                    (o.left = Math.min(o.left, t.left)),
                      (o.top = Math.min(o.top, t.top)),
                      (o.right = Math.max(o.right, t.right)),
                      (o.bottom = Math.max(o.bottom, t.bottom));
                  }
                  return (o.width = o.right - o.left), (o.height = o.bottom - o.top), new Zr(o);
                })(i.getRanges(), t => {
                  const i = Kw(t.start),
                    n = e.toViewElement(i);
                  return new Zr(o.viewToDom(n));
                }),
              positions: Rw,
            };
          const n = Kw(i.getFirstPosition()),
            r = e.toViewElement(n);
          return { target: o.viewToDom(r), positions: Rw };
        }
        function jw(t) {
          return {
            none: t('None'),
            solid: t('Solid'),
            dotted: t('Dotted'),
            dashed: t('Dashed'),
            double: t('Double'),
            groove: t('Groove'),
            ridge: t('Ridge'),
            inset: t('Inset'),
            outset: t('Outset'),
          };
        }
        function Bw(t) {
          return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
        }
        function Fw(t) {
          return t('The value is invalid. Try "10px" or "2em" or simply "2".');
        }
        function Hw(t) {
          return (t = t.trim()), Vw(t) || dm(t);
        }
        function Ww(t) {
          return (t = t.trim()), Vw(t) || Qw(t) || mm(t) || ((e = t), fm.test(e));
          var e;
        }
        function Uw(t) {
          return (t = t.trim()), Vw(t) || Qw(t) || mm(t);
        }
        function qw(t) {
          const e = new Co(),
            o = jw(t.t);
          for (const i in o) {
            const n = {
              type: 'button',
              model: new Bh({ _borderStyleValue: 'none' === i ? '' : i, label: o[i], withText: !0 }),
            };
            'none' === i
              ? n.model.bind('isOn').to(t, 'borderStyle', t => !t)
              : n.model.bind('isOn').to(t, 'borderStyle', t => t === i),
              e.add(n);
          }
          return e;
        }
        function Gw({ view: t, icons: e, toolbar: o, labels: i, propertyName: n, nameToValue: r }) {
          for (const s in i) {
            const a = new Ac(t.locale);
            a.set({ label: i[s], icon: e[s], tooltip: i[s] }),
              a.bind('isOn').to(t, n, t => t === r(s)),
              a.on('execute', () => {
                t[n] = r(s);
              }),
              o.items.add(a);
          }
        }
        const Yw = [
          { color: 'hsl(0, 0%, 0%)', label: 'Black' },
          { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
          { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
          { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
          { color: 'hsl(0, 0%, 100%)', label: 'White', hasBorder: !0 },
          { color: 'hsl(0, 75%, 60%)', label: 'Red' },
          { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
          { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
          { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
          { color: 'hsl(120, 75%, 60%)', label: 'Green' },
          { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
          { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
          { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
          { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
          { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
        ];
        function $w(t) {
          return (e, o, i) => {
            const n = new Mw(e.locale, {
              colorDefinitions:
                ((r = t.colorConfig),
                r.map(t => ({ color: t.model, label: t.label, options: { hasBorder: t.hasBorder } }))),
              columns: t.columns,
            });
            var r;
            return (
              n.set({ id: o, ariaDescribedById: i }),
              n.bind('isReadOnly').to(e, 'isEnabled', t => !t),
              n.bind('errorText').to(e),
              n.on('input', () => {
                e.errorText = null;
              }),
              n
            );
          };
        }
        function Qw(t) {
          const e = parseFloat(t);
          return !Number.isNaN(e) && t === String(e);
        }
        function Kw(t) {
          return t.nodeAfter && t.nodeAfter.is('tableCell') ? t.nodeAfter : vp('tableCell', t);
        }
        o(108);
        class Jw extends sc {
          constructor(t, e = {}) {
            super(t);
            const o = this.bindTemplate;
            this.set('class', e.class || null),
              (this.children = this.createCollection()),
              e.children && e.children.forEach(t => this.children.add(t)),
              this.set('_role', null),
              this.set('_ariaLabelledBy', null),
              e.labelView && this.set({ _role: 'group', _ariaLabelledBy: e.labelView.id }),
              this.setTemplate({
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-form__row', o.to('class')],
                  role: o.to('_role'),
                  'aria-labelledby': o.to('_ariaLabelledBy'),
                },
                children: this.children,
              });
          }
        }
        o(110);
        class Zw extends sc {
          constructor(t, e = {}) {
            super(t);
            const o = this.bindTemplate;
            this.set('label', e.label || ''),
              this.set('class', e.class || null),
              (this.children = this.createCollection()),
              this.setTemplate({
                tag: 'div',
                attributes: { class: ['ck', 'ck-form__header', o.to('class')] },
                children: this.children,
              });
            const i = new sc(t);
            i.setTemplate({
              tag: 'span',
              attributes: { class: ['ck', 'ck-form__header__label'] },
              children: [{ text: o.to('label') }],
            }),
              this.children.add(i);
          }
        }
        o(12), o(13), o(114);
        const Xw = { left: bg, center: wg, right: kg };
        class tk extends sc {
          constructor(t, e) {
            super(t),
              this.set({
                borderStyle: '',
                borderWidth: '',
                borderColor: '',
                backgroundColor: '',
                width: '',
                height: '',
                alignment: '',
              }),
              (this.options = e);
            const {
                borderStyleDropdown: o,
                borderWidthInput: i,
                borderColorInput: n,
                borderRowLabel: r,
              } = this._createBorderFields(),
              { widthInput: s, operatorLabel: a, heightInput: l, dimensionsLabel: c } = this._createDimensionFields(),
              { alignmentToolbar: d, alignmentLabel: h } = this._createAlignmentFields();
            (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this.children = this.createCollection()),
              (this.borderStyleDropdown = o),
              (this.borderWidthInput = i),
              (this.borderColorInput = n),
              (this.backgroundInput = this._createBackgroundField()),
              (this.widthInput = s),
              (this.heightInput = l),
              (this.alignmentToolbar = d);
            const { saveButtonView: u, cancelButtonView: g } = this._createActionButtons();
            (this.saveButtonView = u),
              (this.cancelButtonView = g),
              (this._focusables = new Bl()),
              (this._focusCycler = new uc({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              this.children.add(new Zw(t, { label: this.t('Table properties') })),
              this.children.add(
                new Jw(t, { labelView: r, children: [r, o, n, i], class: 'ck-table-form__border-row' })
              ),
              this.children.add(new Jw(t, { children: [this.backgroundInput] })),
              this.children.add(
                new Jw(t, {
                  children: [
                    new Jw(t, { labelView: c, children: [c, s, a, l], class: 'ck-table-form__dimensions-row' }),
                    new Jw(t, { labelView: h, children: [h, d], class: 'ck-table-properties-form__alignment-row' }),
                  ],
                })
              ),
              this.children.add(
                new Jw(t, {
                  children: [this.saveButtonView, this.cancelButtonView],
                  class: 'ck-table-form__action-row',
                })
              ),
              this.setTemplate({
                tag: 'form',
                attributes: { class: ['ck', 'ck-form', 'ck-table-form', 'ck-table-properties-form'], tabindex: '-1' },
                children: this.children,
              });
          }
          render() {
            super.render(),
              Uu({ view: this }),
              [
                this.borderStyleDropdown,
                this.borderColorInput,
                this.borderWidthInput,
                this.backgroundInput,
                this.widthInput,
                this.heightInput,
                this.alignmentToolbar,
                this.saveButtonView,
                this.cancelButtonView,
              ].forEach(t => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              }),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createBorderFields() {
            const t = $w({ colorConfig: this.options.borderColors, columns: 5 }),
              e = this.locale,
              o = this.t,
              i = new kh(e);
            i.text = o('Border');
            const n = jw(this.t),
              r = new Bu(e, Wu);
            r.set({ label: o('Style'), class: 'ck-table-form__border-style' }),
              r.fieldView.buttonView.set({ isOn: !1, withText: !0, tooltip: o('Style') }),
              r.fieldView.buttonView.bind('label').to(this, 'borderStyle', t => n[t || 'none']),
              r.fieldView.on('execute', t => {
                this.borderStyle = t.source._borderStyleValue;
              }),
              Vc(r.fieldView, qw(this));
            const s = new Bu(e, Hu);
            s.set({ label: o('Width'), class: 'ck-table-form__border-width' }),
              s.fieldView.bind('value').to(this, 'borderWidth'),
              s.bind('isEnabled').to(this, 'borderStyle', ek),
              s.fieldView.on('input', () => {
                this.borderWidth = s.fieldView.element.value;
              });
            const a = new Bu(e, t);
            return (
              a.set({ label: o('Color'), class: 'ck-table-form__border-color' }),
              a.fieldView.bind('value').to(this, 'borderColor'),
              a.bind('isEnabled').to(this, 'borderStyle', ek),
              a.fieldView.on('input', () => {
                this.borderColor = a.fieldView.value;
              }),
              this.on('change:borderStyle', (t, e, o) => {
                ek(o) || ((this.borderColor = ''), (this.borderWidth = ''));
              }),
              { borderRowLabel: i, borderStyleDropdown: r, borderColorInput: a, borderWidthInput: s }
            );
          }
          _createBackgroundField() {
            const t = $w({ colorConfig: this.options.backgroundColors, columns: 5 }),
              e = this.locale,
              o = this.t,
              i = new Bu(e, t);
            return (
              i.set({ label: o('Background'), class: 'ck-table-properties-form__background' }),
              i.fieldView.bind('value').to(this, 'backgroundColor'),
              i.fieldView.on('input', () => {
                this.backgroundColor = i.fieldView.value;
              }),
              i
            );
          }
          _createDimensionFields() {
            const t = this.locale,
              e = this.t,
              o = new kh(t);
            o.text = e('Dimensions');
            const i = new Bu(t, Hu);
            i.set({ label: e('Width'), class: 'ck-table-form__dimensions-row__width' }),
              i.fieldView.bind('value').to(this, 'width'),
              i.fieldView.on('input', () => {
                this.width = i.fieldView.element.value;
              });
            const n = new sc(t);
            n.setTemplate({
              tag: 'span',
              attributes: { class: ['ck-table-form__dimension-operator'] },
              children: [{ text: '×' }],
            });
            const r = new Bu(t, Hu);
            return (
              r.set({ label: e('Height'), class: 'ck-table-form__dimensions-row__height' }),
              r.fieldView.bind('value').to(this, 'height'),
              r.fieldView.on('input', () => {
                this.height = r.fieldView.element.value;
              }),
              { dimensionsLabel: o, widthInput: i, operatorLabel: n, heightInput: r }
            );
          }
          _createAlignmentFields() {
            const t = this.locale,
              e = this.t,
              o = new kh(t);
            o.text = e('Alignment');
            const i = new Dc(t);
            return (
              i.set({ isCompact: !0, ariaLabel: e('Table alignment toolbar') }),
              Gw({
                view: this,
                icons: Xw,
                toolbar: i,
                labels: this._alignmentLabels,
                propertyName: 'alignment',
                nameToValue: t => ('center' === t ? '' : t),
              }),
              { alignmentLabel: o, alignmentToolbar: i }
            );
          }
          _createActionButtons() {
            const t = this.locale,
              e = this.t,
              o = new Ac(t),
              i = new Ac(t),
              n = [
                this.borderWidthInput,
                this.borderColorInput,
                this.backgroundInput,
                this.widthInput,
                this.heightInput,
              ];
            return (
              o.set({ label: e('Save'), icon: qu, class: 'ck-button-save', type: 'submit', withText: !0 }),
              o.bind('isEnabled').toMany(n, 'errorText', (...t) => t.every(t => !t)),
              i.set({ label: e('Cancel'), icon: Gu, class: 'ck-button-cancel', type: 'cancel', withText: !0 }),
              i.delegate('execute').to(this, 'cancel'),
              { saveButtonView: o, cancelButtonView: i }
            );
          }
          get _alignmentLabels() {
            const t = this.locale,
              e = this.t,
              o = e('Align table to the left'),
              i = e('Center table'),
              n = e('Align table to the right');
            return 'rtl' === t.uiLanguageDirection
              ? { right: n, center: i, left: o }
              : { left: o, center: i, right: n };
          }
        }
        function ek(t) {
          return !!t;
        }
        const ok = {
          borderStyle: 'tableBorderStyle',
          borderColor: 'tableBorderColor',
          borderWidth: 'tableBorderWidth',
          backgroundColor: 'tableBackgroundColor',
          width: 'tableWidth',
          height: 'tableHeight',
          alignment: 'tableAlignment',
        };
        class ik extends Hc {
          static get requires() {
            return [Qu];
          }
          static get pluginName() {
            return 'TablePropertiesUI';
          }
          constructor(t) {
            super(t), t.config.define('table.tableProperties', { borderColors: Yw, backgroundColors: Yw });
          }
          init() {
            const t = this.editor,
              e = t.t;
            (this._balloon = t.plugins.get(Qu)),
              (this.view = this._createPropertiesView()),
              (this._undoStepBatch = null),
              t.ui.componentFactory.add('tableProperties', o => {
                const i = new Ac(o);
                i.set({
                  label: e('Table properties'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="M15.5 11.5l1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>',
                  tooltip: !0,
                }),
                  this.listenTo(i, 'execute', () => this._showView());
                const n = Object.values(ok).map(e => t.commands.get(e));
                return i.bind('isEnabled').toMany(n, 'isEnabled', (...t) => t.some(t => t)), i;
              });
          }
          destroy() {
            super.destroy(), this.view.destroy();
          }
          _createPropertiesView() {
            const t = this.editor,
              e = t.editing.view.document,
              o = t.config.get('table.tableProperties'),
              i = Ph(o.borderColors),
              n = Sh(t.locale, i),
              r = Ph(o.backgroundColors),
              s = Sh(t.locale, r),
              a = new tk(t.locale, { borderColors: n, backgroundColors: s }),
              l = t.t;
            a.render(),
              this.listenTo(a, 'submit', () => {
                this._hideView();
              }),
              this.listenTo(a, 'cancel', () => {
                this._undoStepBatch.operations.length && t.execute('undo', this._undoStepBatch), this._hideView();
              }),
              a.keystrokes.set('Esc', (t, e) => {
                this._hideView(), e();
              }),
              this.listenTo(t.ui, 'update', () => {
                Rp(e.selection) ? this._isViewVisible && Dw(t, 'table') : this._hideView();
              }),
              Nc({
                emitter: a,
                activator: () => this._isViewInBalloon,
                contextElements: [this._balloon.view.element],
                callback: () => this._hideView(),
              });
            const c = Bw(l),
              d = Fw(l);
            return (
              a.on('change:borderStyle', this._getPropertyChangeCallback('tableBorderStyle')),
              a.on(
                'change:borderColor',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.borderColorInput,
                  commandName: 'tableBorderColor',
                  errorText: c,
                  validator: Hw,
                })
              ),
              a.on(
                'change:borderWidth',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.borderWidthInput,
                  commandName: 'tableBorderWidth',
                  errorText: d,
                  validator: Uw,
                })
              ),
              a.on(
                'change:backgroundColor',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.backgroundInput,
                  commandName: 'tableBackgroundColor',
                  errorText: c,
                  validator: Hw,
                })
              ),
              a.on(
                'change:width',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.widthInput,
                  commandName: 'tableWidth',
                  errorText: d,
                  validator: Ww,
                })
              ),
              a.on(
                'change:height',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.heightInput,
                  commandName: 'tableHeight',
                  errorText: d,
                  validator: Ww,
                })
              ),
              a.on('change:alignment', this._getPropertyChangeCallback('tableAlignment')),
              a
            );
          }
          _fillViewFormFromCommandValues() {
            const t = this.editor.commands;
            Object.entries(ok)
              .map(([e, o]) => [e, t.get(o).value || ''])
              .forEach(([t, e]) => this.view.set(t, e));
          }
          _showView() {
            const t = this.editor;
            this._balloon.add({ view: this.view, position: zw(t) }),
              (this._undoStepBatch = t.model.createBatch()),
              this._fillViewFormFromCommandValues(),
              this.view.focus();
          }
          _hideView() {
            if (!this._isViewInBalloon) return;
            const t = this.editor;
            this.stopListening(t.ui, 'update'),
              this.view.saveButtonView.focus(),
              this._balloon.remove(this.view),
              this.editor.editing.view.focus();
          }
          get _isViewVisible() {
            return this._balloon.visibleView === this.view;
          }
          get _isViewInBalloon() {
            return this._balloon.hasView(this.view);
          }
          _getPropertyChangeCallback(t) {
            return (e, o, i) => {
              this.editor.execute(t, { value: i, batch: this._undoStepBatch });
            };
          }
          _getValidatedPropertyChangeCallback({ commandName: t, viewField: e, validator: o, errorText: i }) {
            const n = Wr(() => {
              e.errorText = i;
            }, 500);
            return (i, r, s) => {
              n.cancel(),
                o(s) ? (this.editor.execute(t, { value: s, batch: this._undoStepBatch }), (e.errorText = null)) : n();
            };
          }
        }
        o(116);
        const nk = {
          left: Zc,
          center: td,
          right: Xc,
          justify: ed,
          top:
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.261 7.062l2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
          middle:
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
          bottom:
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.239 13.938l-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
        };
        class rk extends sc {
          constructor(t, e) {
            super(t),
              this.set({
                borderStyle: '',
                borderWidth: '',
                borderColor: '',
                padding: '',
                backgroundColor: '',
                width: '',
                height: '',
                horizontalAlignment: '',
                verticalAlignment: '',
              }),
              (this.options = e);
            const {
                borderStyleDropdown: o,
                borderWidthInput: i,
                borderColorInput: n,
                borderRowLabel: r,
              } = this._createBorderFields(),
              { widthInput: s, operatorLabel: a, heightInput: l, dimensionsLabel: c } = this._createDimensionFields(),
              {
                horizontalAlignmentToolbar: d,
                verticalAlignmentToolbar: h,
                alignmentLabel: u,
              } = this._createAlignmentFields();
            (this.focusTracker = new Nl()),
              (this.keystrokes = new Cl()),
              (this.children = this.createCollection()),
              (this.borderStyleDropdown = o),
              (this.borderWidthInput = i),
              (this.borderColorInput = n),
              (this.backgroundInput = this._createBackgroundField()),
              (this.paddingInput = this._createPaddingField()),
              (this.widthInput = s),
              (this.heightInput = l),
              (this.horizontalAlignmentToolbar = d),
              (this.verticalAlignmentToolbar = h);
            const { saveButtonView: g, cancelButtonView: m } = this._createActionButtons();
            (this.saveButtonView = g),
              (this.cancelButtonView = m),
              (this._focusables = new Bl()),
              (this._focusCycler = new uc({
                focusables: this._focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
              })),
              this.children.add(new Zw(t, { label: this.t('Cell properties') })),
              this.children.add(
                new Jw(t, { labelView: r, children: [r, o, n, i], class: 'ck-table-form__border-row' })
              ),
              this.children.add(new Jw(t, { children: [this.backgroundInput] })),
              this.children.add(
                new Jw(t, {
                  children: [
                    new Jw(t, { labelView: c, children: [c, s, a, l], class: 'ck-table-form__dimensions-row' }),
                    new Jw(t, { children: [this.paddingInput], class: 'ck-table-cell-properties-form__padding-row' }),
                  ],
                })
              ),
              this.children.add(
                new Jw(t, { labelView: u, children: [u, d, h], class: 'ck-table-cell-properties-form__alignment-row' })
              ),
              this.children.add(
                new Jw(t, {
                  children: [this.saveButtonView, this.cancelButtonView],
                  class: 'ck-table-form__action-row',
                })
              ),
              this.setTemplate({
                tag: 'form',
                attributes: {
                  class: ['ck', 'ck-form', 'ck-table-form', 'ck-table-cell-properties-form'],
                  tabindex: '-1',
                },
                children: this.children,
              });
          }
          render() {
            super.render(),
              Uu({ view: this }),
              [
                this.borderStyleDropdown,
                this.borderColorInput,
                this.borderWidthInput,
                this.backgroundInput,
                this.widthInput,
                this.heightInput,
                this.paddingInput,
                this.horizontalAlignmentToolbar,
                this.verticalAlignmentToolbar,
                this.saveButtonView,
                this.cancelButtonView,
              ].forEach(t => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              }),
              this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createBorderFields() {
            const t = $w({ colorConfig: this.options.borderColors, columns: 5 }),
              e = this.locale,
              o = this.t,
              i = new kh(e);
            i.text = o('Border');
            const n = jw(o),
              r = new Bu(e, Wu);
            r.set({ label: o('Style'), class: 'ck-table-form__border-style' }),
              r.fieldView.buttonView.set({ isOn: !1, withText: !0, tooltip: o('Style') }),
              r.fieldView.buttonView.bind('label').to(this, 'borderStyle', t => n[t || 'none']),
              r.fieldView.on('execute', t => {
                this.borderStyle = t.source._borderStyleValue;
              }),
              Vc(r.fieldView, qw(this));
            const s = new Bu(e, Hu);
            s.set({ label: o('Width'), class: 'ck-table-form__border-width' }),
              s.fieldView.bind('value').to(this, 'borderWidth'),
              s.bind('isEnabled').to(this, 'borderStyle', sk),
              s.fieldView.on('input', () => {
                this.borderWidth = s.fieldView.element.value;
              });
            const a = new Bu(e, t);
            return (
              a.set({ label: o('Color'), class: 'ck-table-form__border-color' }),
              a.fieldView.bind('value').to(this, 'borderColor'),
              a.bind('isEnabled').to(this, 'borderStyle', sk),
              a.fieldView.on('input', () => {
                this.borderColor = a.fieldView.value;
              }),
              this.on('change:borderStyle', (t, e, o) => {
                sk(o) || ((this.borderColor = ''), (this.borderWidth = ''));
              }),
              { borderRowLabel: i, borderStyleDropdown: r, borderColorInput: a, borderWidthInput: s }
            );
          }
          _createBackgroundField() {
            const t = this.locale,
              e = this.t,
              o = $w({ colorConfig: this.options.backgroundColors, columns: 5 }),
              i = new Bu(t, o);
            return (
              i.set({ label: e('Background'), class: 'ck-table-cell-properties-form__background' }),
              i.fieldView.bind('value').to(this, 'backgroundColor'),
              i.fieldView.on('input', () => {
                this.backgroundColor = i.fieldView.value;
              }),
              i
            );
          }
          _createDimensionFields() {
            const t = this.locale,
              e = this.t,
              o = new kh(t);
            o.text = e('Dimensions');
            const i = new Bu(t, Hu);
            i.set({ label: e('Width'), class: 'ck-table-form__dimensions-row__width' }),
              i.fieldView.bind('value').to(this, 'width'),
              i.fieldView.on('input', () => {
                this.width = i.fieldView.element.value;
              });
            const n = new sc(t);
            n.setTemplate({
              tag: 'span',
              attributes: { class: ['ck-table-form__dimension-operator'] },
              children: [{ text: '×' }],
            });
            const r = new Bu(t, Hu);
            return (
              r.set({ label: e('Height'), class: 'ck-table-form__dimensions-row__height' }),
              r.fieldView.bind('value').to(this, 'height'),
              r.fieldView.on('input', () => {
                this.height = r.fieldView.element.value;
              }),
              { dimensionsLabel: o, widthInput: i, operatorLabel: n, heightInput: r }
            );
          }
          _createPaddingField() {
            const t = this.locale,
              e = this.t,
              o = new Bu(t, Hu);
            return (
              o.set({ label: e('Padding'), class: 'ck-table-cell-properties-form__padding' }),
              o.fieldView.bind('value').to(this, 'padding'),
              o.fieldView.on('input', () => {
                this.padding = o.fieldView.element.value;
              }),
              o
            );
          }
          _createAlignmentFields() {
            const t = this.locale,
              e = this.t,
              o = new kh(t);
            o.text = e('Table cell text alignment');
            const i = new Dc(t),
              n = 'rtl' === this.locale.contentLanguageDirection;
            i.set({ isCompact: !0, ariaLabel: e('Horizontal text alignment toolbar') }),
              Gw({
                view: this,
                icons: nk,
                toolbar: i,
                labels: this._horizontalAlignmentLabels,
                propertyName: 'horizontalAlignment',
                nameToValue: t => (t === (n ? 'right' : 'left') ? '' : t),
              });
            const r = new Dc(t);
            return (
              r.set({ isCompact: !0, ariaLabel: e('Vertical text alignment toolbar') }),
              Gw({
                view: this,
                icons: nk,
                toolbar: r,
                labels: this._verticalAlignmentLabels,
                propertyName: 'verticalAlignment',
                nameToValue: t => ('middle' === t ? '' : t),
              }),
              { horizontalAlignmentToolbar: i, verticalAlignmentToolbar: r, alignmentLabel: o }
            );
          }
          _createActionButtons() {
            const t = this.locale,
              e = this.t,
              o = new Ac(t),
              i = new Ac(t),
              n = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput];
            return (
              o.set({ label: e('Save'), icon: qu, class: 'ck-button-save', type: 'submit', withText: !0 }),
              o.bind('isEnabled').toMany(n, 'errorText', (...t) => t.every(t => !t)),
              i.set({ label: e('Cancel'), icon: Gu, class: 'ck-button-cancel', type: 'cancel', withText: !0 }),
              i.delegate('execute').to(this, 'cancel'),
              { saveButtonView: o, cancelButtonView: i }
            );
          }
          get _horizontalAlignmentLabels() {
            const t = this.locale,
              e = this.t,
              o = e('Align cell text to the left'),
              i = e('Align cell text to the center'),
              n = e('Align cell text to the right'),
              r = e('Justify cell text');
            return 'rtl' === t.uiLanguageDirection
              ? { right: n, center: i, left: o, justify: r }
              : { left: o, center: i, right: n, justify: r };
          }
          get _verticalAlignmentLabels() {
            const t = this.t;
            return {
              top: t('Align cell text to the top'),
              middle: t('Align cell text to the middle'),
              bottom: t('Align cell text to the bottom'),
            };
          }
        }
        function sk(t) {
          return !!t;
        }
        const ak = {
          borderStyle: 'tableCellBorderStyle',
          borderColor: 'tableCellBorderColor',
          borderWidth: 'tableCellBorderWidth',
          width: 'tableCellWidth',
          height: 'tableCellHeight',
          padding: 'tableCellPadding',
          backgroundColor: 'tableCellBackgroundColor',
          horizontalAlignment: 'tableCellHorizontalAlignment',
          verticalAlignment: 'tableCellVerticalAlignment',
        };
        class lk extends Hc {
          static get requires() {
            return [Qu];
          }
          static get pluginName() {
            return 'TableCellPropertiesUI';
          }
          constructor(t) {
            super(t), t.config.define('table.tableCellProperties', { borderColors: Yw, backgroundColors: Yw });
          }
          init() {
            const t = this.editor,
              e = t.t;
            (this._balloon = t.plugins.get(Qu)),
              (this.view = this._createPropertiesView()),
              (this._undoStepBatch = null),
              t.ui.componentFactory.add('tableCellProperties', o => {
                const i = new Ac(o);
                i.set({
                  label: e('Cell properties'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.105 18l-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="M15.5 11.5l1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>',
                  tooltip: !0,
                }),
                  this.listenTo(i, 'execute', () => this._showView());
                const n = Object.values(ak).map(e => t.commands.get(e));
                return i.bind('isEnabled').toMany(n, 'isEnabled', (...t) => t.some(t => t)), i;
              });
          }
          destroy() {
            super.destroy(), this.view.destroy();
          }
          _createPropertiesView() {
            const t = this.editor,
              e = t.editing.view.document,
              o = t.config.get('table.tableCellProperties'),
              i = Ph(o.borderColors),
              n = Sh(t.locale, i),
              r = Ph(o.backgroundColors),
              s = Sh(t.locale, r),
              a = new rk(t.locale, { borderColors: n, backgroundColors: s }),
              l = t.t;
            a.render(),
              this.listenTo(a, 'submit', () => {
                this._hideView();
              }),
              this.listenTo(a, 'cancel', () => {
                this._undoStepBatch.operations.length && t.execute('undo', this._undoStepBatch), this._hideView();
              }),
              a.keystrokes.set('Esc', (t, e) => {
                this._hideView(), e();
              }),
              this.listenTo(t.ui, 'update', () => {
                Rp(e.selection) ? this._isViewVisible && Dw(t, 'cell') : this._hideView();
              }),
              Nc({
                emitter: a,
                activator: () => this._isViewInBalloon,
                contextElements: [this._balloon.view.element],
                callback: () => this._hideView(),
              });
            const c = Bw(l),
              d = Fw(l);
            return (
              a.on('change:borderStyle', this._getPropertyChangeCallback('tableCellBorderStyle')),
              a.on(
                'change:borderColor',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.borderColorInput,
                  commandName: 'tableCellBorderColor',
                  errorText: c,
                  validator: Hw,
                })
              ),
              a.on(
                'change:borderWidth',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.borderWidthInput,
                  commandName: 'tableCellBorderWidth',
                  errorText: d,
                  validator: Uw,
                })
              ),
              a.on(
                'change:padding',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.paddingInput,
                  commandName: 'tableCellPadding',
                  errorText: d,
                  validator: Ww,
                })
              ),
              a.on(
                'change:width',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.widthInput,
                  commandName: 'tableCellWidth',
                  errorText: d,
                  validator: Ww,
                })
              ),
              a.on(
                'change:height',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.heightInput,
                  commandName: 'tableCellHeight',
                  errorText: d,
                  validator: Ww,
                })
              ),
              a.on(
                'change:backgroundColor',
                this._getValidatedPropertyChangeCallback({
                  viewField: a.backgroundInput,
                  commandName: 'tableCellBackgroundColor',
                  errorText: c,
                  validator: Hw,
                })
              ),
              a.on('change:horizontalAlignment', this._getPropertyChangeCallback('tableCellHorizontalAlignment')),
              a.on('change:verticalAlignment', this._getPropertyChangeCallback('tableCellVerticalAlignment')),
              a
            );
          }
          _fillViewFormFromCommandValues() {
            const t = this.editor.commands;
            Object.entries(ak)
              .map(([e, o]) => [e, t.get(o).value || ''])
              .forEach(([t, e]) => this.view.set(t, e));
          }
          _showView() {
            const t = this.editor;
            this._balloon.add({ view: this.view, position: Lw(t) }),
              (this._undoStepBatch = t.model.createBatch()),
              this._fillViewFormFromCommandValues(),
              this.view.focus();
          }
          _hideView() {
            if (!this._isViewInBalloon) return;
            const t = this.editor;
            this.stopListening(t.ui, 'update'),
              this.view.saveButtonView.focus(),
              this._balloon.remove(this.view),
              this.editor.editing.view.focus();
          }
          get _isViewVisible() {
            return this._balloon.visibleView === this.view;
          }
          get _isViewInBalloon() {
            return this._balloon.hasView(this.view);
          }
          _getPropertyChangeCallback(t) {
            return (e, o, i) => {
              this.editor.execute(t, { value: i, batch: this._undoStepBatch });
            };
          }
          _getValidatedPropertyChangeCallback({ commandName: t, viewField: e, validator: o, errorText: i }) {
            const n = Wr(() => {
              e.errorText = i;
            }, 500);
            return (i, r, s) => {
              n.cancel(),
                o(s) ? (this.editor.execute(t, { value: s, batch: this._undoStepBatch }), (e.errorText = null)) : n();
            };
          }
        }
        function ck(t) {
          t.setNormalizer('padding', Tm('padding')),
            t.setNormalizer('padding-top', t => ({ path: 'padding.top', value: t })),
            t.setNormalizer('padding-right', t => ({ path: 'padding.right', value: t })),
            t.setNormalizer('padding-bottom', t => ({ path: 'padding.bottom', value: t })),
            t.setNormalizer('padding-left', t => ({ path: 'padding.left', value: t })),
            t.setReducer('padding', Cm('padding')),
            t.setStyleRelation('padding', ['padding-top', 'padding-right', 'padding-bottom', 'padding-left']);
        }
        class dk extends Uc {
          constructor(t, e) {
            super(t), (this.attributeName = e);
          }
          refresh() {
            const t = Dp(this.editor.model.document.selection);
            (this.isEnabled = !!t.length), (this.value = this._getSingleValue(t));
          }
          execute(t = {}) {
            const { value: e, batch: o } = t,
              i = this.editor.model,
              n = Dp(i.document.selection),
              r = this._getValueToSet(e);
            i.enqueueChange(o || 'default', t => {
              r
                ? n.forEach(e => t.setAttribute(this.attributeName, r, e))
                : n.forEach(e => t.removeAttribute(this.attributeName, e));
            });
          }
          _getAttribute(t) {
            if (t) return t.getAttribute(this.attributeName);
          }
          _getValueToSet(t) {
            return t;
          }
          _getSingleValue(t) {
            const e = this._getAttribute(t[0]);
            return t.every(t => this._getAttribute(t) === e) ? e : void 0;
          }
        }
        class hk extends dk {
          constructor(t) {
            super(t, 'padding');
          }
          _getAttribute(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        class uk extends dk {
          constructor(t) {
            super(t, 'width');
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        class gk extends dk {
          constructor(t) {
            super(t, 'height');
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        class mk extends dk {
          constructor(t) {
            super(t, 'backgroundColor');
          }
        }
        class fk extends dk {
          constructor(t) {
            super(t, 'verticalAlignment');
          }
        }
        class pk extends dk {
          constructor(t) {
            super(t, 'horizontalAlignment');
          }
        }
        class bk extends dk {
          constructor(t) {
            super(t, 'borderStyle');
          }
          _getAttribute(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
        }
        class wk extends dk {
          constructor(t) {
            super(t, 'borderColor');
          }
          _getAttribute(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
        }
        class kk extends dk {
          constructor(t) {
            super(t, 'borderWidth');
          }
          _getAttribute(t) {
            if (t) return Cp(t.getAttribute(this.attributeName));
          }
          _getValueToSet(t) {
            return Ap(t, 'px');
          }
        }
        const _k = /^(top|bottom)$/;
        class vk extends Hc {
          static get pluginName() {
            return 'TableCellPropertiesEditing';
          }
          static get requires() {
            return [Bb];
          }
          init() {
            const t = this.editor,
              e = t.model.schema,
              o = t.conversion,
              i = t.locale;
            t.data.addStyleProcessorRules(ew),
              (function (t, e) {
                t.extend('tableCell', { allowAttributes: ['borderWidth', 'borderColor', 'borderStyle'] }),
                  pw(e, 'td'),
                  pw(e, 'th'),
                  bw(e, 'tableCell', 'borderStyle', 'border-style'),
                  bw(e, 'tableCell', 'borderColor', 'border-color'),
                  bw(e, 'tableCell', 'borderWidth', 'border-width');
              })(e, o),
              t.commands.add('tableCellBorderStyle', new bk(t)),
              t.commands.add('tableCellBorderColor', new wk(t)),
              t.commands.add('tableCellBorderWidth', new kk(t)),
              (function (t, e, o) {
                t.extend('tableCell', { allowAttributes: ['horizontalAlignment'] });
                const i = ['rtl' == o.contentLanguageDirection ? 'left' : 'right', 'center', 'justify'];
                e.attributeToAttribute({
                  model: { name: 'tableCell', key: 'horizontalAlignment', values: i },
                  view: i.reduce((t, e) => ({ ...t, [e]: { key: 'style', value: { 'text-align': e } } }), {}),
                });
              })(e, o, i),
              t.commands.add('tableCellHorizontalAlignment', new pk(t)),
              yk(e, o, 'width', 'width'),
              t.commands.add('tableCellWidth', new uk(t)),
              yk(e, o, 'height', 'height'),
              t.commands.add('tableCellHeight', new gk(t)),
              t.data.addStyleProcessorRules(ck),
              yk(e, o, 'padding', 'padding'),
              t.commands.add('tableCellPadding', new hk(t)),
              t.data.addStyleProcessorRules(gw),
              yk(e, o, 'backgroundColor', 'background-color'),
              t.commands.add('tableCellBackgroundColor', new mk(t)),
              (function (t, e) {
                t.extend('tableCell', { allowAttributes: ['verticalAlignment'] }),
                  e.attributeToAttribute({
                    model: { name: 'tableCell', key: 'verticalAlignment', values: ['top', 'bottom'] },
                    view: {
                      top: { key: 'style', value: { 'vertical-align': 'top' } },
                      bottom: { key: 'style', value: { 'vertical-align': 'bottom' } },
                    },
                  }),
                  e.for('upcast').attributeToAttribute({
                    view: { attributes: { valign: _k } },
                    model: { name: 'tableCell', key: 'verticalAlignment', value: t => t.getAttribute('valign') },
                  });
              })(e, o),
              t.commands.add('tableCellVerticalAlignment', new fk(t));
          }
        }
        function yk(t, e, o, i) {
          t.extend('tableCell', { allowAttributes: [o] }), fw(e, 'tableCell', o, i), bw(e, 'tableCell', o, i);
        }
        class xk {
          constructor(t, e) {
            (this.model = t),
              (this.testCallback = e),
              (this.hasMatch = !1),
              this.set('isEnabled', !0),
              this.on('change:isEnabled', () => {
                this.isEnabled
                  ? this._startListening()
                  : (this.stopListening(t.document.selection), this.stopListening(t.document));
              }),
              this._startListening();
          }
          _startListening() {
            const t = this.model.document;
            this.listenTo(t.selection, 'change:range', (e, { directChange: o }) => {
              o &&
                (t.selection.isCollapsed
                  ? this._evaluateTextBeforeSelection('selection')
                  : this.hasMatch && (this.fire('unmatched'), (this.hasMatch = !1)));
            }),
              this.listenTo(t, 'change:data', (t, e) => {
                'transparent' != e.type && this._evaluateTextBeforeSelection('data', { batch: e });
              });
          }
          _evaluateTextBeforeSelection(t, e = {}) {
            const o = this.model,
              i = o.document.selection,
              n = o.createRange(o.createPositionAt(i.focus.parent, 0), i.focus),
              { text: r, range: s } = rd(n, o),
              a = this.testCallback(r);
            if ((!a && this.hasMatch && this.fire('unmatched'), (this.hasMatch = !!a), a)) {
              const o = Object.assign(e, { text: r, range: s });
              'object' == typeof a && Object.assign(o, a), this.fire('matched:' + t, o);
            }
          }
        }
        xo(xk, Hi);
        var Ck = /[\\^$.*+?()[\]{}|]/g,
          Ak = RegExp(Ck.source);
        var Tk = function (t) {
          return (t = Zo(t)) && Ak.test(t) ? t.replace(Ck, '\\$&') : t;
        };
        const Sk = {
            copyright: { from: '(c)', to: '©' },
            registeredTrademark: { from: '(r)', to: '®' },
            trademark: { from: '(tm)', to: '™' },
            oneHalf: { from: '1/2', to: '½' },
            oneThird: { from: '1/3', to: '⅓' },
            twoThirds: { from: '2/3', to: '⅔' },
            oneForth: { from: '1/4', to: '¼' },
            threeQuarters: { from: '3/4', to: '¾' },
            lessThanOrEqual: { from: '<=', to: '≤' },
            greaterThanOrEqual: { from: '>=', to: '≥' },
            notEqual: { from: '!=', to: '≠' },
            arrowLeft: { from: '<-', to: '←' },
            arrowRight: { from: '->', to: '→' },
            horizontalEllipsis: { from: '...', to: '…' },
            enDash: { from: /(^| )(--)( )$/, to: [null, '–', null] },
            emDash: { from: /(^| )(---)( )$/, to: [null, '—', null] },
            quotesPrimary: { from: Rk('"'), to: [null, '“', null, '”'] },
            quotesSecondary: { from: Rk("'"), to: [null, '‘', null, '’'] },
            quotesPrimaryEnGb: { from: Rk("'"), to: [null, '‘', null, '’'] },
            quotesSecondaryEnGb: { from: Rk('"'), to: [null, '“', null, '”'] },
            quotesPrimaryPl: { from: Rk('"'), to: [null, '„', null, '”'] },
            quotesSecondaryPl: { from: Rk("'"), to: [null, '‚', null, '’'] },
          },
          Pk = {
            symbols: ['copyright', 'registeredTrademark', 'trademark'],
            mathematical: [
              'oneHalf',
              'oneThird',
              'twoThirds',
              'oneForth',
              'threeQuarters',
              'lessThanOrEqual',
              'greaterThanOrEqual',
              'notEqual',
              'arrowLeft',
              'arrowRight',
            ],
            typography: ['horizontalEllipsis', 'enDash', 'emDash'],
            quotes: ['quotesPrimary', 'quotesSecondary'],
          },
          Ek = ['symbols', 'mathematical', 'typography', 'quotes'];
        function Mk(t) {
          return 'string' == typeof t ? new RegExp(`(${Tk(t)})$`) : t;
        }
        function Ik(t) {
          return 'string' == typeof t ? () => [t] : t instanceof Array ? () => t : t;
        }
        function Nk(t) {
          return (t.textNode ? t.textNode : t.nodeAfter).getAttributes();
        }
        function Rk(t) {
          return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
        }
        class Ok extends Hc {
          static get pluginName() {
            return 'UnderlineEditing';
          }
          init() {
            const t = this.editor;
            t.model.schema.extend('$text', { allowAttributes: 'underline' }),
              t.model.schema.setAttributeProperties('underline', { isFormatting: !0, copyOnEnter: !0 }),
              t.conversion.attributeToElement({
                model: 'underline',
                view: 'u',
                upcastAlso: { styles: { 'text-decoration': 'underline' } },
              }),
              t.commands.add('underline', new fd(t, 'underline')),
              t.keystrokes.set('CTRL+U', 'underline');
          }
        }
        class Vk extends Hc {
          init() {
            const t = this.editor,
              e = t.t;
            t.ui.componentFactory.add('underline', o => {
              const i = t.commands.get('underline'),
                n = new Ac(o);
              return (
                n.set({
                  label: e('Underline'),
                  icon:
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>',
                  keystroke: 'CTRL+U',
                  tooltip: !0,
                  isToggleable: !0,
                }),
                n.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled'),
                this.listenTo(n, 'execute', () => {
                  t.execute('underline'), t.editing.view.focus();
                }),
                n
              );
            });
          }
        }
        class Dk extends Fc {}
        Dk.builtinPlugins = [
          class extends Hc {
            static get requires() {
              return [Jc, id];
            }
            static get pluginName() {
              return 'Alignment';
            }
          },
          class extends Hc {
            static get pluginName() {
              return 'Autoformat';
            }
            afterInit() {
              this._addListAutoformats(),
                this._addBasicStylesAutoformats(),
                this._addHeadingAutoformats(),
                this._addBlockQuoteAutoformats(),
                this._addCodeBlockAutoformats();
            }
            _addListAutoformats() {
              const t = this.editor.commands;
              t.get('bulletedList') && new nd(this.editor, /^[*-]\s$/, 'bulletedList'),
                t.get('numberedList') && new nd(this.editor, /^1[.|)]\s$/, 'numberedList');
            }
            _addBasicStylesAutoformats() {
              const t = this.editor.commands;
              if (t.get('bold')) {
                const t = ld(this.editor, 'bold');
                new sd(this.editor, /(\*\*)([^*]+)(\*\*)$/g, t), new sd(this.editor, /(__)([^_]+)(__)$/g, t);
              }
              if (t.get('italic')) {
                const t = ld(this.editor, 'italic');
                new sd(this.editor, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, t),
                  new sd(this.editor, /(?:^|[^_])(_)([^_]+)(_)$/g, t);
              }
              if (t.get('code')) {
                const t = ld(this.editor, 'code');
                new sd(this.editor, /(`)([^`]+)(`)$/g, t);
              }
              if (t.get('strikethrough')) {
                const t = ld(this.editor, 'strikethrough');
                new sd(this.editor, /(~~)([^~]+)(~~)$/g, t);
              }
            }
            _addHeadingAutoformats() {
              const t = this.editor.commands.get('heading');
              t &&
                t.modelElements
                  .filter(t => t.match(/^heading[1-6]$/))
                  .forEach(e => {
                    const o = e[7],
                      i = new RegExp(`^(#{${o}})\\s$`);
                    new nd(this.editor, i, () => {
                      if (!t.isEnabled) return !1;
                      this.editor.execute('heading', { value: e });
                    });
                  });
            }
            _addBlockQuoteAutoformats() {
              this.editor.commands.get('blockQuote') && new nd(this.editor, /^>\s$/, 'blockQuote');
            }
            _addCodeBlockAutoformats() {
              this.editor.commands.get('codeBlock') && new nd(this.editor, /^```$/, 'codeBlock');
            }
          },
          class extends Hc {
            static get requires() {
              return [gd, md];
            }
            static get pluginName() {
              return 'BlockQuote';
            }
          },
          class extends Hc {
            static get requires() {
              return [pd, bd];
            }
            static get pluginName() {
              return 'Bold';
            }
          },
          class extends Hc {
            static get requires() {
              return [vd, Td, Vd, Md, Qd, fh];
            }
            static get pluginName() {
              return 'Essentials';
            }
          },
          class extends Hc {
            static get requires() {
              return [Th, Ih];
            }
            static get pluginName() {
              return 'FontBackgroundColor';
            }
          },
          class extends Hc {
            static get requires() {
              return [Rh, Oh];
            }
            static get pluginName() {
              return 'FontColor';
            }
          },
          class extends Hc {
            static get requires() {
              return [jh, Fh];
            }
            static get pluginName() {
              return 'FontSize';
            }
          },
          class extends Hc {
            static get requires() {
              return [Kh, Jh];
            }
            static get pluginName() {
              return 'Heading';
            }
          },
          class extends Hc {
            static get requires() {
              return [Xh, eu];
            }
            static get pluginName() {
              return 'Highlight';
            }
          },
          class extends Hc {
            static get requires() {
              return [Eu, Du, tg];
            }
            static get pluginName() {
              return 'Image';
            }
          },
          class extends Hc {
            static get requires() {
              return [ig];
            }
            static get pluginName() {
              return 'ImageCaption';
            }
          },
          class extends Hc {
            static get requires() {
              return [ug];
            }
            static get pluginName() {
              return 'ImageResize';
            }
            init() {
              const t = this.editor,
                e = new gg(t);
              this._registerSchema(),
                this._registerConverters(),
                t.commands.add('imageResize', e),
                t.editing.downcastDispatcher.on(
                  'insert:image',
                  (o, i, n) => {
                    const r = n.mapper.toViewElement(i.item),
                      s = t.plugins.get(ug).attachTo({
                        unit: t.config.get('image.resizeUnit') || '%',
                        modelElement: i.item,
                        viewElement: r,
                        editor: t,
                        getHandleHost: t => t.querySelector('img'),
                        getResizeHost: t => t,
                        isCentered() {
                          const t = i.item.getAttribute('imageStyle');
                          return !t || 'full' == t || 'alignCenter' == t;
                        },
                        onCommit(e) {
                          t.execute('imageResize', { width: e });
                        },
                      });
                    s.on('updateSize', () => {
                      r.hasClass('image_resized') ||
                        t.editing.view.change(t => {
                          t.addClass('image_resized', r);
                        });
                    }),
                      s.bind('isEnabled').to(e);
                  },
                  { priority: 'low' }
                );
            }
            _registerSchema() {
              this.editor.model.schema.extend('image', { allowAttributes: 'width' });
            }
            _registerConverters() {
              const t = this.editor;
              t.conversion.for('downcast').add(t =>
                t.on('attribute:width:image', (t, e, o) => {
                  if (!o.consumable.consume(e.item, t.name)) return;
                  const i = o.writer,
                    n = o.mapper.toViewElement(e.item);
                  null !== e.attributeNewValue
                    ? (i.setStyle('width', e.attributeNewValue, n), i.addClass('image_resized', n))
                    : (i.removeStyle('width', n), i.removeClass('image_resized', n));
                })
              ),
                t.conversion.for('upcast').attributeToAttribute({
                  view: { name: 'figure', styles: { width: /.+/ } },
                  model: { key: 'width', value: t => t.getStyle('width') },
                });
            }
          },
          class extends Hc {
            static get requires() {
              return [Cg, Ag];
            }
            static get pluginName() {
              return 'ImageStyle';
            }
          },
          class extends Hc {
            static get requires() {
              return [Tg];
            }
            static get pluginName() {
              return 'ImageToolbar';
            }
            afterInit() {
              const t = this.editor,
                e = t.t;
              t.plugins.get(Tg).register('image', {
                ariaLabel: e('Image toolbar'),
                items: t.config.get('image.toolbar') || [],
                getRelatedElement: yu,
              });
            }
          },
          class extends Hc {
            static get pluginName() {
              return 'ImageUpload';
            }
            static get requires() {
              return [$g, Ng, Lg];
            }
          },
          class extends Hc {
            static get pluginName() {
              return 'Indent';
            }
            static get requires() {
              return [Jg, tm];
            }
          },
          class extends Hc {
            constructor(t) {
              super(t), t.config.define('indentBlock', { offset: 40, unit: 'px' });
            }
            static get pluginName() {
              return 'IndentBlock';
            }
            init() {
              const t = this.editor,
                e = t.config.get('indentBlock'),
                o = !e.classes || !e.classes.length,
                i = Object.assign({ direction: 'forward' }, e),
                n = Object.assign({ direction: 'backward' }, e);
              o
                ? (t.data.addStyleProcessorRules(Pm),
                  this._setupConversionUsingOffset(t.conversion),
                  t.commands.add('indentBlock', new em(t, new om(i))),
                  t.commands.add('outdentBlock', new em(t, new om(n))))
                : (this._setupConversionUsingClasses(e.classes),
                  t.commands.add('indentBlock', new em(t, new im(i))),
                  t.commands.add('outdentBlock', new em(t, new im(n))));
            }
            afterInit() {
              const t = this.editor,
                e = t.model.schema,
                o = t.commands.get('indent'),
                i = t.commands.get('outdent');
              ['paragraph', 'heading1', 'heading2', 'heading3', 'heading4', 'heading5', 'heading6'].forEach(t => {
                e.isRegistered(t) && e.extend(t, { allowAttributes: 'blockIndent' });
              }),
                o.registerChildCommand(t.commands.get('indentBlock')),
                i.registerChildCommand(t.commands.get('outdentBlock'));
            }
            _setupConversionUsingOffset() {
              const t = this.editor.conversion,
                e = 'rtl' === this.editor.locale.contentLanguageDirection ? 'margin-right' : 'margin-left';
              t.for('upcast').attributeToAttribute({
                view: { styles: { [e]: /[\s\S]+/ } },
                model: { key: 'blockIndent', value: t => t.getStyle(e) },
              }),
                t
                  .for('downcast')
                  .attributeToAttribute({ model: 'blockIndent', view: t => ({ key: 'style', value: { [e]: t } }) });
            }
            _setupConversionUsingClasses(t) {
              const e = { model: { key: 'blockIndent', values: [] }, view: {} };
              for (const o of t) e.model.values.push(o), (e.view[o] = { key: 'class', value: [o] });
              this.editor.conversion.attributeToAttribute(e);
            }
          },
          class extends Hc {
            static get requires() {
              return [Em, Mm];
            }
            static get pluginName() {
              return 'Italic';
            }
          },
          class extends Hc {
            static get requires() {
              return [uf, pf];
            }
            static get pluginName() {
              return 'Link';
            }
          },
          class extends Hc {
            static get requires() {
              return [Hf, Uf];
            }
            static get pluginName() {
              return 'List';
            }
          },
          class extends Hc {
            static get requires() {
              return [Xf, ip, ep, Du];
            }
            static get pluginName() {
              return 'MediaEmbed';
            }
          },
          qh,
          class extends Hc {
            static get pluginName() {
              return 'PasteFromOffice';
            }
            static get requires() {
              return [vd];
            }
            init() {
              const t = this.editor,
                e = t.editing.view.document,
                o = [];
              o.push(new mp(e)),
                o.push(new lp(e)),
                t.plugins.get('Clipboard').on(
                  'inputTransformation',
                  (t, e) => {
                    if (e.isTransformedWithPasteFromOffice) return;
                    const i = e.dataTransfer.getData('text/html'),
                      n = o.find(t => t.isActive(i));
                    n && (n.execute(e), (e.isTransformedWithPasteFromOffice = !0));
                  },
                  { priority: 'high' }
                );
            }
          },
          class extends Hc {
            static get requires() {
              return [bp, fp];
            }
            static get pluginName() {
              return 'RemoveFormat';
            }
          },
          class extends Hc {
            static get requires() {
              return [Dg];
            }
            static get pluginName() {
              return 'SimpleUploadAdapter';
            }
            init() {
              const t = this.editor.config.get('simpleUpload');
              t &&
                (t.uploadUrl
                  ? (this.editor.plugins.get(Dg).createUploadAdapter = e => new wp(e, t))
                  : console.warn(
                      Object(uo.a)(
                        'simple-upload-adapter-missing-uploadUrl: Missing the "uploadUrl" property in the "simpleUpload" editor configuration.'
                      )
                    ));
            }
          },
          class extends Hc {
            static get requires() {
              return [kp, _p];
            }
            static get pluginName() {
              return 'Strikethrough';
            }
          },
          class extends Hc {
            static get requires() {
              return [Bb, Wb, $b, Kb, tw, Du];
            }
            static get pluginName() {
              return 'Table';
            }
          },
          class extends Hc {
            static get pluginName() {
              return 'TableCellProperties';
            }
            static get requires() {
              return [vk, lk];
            }
          },
          class extends Hc {
            static get pluginName() {
              return 'TableProperties';
            }
            static get requires() {
              return [Pw, ik];
            }
          },
          class extends Hc {
            static get requires() {
              return [Tg];
            }
            static get pluginName() {
              return 'TableToolbar';
            }
            afterInit() {
              const t = this.editor,
                e = t.t,
                o = t.plugins.get(Tg),
                i = t.config.get('table.contentToolbar'),
                n = t.config.get('table.tableToolbar');
              i && o.register('tableContent', { ariaLabel: e('Table toolbar'), items: i, getRelatedElement: Rp }),
                n && o.register('table', { ariaLabel: e('Table toolbar'), items: n, getRelatedElement: Np });
            }
          },
          class extends Hc {
            static get pluginName() {
              return 'TextTransformation';
            }
            constructor(t) {
              super(t), t.config.define('typing', { transformations: { include: Ek } });
            }
            init() {
              const t = this.editor.model.document.selection;
              t.on('change:range', () => {
                this.isEnabled = !t.anchor.parent.is('codeBlock');
              }),
                this._enableTransformationWatchers();
            }
            _enableTransformationWatchers() {
              const t = this.editor,
                e = t.model,
                o = t.plugins.get('Input'),
                i = (function (t) {
                  const e = t.extra || [],
                    o = t.remove || [],
                    i = t => !o.includes(t);
                  return (function (t) {
                    const e = new Set();
                    for (const o of t)
                      if (Pk[o]) for (const t of Pk[o]) e.add(t);
                      else e.add(o);
                    return Array.from(e);
                  })(t.include.concat(e).filter(i))
                    .filter(i)
                    .map(t => Sk[t] || t)
                    .map(t => ({ from: Mk(t.from), to: Ik(t.to) }));
                })(t.config.get('typing.transformations')),
                n = new xk(t.model, t => {
                  for (const e of i) {
                    if (e.from.test(t)) return { normalizedTransformation: e };
                  }
                });
              n.on('matched:data', (t, i) => {
                if (!o.isInput(i.batch)) return;
                const { from: n, to: r } = i.normalizedTransformation,
                  s = n.exec(i.text),
                  a = r(s.slice(1)),
                  l = i.range;
                let c = s.index;
                e.enqueueChange(t => {
                  for (let o = 1; o < s.length; o++) {
                    const i = s[o],
                      n = a[o - 1];
                    if (null == n) {
                      c += i.length;
                      continue;
                    }
                    const r = l.start.getShiftedBy(c),
                      d = e.createRange(r, r.getShiftedBy(i.length)),
                      h = Nk(r);
                    e.insertContent(t.createText(n, h), d), (c += n.length);
                  }
                });
              }),
                n.bind('isEnabled').to(this);
            }
          },
          class extends Hc {
            static get requires() {
              return [Ok, Vk];
            }
            static get pluginName() {
              return 'Underline';
            }
          },
        ];
        e.default = Dk;
      },
    ]).default;
  });
//# sourceMappingURL=ckeditor.js.map
